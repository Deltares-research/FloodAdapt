<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Event scenario – Flood Adapt Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../5_technical_docs/RiskScenario.html" rel="next">
<link href="../_static/logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-562b512568abf03695ff183f679b8708.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-0a88f9bf3c7dc6da7549435e9e0a9869.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-562b512568abf03695ff183f679b8708.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 5,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../_static/styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../_static/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">FloodAdapt</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../1_introduction/index.html"> 
<span class="menu-text">Introduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../4_user_guide/index.html"> 
<span class="menu-text">User Guide</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../3_setup_guide/index.html"> 
<span class="menu-text">Setup Guide</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../5_technical_docs/index.html"> 
<span class="menu-text">Technical Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../api_ref/api_index.html"> 
<span class="menu-text">API Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../examples/index.html"> 
<span class="menu-text">Examples</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Deltares-research/FloodAdapt"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../5_technical_docs/EventScenario.html">Event scenario</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../5_technical_docs/EventScenario.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Event scenario</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../5_technical_docs/RiskScenario.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Risk Scenario</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../5_technical_docs/EquityCalc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Equity Calculation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../5_technical_docs/BenefitCalc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Benefit Calculation</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="-1">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#hazard-calculation" id="toc-hazard-calculation" class="nav-link active" data-scroll-target="#hazard-calculation">Hazard calculation</a></li>
  <li><a href="#impact-calculation" id="toc-impact-calculation" class="nav-link" data-scroll-target="#impact-calculation">Impact calculation</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Deltares-research/FloodAdapt/blob/main/5_technical_docs/EventScenario.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/Deltares-research/FloodAdapt/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Event scenario</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The FloodAdapt calculation framework to calculate flooding and impacts for an event scenario will be described here, first for the flooding (<a href="#hazard-calculation">hazard calculation</a>) and then for the <a href="#impact-calculation">impact calculation</a>.</p>
<p>The calculation framework includes the open-source, process-based compound flood model <a href="https://github.com/Deltares/SFINCS">SFINCS</a> that can accurately predict compound flooding due to tide, surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. It also includes the open-source flood impact assessment tool <a href="https://github.com/Deltares/Delft-FIAT">Delft-FIAT</a> which rapidly calculates flood damages to individual buildings and roads. When FloodAdapt is set up in a new location, <strong>baseline</strong> SFINCS and Delft-FIAT models must be set up as part of that process. FloodAdapt then updates these baseline models to reflect user-defined scenarios, runs the simulations, and post-processes the output to make the evaluation of the scenario as easy as possible for the user. The FloodAdapt setup guide provides guidance for setting up these baseline models: click the links to view the <a href="../3_setup_guide/SFINCS/index.html">SFINCS setup guide</a> and <a href="../3_setup_guide/Delft_Fiat/index.html">Delft-FIAT setup guide</a>.</p>
<section id="hazard-calculation" class="level2">
<h2 class="anchored" data-anchor-id="hazard-calculation">Hazard calculation</h2>
<p>Through the use of the FloodAdapt user interface, users enter information on (1) a hydrometeorological event, (2) a projection of future conditions, and (3) a strategy composed of adaptation measures. These three ‘ingredients’ define an event scenario. FloodAdapt uses this information to initiate the workflow to calculate flooding and impacts for the event scenario. <a href="#fig-workflow_event_hazard" class="quarto-xref">Figure&nbsp;1</a> zooms in on the hazard calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.</p>
<p>In FloodAdapt there is the option to include two SFINCS models - an “offshore” model and an “overland” model. The offshore model is typically a coarser model with an offshore domain adjacent to the area of interest. It is forced by astronomic tide and wind, pressure, and precipitation fields, and calculates nearshore water level time series that serve as boundary conditions for the overland model. The overland model is typically finer resolution and its domain is a hydrological area over land that includes the project area of interest. Only the overland model is strictly necessary in FloodAdapt, but some event types will not be possible without an offshore model, most notably hurricanes.</p>
<div id="fig-workflow_event_hazard" class="quarto-float quarto-figure quarto-figure-left anchored" data-fig-align="left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-workflow_event_hazard-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="../_static/images/Workflow_eventScenario_hazard.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Hazard calculation framework for an event scenario"><img src="../_static/images/Workflow_eventScenario_hazard.jpg" class="img-fluid quarto-figure quarto-figure-left figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-workflow_event_hazard-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: <strong>Hazard calculation framework for an event scenario</strong>
</figcaption>
</figure>
</div>
<p>The hydro-meteorological event is defined by an “event type”. This is either (1) a historical hurricane, (2) a historical non-hurricane, or (3) a synthetic event. For a historical non-hurricane, there are further two options - (2a) the user has nearshore observed time series of coastal water levels, or (2b) the user does not have observed time series and needs to run an offshore model to generate the nearshore water level time series. Each of these four types has a unique workflow for calculating the overland flooding, which will be described in the coming paragraphs.</p>
<p>What is common to all the overland flooding workflows is the handling of <strong>adaptation measures</strong>. There are three measure types in FloodAdapt that affect the flood modeling: (1) levee or floodwall, (2) pump, and (3) urban green infrastructure. All of these choices initiate modifications to the overland SFINCS model schematization. When users specify a levee or floodwall as an adaptation measure, FloodAdapt coordinates the updating of the “weir” file in the SFINCS overland model. This file contains coordinates of linear features and their elevation, and serve to block flow in the overland model up to the specified height of the floodwall or levee. The FloodAdapt user interfaces allows users to click a polyline on a map, or import a polyline, and then uses the specifications (location and elevation) to update the weir file. When users specify a pump as (part of) an adaptation measure, FloodAdapt coordinates the updating of the “drn” (drainage) file in the SFINCS overland model. This file contains the coordinates of the intake and outfall locations and the pump capacity. When a user specifies green infrastructure as a measure, FloodAdapt coordinates the creation or updating of a storage volume input for the SFINCS overland model, based on the green infrastructure area and storage specified. SFINCS ‘stores’ this water volume (defined per cell) before any overland flooding takes place.</p>
<p>For <strong>historical hurricanes</strong>, the track information is pulled by the user interface from the National Hurricane Center HURDAT2 database. The first step in the workflow is to translate the track information, like maximum wind speeds and radius, into the wind, pressure, and precipitation fields needed by the offshore SFINCS model. The wind and pressure fields are generated using the <a href="https://journals.ametsoc.org/view/journals/mwre/138/12/2010mwr3317.1.xml">Holland 2010 method</a> and the rainfall field is generated using the <a href="https://www.sciencedirect.com/science/article/abs/pii/S0022169419309904">IPET method</a>. This translation is done by an open-source python package called the Coastal Hazard Toolkit - Cyclone, or <a href="https://github.com/Deltares-research/cht_cyclones">CHT-cyclone</a>. The astronomic tidal boundary for the offshore SFINCS model is obtained using another CHT package called CHT-tide. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The wind, pressure, and precipitation fields and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels (tide + surge). The input to the SFINCS overland model includes the simulated nearshore water level time series, the wind, pressure, and precipitation fields generated from the track, and any river discharge time series specified by the user in the user interface (when rivers are present in the site). It is also possible in FloodAdapt for a user to “turn off” the rainfall in the overland model, for example to explore the difference in flooding with and without the inclusion of rainfall. Using these inputs, the SFINCS overland model is run and the resulting maximum flood depth maps are returned. Additionally, if “observation points” have been specified when the FloodAdapt system was configured, water level time series will be saved for these locations.</p>
<p>For a <strong>historical event without observed nearshore water levels</strong>, FloodAdapt orchestrates the downloading of gridded wind, pressure, and precipitation data from the <a href="https://www.ncei.noaa.gov/products/weather-climate-models/global-forecast">NOAA global forecasting system</a> reanalysis data. These data are available at a spatial resolution of 0.5 degrees for dates prior to February 2021, and 0.25 degrees after. The downloading and formatting of these data are done with the Coastal Hazard Toolkit package <a href="https://github.com/Deltares-research/cht_meteo">CHT-meteo</a>. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The gridded wind, pressure, and precipitation data and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels. For this event type, users are able to specify rainfall, wind, and river discharge inputs for the overland flood model. These values, together with the simulated nearshore water levels are input into the overland flood model which outputs maximum flood depth maps and - if “observation points” have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Sea level offset for offshore simulations
</div>
</div>
<div class="callout-body-container callout-body">
<p>For hazard simulations that use the offshore SFINCS model, the nearshore water levels are returned relative to mean sea level. However, sea levels have risen since the mean sea level was set for the 1983-2001 epoch. This discrepancy results in predicted/simulated nearshore water levels that are lower than what would be observed at a tide gauge. Trend analysis can be done to determine an appropriate level of “offset” to correct mean sea level to present day conditions. This value is set in the FloodAdapt site configuration file, and can be modified by an advanced user. The offset is applied in the workflow where the future-condition sea level rise is added. This is only done for offshore events, because nearshore gauged data represent observed water levels and will already include sea level increases in the measurements. Similarly, for synthetic events, it is assumed that users will select a nearshore water level of interest, and any sea level rise of interest will be captured as a projection relative to current conditions.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Vertical datum references in the offshore and overland models
</div>
</div>
<div class="callout-body-container callout-body">
<p>If there is a difference in vertical datum between the offshore and overland model, FloodAdapt automatically corrects the water level time series output from the offshore model to the datum used in the overland model prior to running the overland model.</p>
</div>
</div>
<p>For a <strong>historical event with observed nearshore water levels</strong>, FloodAdapt offers the user the choice to upload their own time series data of nearshore water levels, or the user can specify a start and stop time of the event and click the ‘Download water levels button’ which downloads the time series data from the <a href="https://tidesandcurrents.noaa.gov/products.html">NOAA</a> website. More details about this and how users can specify or import rainfall, wind, and river discharge data for the event are provided in the user manual <a href="../4_user_guide/events/historic_events/historic_events_gauged.html">here</a>. If the user has specified sea level rise in their scenario future-conditions projection, it will be added to the specified nearshore water levels at this point in the workflow prior to running the overland model. For this event type, only the SFINCS overland model needs to be run. The water level time series, rainfall, wind, and river discharge inputs are used to force the overland model, which then outputs maximum flood depth maps and - if “observation points” have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.</p>
<p>For a <strong>synthetic event</strong>, the workflow to derive the flood map and simulated water level time series at observation points is identical to the workflow for the historical event with observed nearshore water levels. It only differs in terms of the specification of the forcing data. To see more details on how users can specify synthetic events in the user manual <a href="../4_user_guide/events/synthetic_events.html">here</a>.</p>
</section>
<section id="impact-calculation" class="level2">
<h2 class="anchored" data-anchor-id="impact-calculation">Impact calculation</h2>
<p>Once a hazard calculation is complete, FloodAdapt initiates the impact calculation, making use of the simulated flood depth map. <a href="#fig-workflow_event_impacts" class="quarto-xref">Figure&nbsp;2</a> zooms in on the impact calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.</p>
<p>In the user interface, the user is able to specify impact-related future conditions (economic growth and/or population growth) and impact-reducing adaptation options: buyout, elevate, and floodproof. The user manual describes how a user can specify impact-related projections <a href="../4_user_guide/projections/socioEconomic.html">here</a> and impact-reducting adaptation options <a href="../4_user_guide/measures/buildings.html">here</a>. When a scenario is created containing any of these features it initiates a modification of the baseline Delft-FIAT model.</p>
<div id="fig-workflow_event_impacts" class="quarto-float quarto-figure quarto-figure-left anchored" data-fig-align="left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-workflow_event_impacts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="../_static/images/Workflow_eventScenario_impacts.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: Impact calculation framework for an event scenario"><img src="../_static/images/Workflow_eventScenario_impacts.jpg" class="img-fluid quarto-figure quarto-figure-left figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-workflow_event_impacts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: <strong>Impact calculation framework for an event scenario</strong>
</figcaption>
</figure>
</div>
<p>There are three <strong>impact-reducing adaptation measures</strong> in FloodAdapt that affect the impact model schematization: (1) buyouts (2) elevate, and (3) floodproof. These are all measures taken at the building level. When users specify a <strong>buyout</strong> measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attributes “maximum potential damages - structure” and “maximum potential damages - content”, setting them both to zero for buildings selected for buyout. This ensures that these buildings no longer accrue any damage during flood events. When users specify an <strong>elevate</strong> measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attribute “finished floor height”, setting it to the user-specified height. Users are able to elevate buildings to a specified height above base flood elevation (BFE) if they have included a BFE map during system setup. In this case, FloodAdapt calculates the elevation of the finished floor using the BFE and specified height above BFE, and then subtracts the ground elevation at the building location to determine the required finished floor height. The ground elevation is an attribute of the building in the Delft-FIAT exposure data (which should be aligned with the DEM used in the flood model, something that is arranged during system setup). When users specify a <strong>floodproofing</strong> measure, FloodAdapt coordinates the updating of the depth-damage curves for the buildings selected for floodproofing. It sets the damage fraction to zero in the depth-damage curve up to the floodpoofing height. After that height, the depth-damage curve resumes its original shape.</p>
<p><strong>Future socio-economic projections</strong> also initiate updating of the Delft-FIAT model. Users can choose economic growth or population growth. For <strong>population growth</strong> there are two options: (1) the population increases in the current built area or (2) population increases in currently undeveloped areas. For the former, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes “maximum potential damages - structure” and “maximum potential damages - content” by the percentage population increase specified. The idea is that the building stock density will increase, and hence also the potential damages during flood events. For population growth in currently-undeveloped areas, FloodAdapt coordinates the creation of a hybrid exposure asset with the footprint of the specified to-be-developed area. The attributes of this hybrid asset are a weighted average of the existing exposed assets, meaning the new area is assumed to reflect the make-up (in terms of building types) of the existing built area. This method was implemented to evaluate future development and assess how it will contribute to risk in the future. The method allows for users to specify the finished floor height of the new development buildings, helping to provide a foundation for ordinances on new development heights. NOTE: the “population growth in new development areas” feature is under-tested and is considered by the FloodAdapt development team to be in need of improvements before it reaches its potential. When users enter a percentage for <strong>economic growth</strong>, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes “maximum potential damages - structure” and “maximum potential damages - content” by the percentage economic growth specified.</p>
<p>Once the Delft-FIAT model schematization has been updated, FloodAdapt coordinates the running of Delft-FIAT with the simulated flood depth map from the hazard calculation. The calculation method of Delft-FIAT follows a standard approach and is described in the <a href="https://github.com/Deltares/Delft-FIAT" class="external" data-link-external-newwindow="true">Delft-FIAT github documentation</a> and in the <a href="../3_setup_guide/Delft_Fiat/index.html">Delft-FIAT setup documentation</a>. <a href="#fig-DF_overview2" class="quarto-xref">Figure&nbsp;3</a> shows conceptually how Delft-FIAT calculates damages. Note that no indirect damages are calculated with Delft-FIAT, only direct damages to assets in the exposure dataset.</p>
<div id="fig-DF_overview2" class="quarto-float quarto-figure quarto-figure-left anchored" data-fig-align="left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-DF_overview2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="../_static/images/DelftFIAT_overview.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Overview of the calculation method in Delft-FIAT"><img src="../_static/images/DelftFIAT_overview.png" class="img-fluid quarto-figure quarto-figure-left figure-img" style="width:75.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-DF_overview2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Overview of the calculation method in Delft-FIAT
</figcaption>
</figure>
</div>
<p>The impact calculation returns inundation depths and economic damages for every asset in the Delft-FIAT model. These results are passed through a <a href="https://github.com/Deltares/fiat_toolbox">post-processing toolkit</a>. This aggregates the damages to aggregation levels specified during system setup, creates vector files of impacts, and generates the FloodAdapt infographic and metrics.</p>
<p>To read more about the output from an event scenario calculation, please see the user manual section on Output <a href="../4_user_guide/output/index.html">here</a>.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
  </div>
  <div class="nav-page nav-page-next">
      <a href="../5_technical_docs/RiskScenario.html" class="pagination-link" aria-label="Risk Scenario">
        <span class="nav-page-text">Risk Scenario</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Made possible by: <a href="https://www.deltares.nl/en" target="_blank" rel="noreferrer noopener"> <img src="../_static/images/deltares-blue.svg" alt="Deltares" style="height: 40px;"> </a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Deltares-research/FloodAdapt/blob/main/5_technical_docs/EventScenario.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/Deltares-research/FloodAdapt/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>