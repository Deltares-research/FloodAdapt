[
  {
    "objectID": "examples/events/synthetic_event.html",
    "href": "examples/events/synthetic_event.html",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a synthetic event using FloodAdapt. Synthetic events are valuable for controlled testing, sensitivity analysis, and understanding the behavior of flood models under simplified or hypothetical scenarios.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full synthetic event with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-1.-setup-and-imports",
    "href": "examples/events/synthetic_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing synthetic forcings and managing event data within the FloodAdapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import SyntheticEvent, TimeFrame\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nSTATIC_DATA_DIR = Path(\"../../_data/examples/static-data\").resolve()\nsettings = Settings(\n    DATABASE_ROOT=Path(\"../../_data/examples\").resolve(),\n    DATABASE_NAME=\"charleston_test\"\n)\nfa = FloodAdapt(database_path=settings.database_path)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-2.-define-the-simulation-time-frame",
    "href": "examples/events/synthetic_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the SyntheticEvent, from January 1 to January 2, 2025.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2025, month=1, day=1)\nend_time = datetime(year=2025, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-3.-define-water-level-forcing",
    "href": "examples/events/synthetic_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nSynthetic water levels are constructed from a combination of tidal and surge components. All FloodAdapt events require exactly 1 water level forcing, all other forcings are optional.\n\n# Synthetic water levels can be computed from a combination of surge and tide.\nsurge = f.SurgeModel(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulLength(value=2, units=us.UnitTypesLength.meters),\n    )\n)\n\ntide = f.TideModel(\n    harmonic_amplitude=us.UnitfulLength(value=1, units=us.UnitTypesLength.meters),\n    # Choose the middle of the time frame for peak time\n    harmonic_phase=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n    harmonic_period=us.UnitfulTime(value=12.4, units=us.UnitTypesTime.hours),\n)\n\nwater_levels_synthetic = f.WaterlevelSynthetic(\n    surge=surge,\n    tide=tide,\n)\n\n# Inspect\ngaussian = surge.timeseries.to_dataframe(time_frame=time_frame)\ngaussian.columns = [\"Surge\"]\nharmonic = tide.to_dataframe(time_frame=time_frame)\nharmonic.columns = [\"Tide\"]\ntotal = water_levels_synthetic.to_dataframe(time_frame=time_frame)\ntotal.columns = [\"Water levels\"]\ndf_combined = gaussian.join(harmonic).join(total)\ndf_combined.plot(\n    title=\"Synthetic Water Levels (Surge + Tide)\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=True,\n    figsize=(5, 2)\n)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "href": "examples/events/synthetic_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üß© Step 4. Create a minimal event and modify it",
    "text": "üß© Step 4. Create a minimal event and modify it\nGiven a water level forcing, and a TimeFrame, you can create the simplest possible event in FloodAdapt as shown below.\nIn many cases, it is interesting to to investigate a combination of different forcings. In steps 5 - 9, we will show the creation of various forcings and how to add them to an event.\n\nsimple_event = SyntheticEvent(\n    name=\"simple_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels_synthetic],\n    }\n)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-5.-define-rainfall-forcing",
    "href": "examples/events/synthetic_event.html#step-5.-define-rainfall-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üåßÔ∏è Step 5. Define Rainfall Forcing",
    "text": "üåßÔ∏è Step 5. Define Rainfall Forcing\nThe rainfall options for a synthetic event are:\n\nConstant: Constant rainfall intensity for the entire simultion period and spatially uniform across the model domain.\nSynthetic: Custom rainfall intensity timeseries built from key parameters applied spatially uniform across the entire model domain. The key parameters can be used to describe either a gaussian-, block- or triangle-shaped rainfall curve.\nCSV: Custom rainfall intensity from a csv file applied spatially uniform across the entire model domain.\n\n\nrainfall_constant = f.RainfallConstant(\n    intensity=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr)\n)\n\nrainfall_synthetic = f.RainfallSynthetic(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr),\n    )\n)\n\nrainfall_csv = f.RainfallCSV(path=STATIC_DATA_DIR / \"rainfall.csv\")\n\n# Inspect\ndf_constant = rainfall_constant.to_dataframe(time_frame=time_frame)\ndf_constant.columns = [\"Constant\"]\ndf_synthetic = rainfall_synthetic.to_dataframe(time_frame=time_frame)\ndf_synthetic.columns = [\"Synthetic\"]\ndf_csv = rainfall_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"CSV\"]\n\ndf_combined = df_constant.join(df_synthetic).join(df_csv)\ndf_combined.plot(\n    title=\"Synthetic Rainfall (Constant, Gaussian, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Rainfall Intensity (mm/hr)\",\n    legend=True,\n    figsize=(5, 2)\n)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-5.-define-wind-forcing",
    "href": "examples/events/synthetic_event.html#step-5.-define-wind-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üå¨Ô∏è Step 5. Define Wind Forcing",
    "text": "üå¨Ô∏è Step 5. Define Wind Forcing\nThe wind options for a synthetic event are:\n\nCSV: Custom wind speed and direction from a csv file applied spatially uniform across the entire model domain.\nConstant: Constant wind speed and direction is applied spatially uniform across the entire model domain.\n\n\nNote: Wind set up in embayments, lagoons etc is only included for the water bodies included in the overland model. Large scale wind effects creating surges and wind set up are typically included in the water level forcing. When the water level forcing is set to ‚ÄúModel‚Äù (see ‚ÄòHistorical Event‚Äô), this effect can be simulated by FloodAdapt in the offshore model.\n\n\nwind_constant = f.WindConstant(\n    speed=us.UnitfulVelocity(value=12, units=us.UnitTypesVelocity.mps), \n    direction=us.UnitfulDirection(value=2, units=us.UnitTypesDirection.degrees) \n    # 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West\n)\n\nwind_csv = f.WindCSV(path=STATIC_DATA_DIR / \"wind.csv\")\n\n# Inspect\ndf = wind_constant.to_dataframe(time_frame=time_frame)\ndf.columns = [\"speed\", \"direction\"]\ndf_csv = wind_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"speed\", \"direction\"]\ndf_combined = df.join(df_csv, lsuffix=\"_constant\", rsuffix=\"_csv\")\ndf_combined.plot(\n    title=\"Synthetic Wind (Constant, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Wind Speed (m/s)\",\n    legend=True,\n    figsize=(5, 2),\n)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-6.-define-river-discharge-forcing",
    "href": "examples/events/synthetic_event.html#step-6.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üèûÔ∏è Step 6. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 6. Define River Discharge Forcing\nDischarge is required to be defined for all pre-configured rivers. These rivers are registered in the hazard model configuration beforehand and it is important that the order of rivers and their source locations are consistent with the setup of the hazard model. The timeseries data provided will determine the in-flow of water at the river‚Äôs location.\nDischarge options for a SyntheticEvent are:\n\nConstant: Constant discharge for the entire simulation period.\nCSV: Custom discharge specified in a csv file.\nSynthetic: Custom discharge timeseries built from key parameters. The key parameters can be used to describe either a gaussian-, block- or triangle-shaped rainfall curve.\n\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event, you can only set the discharge of each given river.\nprint(f\"Number of available rivers: {len(fa.database.site.sfincs.river)}\")\n\nriver = fa.database.site.sfincs.river[0]\n\ndischarge_constant = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\ndischarge_synthetic = f.DischargeSynthetic(\n    river=river,\n    timeseries=f.BlockTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulDischarge(value=80, units=us.UnitTypesDischarge.cms),\n    )\n)\n\ndischarge_csv = f.DischargeCSV(\n    river=river,\n    path=STATIC_DATA_DIR / \"discharge.csv\"\n)\n\n# Inspect\ndf_constant = discharge_constant.to_dataframe(time_frame=time_frame)\ndf_constant.columns = [\"Constant\"]\ndf_synthetic = discharge_synthetic.to_dataframe(time_frame=time_frame)\ndf_synthetic.columns = [\"Synthetic\"]\ndf_csv = discharge_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"CSV\"]\ndf_combined = df_constant.join(df_synthetic).join(df_csv)\ndf_combined.plot(\n    title=\"Synthetic Discharge (Constant, Gaussian, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Discharge (cms)\",\n    legend=True,\n    figsize=(5, 2)\n)\n\nNumber of available rivers: 1",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-7.-combine-forcings-and-create-synthetic-event",
    "href": "examples/events/synthetic_event.html#step-7.-combine-forcings-and-create-synthetic-event",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üß© Step 7. Combine Forcings and Create Synthetic Event",
    "text": "üß© Step 7. Combine Forcings and Create Synthetic Event\nAll defined forcings are collected into a single dictionary, which is used to construct a SyntheticEvent. Now construct the forcings dictionary that contains the forcings you want to include.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a SyntheticEvent with the forcings and time frame\nfull_event = SyntheticEvent(\n    name=\"example_synthetic_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels_synthetic],\n        f.ForcingType.RAINFALL: [rainfall_constant],\n        f.ForcingType.WIND: [wind_csv],\n        f.ForcingType.DISCHARGE: [discharge_synthetic], \n        # The discharge list needs to be exactly as long as the number of rivers in the hazard model\n    },\n)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/synthetic_event.html#step-8.-save-the-event-to-a-floodadapt-database",
    "href": "examples/events/synthetic_event.html#step-8.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üíæ Step 8. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 8. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=full_event)",
    "crumbs": [
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html",
    "href": "examples/events/historical_event.html",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a historical event using FloodAdapt. Historical events are valuable for validation, controlled testing, sensitivity analysis, and what-if scenarios based on historic events.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full historical event with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-1.-setup-and-imports",
    "href": "examples/events/historical_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing forcings and managing event data within the flood_adapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import HistoricalEvent, TimeFrame\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nSTATIC_DATA_DIR = Path(\"../../_data/examples/static-data\").resolve()\nsettings = Settings(\n    DATABASE_ROOT=Path(\"../../_data/examples\").resolve(),\n    DATABASE_NAME=\"charleston_test\"\n)\nfa = FloodAdapt(database_path=settings.database_path)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-2.-define-the-simulation-time-frame",
    "href": "examples/events/historical_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the historical event, from January 1 to January 2, 2025.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2020, month=1, day=1)\nend_time = datetime(year=2020, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-3.-define-water-level-forcing",
    "href": "examples/events/historical_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nHistorical water levels can be included in 3 few ways:\n\nTide Gauge: Measured water levels downloaded from NOAA CO-OPS. The automated download is only available for stations in the US. Outside the US, water level records can be stored in the FloodAdapt database. This avoids having to import the csv for each event, see below.\n\nCSV: Custom water levels specified in a csv file (perhaps from a tide gauge not connected to the noaa_coops API)\nModel: Generate the storm surge to be used for the overland simulation by running an offshore model. For historic events, this model uses weather re-analysis data (wind and pressure) from the NOAA GFS model.\n\n\n# Recorded water levels from a CSV file\ncsv_file = STATIC_DATA_DIR / \"tide.csv\"\nwater_levels = f.WaterlevelCSV(path=csv_file)\nwl_df = water_levels.to_dataframe(time_frame=time_frame)\n\n# Alternative: Water levels downloaded from a tide gauge\ntide_gauge = fa.database.site.sfincs.tide_gauge\ndf_tide_gauge = tide_gauge.get_waterlevels_in_time_frame(\n    time=time_frame,\n)\nwater_levels_gauged = f.WaterlevelGauged()\n\n# Alternative: Water levels simulated by an offshore model\nwater_levels_from_offshore = f.WaterlevelModel()\n\n# Inspect\nwl_df.plot(\n    title=\"Water Level from CSV\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=False,\n    figsize=(5, 2)\n)\n\ndf_tide_gauge.plot(\n    title=\"Water Level from Tide Gauge\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=False,\n    figsize=(5, 2)\n)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "href": "examples/events/historical_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üß© Step 4. Create a minimal event and modify it",
    "text": "üß© Step 4. Create a minimal event and modify it\nGiven a water level forcing, and a TimeFrame, you can create the simplest possible event in FloodAdapt as shown below.\nIn many cases, it is interesting to to investigate a combination of different forcings. In steps 5 - 9, we will show the creation of various forcings and how to add them to an event.\n\nsimple_event = HistoricalEvent(\n    name=\"simple_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels], \n        # or [water_levels_gauged], [water_levels_from_offshore]\n    }\n)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-5.-define-meteo-forcing",
    "href": "examples/events/historical_event.html#step-5.-define-meteo-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üåßÔ∏è Step 5. Define Meteo Forcing",
    "text": "üåßÔ∏è Step 5. Define Meteo Forcing\nHistoric events have several options to define wind and rainfall, see also Synthteic event. Additionally, FloodAdapt provides an easy connection to NOAA GFS model re-analysis data for rainfall and wind that is automatically downloaded based on the event‚Äôs ‚ÄòTimeFrame‚Äô.\n\nmeteo_dataset = f.MeteoHandler().read(time_frame)\nprint(meteo_dataset) # TODO make sure the meteo files are already downloaded in the database to circumvent flaky noaa coops API calls\n\nRequested meteo data already available\n&lt;xarray.Dataset&gt; Size: 485kB\nDimensions:      (time: 9, lon: 41, lat: 41)\nCoordinates:\n  * time         (time) datetime64[ns] 72B 2020-01-01 ... 2020-01-02\n  * lon          (lon) float32 164B -90.0 -89.5 -89.0 ... -71.0 -70.5 -70.0\n  * lat          (lat) float32 164B 23.0 23.5 24.0 24.5 ... 41.5 42.0 42.5 43.0\n    spatial_ref  int32 4B 0\nData variables:\n    wind10_u     (time, lat, lon) float64 121kB -5.165 -5.625 ... 11.64 11.98\n    wind10_v     (time, lat, lon) float64 121kB -5.967 -5.257 ... -0.8354 -1.565\n    press_msl    (time, lat, lon) float64 121kB 1.017e+05 ... 1.004e+05\n    precip       (time, lat, lon) float64 121kB 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0\n\n\n\nVisualizing Meteo data\nIt can be difficult to visualize spatially varying timeseries data. So, below is a simple animation generator to do some basic data checks on the downloaded NOAA GFS data.\nChoose any of the available timeseries data variables and generate the animation.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\nto_plot = 'press_msl' # available variables: 'wind10_u' or 'wind10_v' or 'press_msl' or 'precip'\n\nvar = meteo_dataset[to_plot] \nfig, ax = plt.subplots()\nplot = var.isel(time=0).plot(ax=ax, cmap='viridis', add_colorbar=True)\n\ndef update(frame):\n    ax.clear()\n    var.isel(time=frame).plot(ax=ax, cmap='viridis', add_colorbar=False)\n    ax.set_title(f'Time: {str(var.time[frame].values)}')\n\nani = animation.FuncAnimation(fig, update, frames=len(var.time), interval=200)\nplt.close(fig)\n\nHTML(ani.to_jshtml()) # TODO look at hvplot or other options to display the animation\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-6.-define-meteo-forcings",
    "href": "examples/events/historical_event.html#step-6.-define-meteo-forcings",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üå¨Ô∏è Step 6. Define Meteo Forcings",
    "text": "üå¨Ô∏è Step 6. Define Meteo Forcings\nTo use the downloaded NOAA‚Äôs GFS hindcast data in FloodAdapt, you need to create Meteo forcings and add them to your event.\nUnder the hood, the meteo forcings use the MeteoHandler to download the data, and then return slices of that dataset.\n\nrainfall = f.RainfallMeteo()\nwind = f.WindMeteo()",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-7.-define-river-discharge-forcing",
    "href": "examples/events/historical_event.html#step-7.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üèûÔ∏è Step 7. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 7. Define River Discharge Forcing\nDischarge is required to be defined for the pre-configured river(s). These rivers must be registered in the hazard model configuration beforehand.\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event\n# You can only set the discharge of each given river.\nprint(f\"Number of available rivers: {len(fa.database.site.sfincs.river)}\")\n\nriver = fa.database.site.sfincs.river[0]\n\ndischarge_constant = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\n# Inspect\ndf = discharge_constant.to_dataframe(time_frame=time_frame)\ndf.plot(\n    title=\"Constant Discharge River\",\n    xlabel=\"Time\",\n    ylabel=\"Discharge (cms)\",\n    legend=True,\n    figsize=(5, 2)\n)\n\nNumber of available rivers: 1",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-8.-combine-forcings-and-create-event",
    "href": "examples/events/historical_event.html#step-8.-combine-forcings-and-create-event",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üß© Step 8. Combine Forcings and Create Event",
    "text": "üß© Step 8. Combine Forcings and Create Event\nAll defined forcings are collected into a single dictionary, which is used to construct a HistoricalEvent.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a HistoricalEvent with the forcings and time frame\nevent = HistoricalEvent(\n    name=\"example_historical_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels], \n        # or one of `water_levels_gauged` or `water_levels_from_offshore`,\n        f.ForcingType.RAINFALL: [rainfall],\n        f.ForcingType.WIND: [wind],\n        f.ForcingType.DISCHARGE: [discharge_constant],\n    },\n)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/events/historical_event.html#step-9.-save-the-event-to-a-floodadapt-database",
    "href": "examples/events/historical_event.html#step-9.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üíæ Step 9. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 9. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=event)",
    "crumbs": [
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "examples/event_set/create_event_set.html",
    "href": "examples/event_set/create_event_set.html",
    "title": "Event set creation for Risk Analysis",
    "section": "",
    "text": "This notebook explains how to create the input files for a risk analysis in the correct format and place them in the correct folder structure. For an explanation on how to derive the (compound) events and their (joint) probabilities, the reader is referred to the FloodAdapt Setup Guide Event Set.",
    "crumbs": [
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "examples/event_set/create_event_set.html#step-1.-setup-and-imports",
    "href": "examples/event_set/create_event_set.html#step-1.-setup-and-imports",
    "title": "Event set creation for Risk Analysis",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\n\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom flood_adapt import Settings, FloodAdapt\nfrom flood_adapt import unit_system as us\nfrom flood_adapt.config.sfincs import RiverModel\nfrom flood_adapt.objects import (\n    EventSet,\n    SubEventModel,\n    SyntheticEvent,\n)\nfrom flood_adapt.objects.forcing import (\n    DischargeConstant,\n    ForcingType,\n    TimeFrame,\n    ShapeType,\n    TimeseriesFactory,\n    RainfallSynthetic,\n    SurgeModel,\n    TideModel,\n    WaterlevelSynthetic,\n    WindConstant,\n)\n\n# Configure FloodAdapt\nsettings = Settings(\n    DATABASE_ROOT=Path(\"../../_data/examples\").resolve(),\n    DATABASE_NAME=\"charleston_test\"\n)\n\nfa = FloodAdapt(database_path=settings.database_path)",
    "crumbs": [
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "examples/event_set/create_event_set.html#step-2.-set-name-frequencies-and-parameters-to-build-subevents",
    "href": "examples/event_set/create_event_set.html#step-2.-set-name-frequencies-and-parameters-to-build-subevents",
    "title": "Event set creation for Risk Analysis",
    "section": "üóìÔ∏è Step 2. Set name, frequencies and parameters to build subevents",
    "text": "üóìÔ∏è Step 2. Set name, frequencies and parameters to build subevents\nSet the name of the event set and the parameters for the input events and their frequencies. In this example, we are using three synthetic events with different storm surge heights and peak rainfall intensities. Alternatively, historic gauged and ungauged events or hurricanes are possible as well, see Events for examples on how to set up different subevents.\n\nname = \"event_set\"\n\n# Peak surge values in the subevents. \n# Surge is timed to always peak at 24.8 hours after the event start, coinciding with high tide at a tidal phase of 0 and lasting for 10 hours.\nsurge_values = [2.5, 1, 3] # in meters\n\n# Peak rainfall intensities in the three subevents. \n# Rainfall is applied as a 6 hour \"block\" shape preceding the peak of the storm surge.\nrainfall_values = [10, 15, 5] # in mm/hr\n\n# Occurrence frequencies of the three events\nfreq = [0.1, 2, 0.05]",
    "crumbs": [
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "examples/event_set/create_event_set.html#step-3.-create-subevents",
    "href": "examples/event_set/create_event_set.html#step-3.-create-subevents",
    "title": "Event set creation for Risk Analysis",
    "section": "üß© Step 3. Create subevents",
    "text": "üß© Step 3. Create subevents\nCreate the subevents from the parameters defined in Step 1.\n\nevents = []\nnumber = 0\nfor surge, rainfall in zip(surge_values, rainfall_values):\n    number += 1\n    events.append(\n        SyntheticEvent(\n            name = f\"subevent_{number}\",\n            time=TimeFrame(start_time=datetime(2020, 1, 1, 0, 0, 0),end_time=datetime(2020, 1, 3, 0, 0, 0)),\n            forcings={\n                # constant wind speed 10 m/, direction 90 degrees (from the East)\n                ForcingType.WIND: [         \n                    WindConstant(\n                        speed=us.UnitfulVelocity(value=10, units=us.UnitTypesVelocity.mps), \n                        direction=us.UnitfulDirection(\n                            value=90, units=us.UnitTypesDirection.degrees                  \n                        ),\n                    )\n                ],\n                # block rainfall starting 18h after event start, duration 6h, intensity 10 mm/hr \n                ForcingType.RAINFALL: [         \n                    RainfallSynthetic(\n                        timeseries = TimeseriesFactory.from_args(             \n                            shape_type=ShapeType.block,\n                            duration=us.UnitfulTime(\n                                value=6, units=us.UnitTypesTime.hours\n                            ),\n                            peak_time=us.UnitfulTime(\n                                value=21, units=us.UnitTypesTime.hours\n                            ),\n                            peak_value=us.UnitfulIntensity(\n                                value=rainfall, units=us.UnitTypesIntensity.mm_hr\n                            ),\n                        )\n                    )\n                ],\n                # constant discharge in Cooper River of 5000 cubic feet per second\n                ForcingType.DISCHARGE: [         \n                    DischargeConstant(\n                        river=RiverModel(\n                            name=\"cooper\",\n                            description=\"Cooper River\",\n                            x_coordinate=595546.3,\n                            y_coordinate=3675590.6,\n                            mean_discharge=us.UnitfulDischarge(\n                                value=5000, units=us.UnitTypesDischarge.cfs\n                            ),\n                        ),\n                        discharge=us.UnitfulDischarge(\n                            value=5000, units=us.UnitTypesDischarge.cfs \n                        ),\n                    )\n                ],\n                ForcingType.WATERLEVEL: [       \n                    WaterlevelSynthetic(\n                        # storm surge with gaussian shape, duration 10 hours, peak at 24h after event start_time, peak height 3m\n                        surge=SurgeModel(       \n                            timeseries=TimeseriesFactory.from_args(             \n                                shape_type=ShapeType.gaussian,\n                                duration=us.UnitfulTime(\n                                    value=10, units=us.UnitTypesTime.hours\n                                ),\n                                peak_time=us.UnitfulTime(\n                                    value=24, units=us.UnitTypesTime.hours\n                                ),\n                                peak_value=us.UnitfulLength(\n                                    value=surge, units=us.UnitTypesLength.meters\n                                ),\n                            )\n                        ),\n                        # tide with 1m amplitude and 12.4h duration\n                        tide=TideModel(     \n                            harmonic_amplitude=us.UnitfulLength(\n                                value=1, units=us.UnitTypesLength.meters\n                            ),\n                            harmonic_period=us.UnitfulTime(\n                                value=12.4, units=us.UnitTypesTime.hours\n                            ),\n                            harmonic_phase=us.UnitfulTime(\n                                value=0, units=us.UnitTypesTime.hours\n                            ),\n                        ),\n                    )\n                ],\n            },\n        )\n    )\n\nprint(events)\n\n[SyntheticEvent(name='subevent_1', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.0, units=UnitTypesVelocity.mps), direction=UnitfulDirection(value=90.0, units=UnitTypesDirection.degrees))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=21.0, units=UnitTypesTime.hours), peak_value=UnitfulIntensity(value=10.0, units=UnitTypesIntensity.mm_hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=24.0, units=UnitTypesTime.hours), peak_value=UnitfulLength(value=2.5, units=UnitTypesLength.meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.0, units=UnitTypesLength.meters), harmonic_phase=UnitfulTime(value=0.0, units=UnitTypesTime.hours), harmonic_period=UnitfulTime(value=12.4, units=UnitTypesTime.hours)))]}, rainfall_multiplier=1.0), SyntheticEvent(name='subevent_2', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.0, units=UnitTypesVelocity.mps), direction=UnitfulDirection(value=90.0, units=UnitTypesDirection.degrees))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=21.0, units=UnitTypesTime.hours), peak_value=UnitfulIntensity(value=15.0, units=UnitTypesIntensity.mm_hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=24.0, units=UnitTypesTime.hours), peak_value=UnitfulLength(value=1.0, units=UnitTypesLength.meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.0, units=UnitTypesLength.meters), harmonic_phase=UnitfulTime(value=0.0, units=UnitTypesTime.hours), harmonic_period=UnitfulTime(value=12.4, units=UnitTypesTime.hours)))]}, rainfall_multiplier=1.0), SyntheticEvent(name='subevent_3', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.0, units=UnitTypesVelocity.mps), direction=UnitfulDirection(value=90.0, units=UnitTypesDirection.degrees))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=21.0, units=UnitTypesTime.hours), peak_value=UnitfulIntensity(value=5.0, units=UnitTypesIntensity.mm_hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.0, units=UnitTypesDischarge.cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.0, units=UnitTypesTime.hours), peak_time=UnitfulTime(value=24.0, units=UnitTypesTime.hours), peak_value=UnitfulLength(value=3.0, units=UnitTypesLength.meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.0, units=UnitTypesLength.meters), harmonic_phase=UnitfulTime(value=0.0, units=UnitTypesTime.hours), harmonic_period=UnitfulTime(value=12.4, units=UnitTypesTime.hours)))]}, rainfall_multiplier=1.0)]",
    "crumbs": [
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "examples/event_set/create_event_set.html#step-4.-create-and-save-event-set",
    "href": "examples/event_set/create_event_set.html#step-4.-create-and-save-event-set",
    "title": "Event set creation for Risk Analysis",
    "section": "üíæ Step 4. Create and save event set",
    "text": "üíæ Step 4. Create and save event set\nIn this step, we create an event set from the SubEvents created in Step 2, load the actual Event objects into it, and save it to the database. This event set can then be used like any other event in a Scenario. Click here to see examples on how to build a scenario.\n\nsub_events = []\nfor event, frequency in zip(events, freq):\n    sub_events.append(SubEventModel(name=event.name, frequency=frequency))\n\n\nevent_set = EventSet(\n    name=name,\n    sub_events=sub_events,\n)\nevent_set.load_sub_events(events)\n\nfa.save_event(event_set)\nprint(fa.get_events()[\"name\"])\n\n['event_set', 'test_set']",
    "crumbs": [
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "formatting_tips.html",
    "href": "formatting_tips.html",
    "title": "Flood Adapt Documentation",
    "section": "",
    "text": "I put some styling infos here: but you can check all formatting here:\nhttps://quarto.org/docs/authoring/markdown-basics.html"
  },
  {
    "objectID": "formatting_tips.html#generate-tables",
    "href": "formatting_tips.html#generate-tables",
    "title": "Flood Adapt Documentation",
    "section": "Generate tables",
    "text": "Generate tables\nhttps://tablesgenerator.com/markdown_tables"
  },
  {
    "objectID": "formatting_tips.html#headings",
    "href": "formatting_tips.html#headings",
    "title": "Flood Adapt Documentation",
    "section": "Headings",
    "text": "Headings\nfirst level : # Heading second level : ## Heading third level : ### Heading\n‚Ä¶"
  },
  {
    "objectID": "formatting_tips.html#fonts",
    "href": "formatting_tips.html#fonts",
    "title": "Flood Adapt Documentation",
    "section": "Fonts",
    "text": "Fonts\nbold: ** word ** (remove tab spaces betweenw asterisk and word)\nitalic: * this will be italic when tab space removed *\n&lt;Make font a different color?&gt;"
  },
  {
    "objectID": "formatting_tips.html#paragraphs",
    "href": "formatting_tips.html#paragraphs",
    "title": "Flood Adapt Documentation",
    "section": "Paragraphs",
    "text": "Paragraphs\nIf you want to create a paragraph or continue in the next line add 2 tab spaces behind the last word.\nE.g I write and want to continue in the next line.\nIf I only press enter to continue in the next line as I did now this will not show. -&gt; I have to add 2 spaces after line.\nLet‚Äôs see what happens when I add the 2 tabs:\nI to continue in the next line. If I only press enter to continue in the next line as I did now this will not show."
  },
  {
    "objectID": "formatting_tips.html#additional-options",
    "href": "formatting_tips.html#additional-options",
    "title": "Flood Adapt Documentation",
    "section": "Additional options",
    "text": "Additional options\n\nEmphasizing\nCreate different types to emphasize the text eg code\nExample 1: conda install jupyter : Use ` (grave accent) before and after your sentence (without any spacing)\nExample 2: something: just indent one time. for scrolling do the same just write a longer text (see below)\nsomething really long that will needs scrolling so I will just continue writing until the scrolling bar appears.\n\n\nBullet Points\nJust write numbers below one another and use Indentation for the levels.\n\nMerry\nChristmas\nKathryn\n\nand a new year too\n\n\nUse the asterisks for your first level. For the second level in the row below add an indentation and a + per entry.\n\nMerry (* Merry)\n\nChristmas (+ Christmas)\nKathryn (+ Kathryn)"
  },
  {
    "objectID": "formatting_tips.html#urls",
    "href": "formatting_tips.html#urls",
    "title": "Flood Adapt Documentation",
    "section": "URLs",
    "text": "URLs\nadd a URL and give it a name a\n[here comes the name] (here comes the URL)\nFloodAdapt Deltares webpage"
  },
  {
    "objectID": "formatting_tips.html#embedded-videos",
    "href": "formatting_tips.html#embedded-videos",
    "title": "Flood Adapt Documentation",
    "section": "Embedded videos",
    "text": "Embedded videos"
  },
  {
    "objectID": "formatting_tips.html#figures",
    "href": "formatting_tips.html#figures",
    "title": "Flood Adapt Documentation",
    "section": "Figures",
    "text": "Figures\nadd a figure and give it a name add #fig..to cross-reference. Just included here for demonstration purposes):\nFirst an exclamation mark - [here comes the name] (here comes the path to the file){#fig-logo}\nadd ‚Äúfig-‚Äù before the label name to be able to cross reference.\n\n\n\n\n\n\nFigure¬†1: Floodadapt\n\n\n\n\nCross reference figure\nI want to reference the Figure¬†1."
  },
  {
    "objectID": "formatting_tips.html#note-warning-blocks",
    "href": "formatting_tips.html#note-warning-blocks",
    "title": "Flood Adapt Documentation",
    "section": "Note/ Warning Blocks",
    "text": "Note/ Warning Blocks\nCreate info blocks within your test.\nJust use this header (remove quotation mark): ‚Äú::: {.callout-tip}‚Äù write here the Note. and end with the following footer. ‚Äú:::‚Äù\nExample: ::: {.callout-tip} create a tip :::\n\n\n\n\n\n\nWarning\n\n\n\nCreate a warning .\n\n\n\noptions\n\nnote\nwarning\nimportant\ntip\ncaution"
  },
  {
    "objectID": "formatting_tips.html#cross-reference",
    "href": "formatting_tips.html#cross-reference",
    "title": "Flood Adapt Documentation",
    "section": "Cross Reference",
    "text": "Cross Reference\nCross reference to another page or figure: (remove quotation marks)\n‚Äú[Write here the text would want to see]‚Äù(‚Äúadd the reference‚Äù)\n\nCross reference page\n‚Äú[Setup Guide]‚Äù(/3_setup_guide/index.qmd)‚Äù Here I use the reference to the Setup Guide\n\n\nCross reference Figure\nuse the @ before the logo Reference and use the name you gave it as reference above: @ fig-logo (remove space)\nExample: Figure¬†1"
  },
  {
    "objectID": "examples/scenarios/index.html",
    "href": "examples/scenarios/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Scenarios"
    ]
  },
  {
    "objectID": "examples/measures/index.html",
    "href": "examples/measures/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "examples/events/index.html",
    "href": "examples/events/index.html",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt provides a structured system for defining and managing hazard events that can be used for simulation, testing, and analysis. Events are central to the framework, consisting of the time frame of interest as well as all relevant hydrometeorological forcings such as:\n\nWater levels\nRainfall\nWind\nRiver discharge\n\nThese forcings can be derived from measurements or generated synthetically to support hypothetical or controlled scenarios. All event data is stored in a database, ensuring reproducibility and consistency across simulation workflows.\n\n\nAn event in FloodAdapt consists of 1. a TimeFrame, and 2. a (collection of) forcing(s) depending on the event type.\nA TimeFrame is a combination of the event start and end time.\nForcings in FloodAdapt are modular and extensible, allowing fine control over how each physical process is represented. For example, synthetic surge and tide can be combined into a single synthetic water level signal using a Gaussian curve for surge and a cosine function for tide. You can start building your own events by exploring the API reference or following the structure shown in the example. The modular design makes it easy to plug in your own forcing data, synthetic models, or customized logic. You can find a list of all available forcing classes here !TODO!\n\n\n\nFloodAdapt supports three types of events:\nTo see a full example of how to define an event, refer to the following notebooks:\nSynthetic Event: Synthetic timeseries built from key parameters.\nHistorical Event: Built from real-world observations or meteorological hindcast data.\nHurricane Event: Run an offshore hazard model using wind and pressure fields from cyclone tracks to generate the waterlevels for the overland hazard model. Only available when the database has an offshore model.\nEvent modification: Modify existing events or build new events from existing ones.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "examples/events/index.html#components-of-an-event",
    "href": "examples/events/index.html#components-of-an-event",
    "title": "Events",
    "section": "",
    "text": "An event in FloodAdapt consists of 1. a TimeFrame, and 2. a (collection of) forcing(s) depending on the event type.\nA TimeFrame is a combination of the event start and end time.\nForcings in FloodAdapt are modular and extensible, allowing fine control over how each physical process is represented. For example, synthetic surge and tide can be combined into a single synthetic water level signal using a Gaussian curve for surge and a cosine function for tide. You can start building your own events by exploring the API reference or following the structure shown in the example. The modular design makes it easy to plug in your own forcing data, synthetic models, or customized logic. You can find a list of all available forcing classes here !TODO!",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "examples/events/index.html#event-types",
    "href": "examples/events/index.html#event-types",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt supports three types of events:\nTo see a full example of how to define an event, refer to the following notebooks:\nSynthetic Event: Synthetic timeseries built from key parameters.\nHistorical Event: Built from real-world observations or meteorological hindcast data.\nHurricane Event: Run an offshore hazard model using wind and pressure fields from cyclone tracks to generate the waterlevels for the overland hazard model. Only available when the database has an offshore model.\nEvent modification: Modify existing events or build new events from existing ones.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "examples/benefits/index.html",
    "href": "examples/benefits/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "api_ref/objects/Template.html",
    "href": "api_ref/objects/Template.html",
    "title": "Template",
    "section": "",
    "text": "objects.Template()\nClass describing the accepted input for the variable template in Event.\n\n\n\nSynthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Template"
    ]
  },
  {
    "objectID": "api_ref/objects/Template.html#attributes",
    "href": "api_ref/objects/Template.html#attributes",
    "title": "Template",
    "section": "",
    "text": "Synthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Template"
    ]
  },
  {
    "objectID": "api_ref/objects/SubEventModel.html",
    "href": "api_ref/objects/SubEventModel.html",
    "title": "SubEventModel",
    "section": "",
    "text": "objects.SubEventModel()\nThe accepted input for a sub event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SubEventModel"
    ]
  },
  {
    "objectID": "api_ref/objects/SubEventModel.html#attributes",
    "href": "api_ref/objects/SubEventModel.html#attributes",
    "title": "SubEventModel",
    "section": "",
    "text": "name : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SubEventModel"
    ]
  },
  {
    "objectID": "api_ref/objects/SocioEconomicChange.html",
    "href": "api_ref/objects/SocioEconomicChange.html",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "objects.SocioEconomicChange()\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\npopulation_growth_existing : float\n\nThe existing population growth rate. default=0.0\n\neconomic_growth : float\n\nThe economic growth rate. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth rate for new developments. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of new developments. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of new developments. default=None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "SocioEconomicChange"
    ]
  },
  {
    "objectID": "api_ref/objects/SocioEconomicChange.html#attributes",
    "href": "api_ref/objects/SocioEconomicChange.html#attributes",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "population_growth_existing : float\n\nThe existing population growth rate. default=0.0\n\neconomic_growth : float\n\nThe economic growth rate. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth rate for new developments. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of new developments. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of new developments. default=None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "SocioEconomicChange"
    ]
  },
  {
    "objectID": "api_ref/objects/Scenario.html",
    "href": "api_ref/objects/Scenario.html",
    "title": "Scenario",
    "section": "",
    "text": "objects.Scenario()\nBaseModel describing the expected variables and data types of a scenario.\nA scenario is a combination of an event, a projection, and a strategy, that all should be saved in the database.\n\n\n\nevent : str\n\nThe name of the event.\n\nprojection : str\n\nThe name of the projection.\n\nstrategy : str\n\nThe name of the strategy.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Scenarios",
      "Scenario"
    ]
  },
  {
    "objectID": "api_ref/objects/Scenario.html#attributes",
    "href": "api_ref/objects/Scenario.html#attributes",
    "title": "Scenario",
    "section": "",
    "text": "event : str\n\nThe name of the event.\n\nprojection : str\n\nThe name of the projection.\n\nstrategy : str\n\nThe name of the strategy.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Scenarios",
      "Scenario"
    ]
  },
  {
    "objectID": "api_ref/objects/Projection.html",
    "href": "api_ref/objects/Projection.html",
    "title": "Projection",
    "section": "",
    "text": "objects.Projection()\nThe accepted input for a projection in FloodAdapt.\nA projection is a combination of a physical projection and a socio-economic change.\n\n\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "Projection"
    ]
  },
  {
    "objectID": "api_ref/objects/Projection.html#attributes",
    "href": "api_ref/objects/Projection.html#attributes",
    "title": "Projection",
    "section": "",
    "text": "physical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "Projection"
    ]
  },
  {
    "objectID": "api_ref/objects/Mode.html",
    "href": "api_ref/objects/Mode.html",
    "title": "Mode",
    "section": "",
    "text": "objects.Mode()\nClass describing the accepted input for the variable mode in Event.\n\n\n\nsingle_event : The single event mode.\n\n\n\nrisk : The risk mode.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Mode"
    ]
  },
  {
    "objectID": "api_ref/objects/Mode.html#attributes",
    "href": "api_ref/objects/Mode.html#attributes",
    "title": "Mode",
    "section": "",
    "text": "single_event : The single event mode.\n\n\n\nrisk : The risk mode.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Mode"
    ]
  },
  {
    "objectID": "api_ref/objects/Measure.html",
    "href": "api_ref/objects/Measure.html",
    "title": "Measure",
    "section": "",
    "text": "objects.Measure()\nThe expected variables and data types of attributes common to all measures.\nA measure is a collection of attributes that can be applied to a model.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Measure"
    ]
  },
  {
    "objectID": "api_ref/objects/Measure.html#attributes",
    "href": "api_ref/objects/Measure.html#attributes",
    "title": "Measure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Measure"
    ]
  },
  {
    "objectID": "api_ref/objects/HurricaneEvent.html",
    "href": "api_ref/objects/HurricaneEvent.html",
    "title": "HurricaneEvent",
    "section": "",
    "text": "objects.HurricaneEvent()\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HurricaneEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/HurricaneEvent.html#attributes",
    "href": "api_ref/objects/HurricaneEvent.html#attributes",
    "title": "HurricaneEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HurricaneEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/GreenInfrastructure.html",
    "href": "api_ref/objects/GreenInfrastructure.html",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "objects.GreenInfrastructure()\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "api_ref/objects/GreenInfrastructure.html#attributes",
    "href": "api_ref/objects/GreenInfrastructure.html#attributes",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "api_ref/objects/GreenInfrastructure.html#methods",
    "href": "api_ref/objects/GreenInfrastructure.html#methods",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "api_ref/objects/FloodWall.html",
    "href": "api_ref/objects/FloodWall.html",
    "title": "FloodWall",
    "section": "",
    "text": "objects.FloodWall()\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodWall"
    ]
  },
  {
    "objectID": "api_ref/objects/FloodWall.html#attributes",
    "href": "api_ref/objects/FloodWall.html#attributes",
    "title": "FloodWall",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodWall"
    ]
  },
  {
    "objectID": "api_ref/objects/EventSet.html",
    "href": "api_ref/objects/EventSet.html",
    "title": "EventSet",
    "section": "",
    "text": "objects.EventSet()\nBaseModel describing the expected variables and data types for parameters of EventSet.\nAn EventSet is a collection of events that can be used to create a scenario and perform a probabilistoc risk assessment.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "api_ref/objects/EventSet.html#attributes",
    "href": "api_ref/objects/EventSet.html#attributes",
    "title": "EventSet",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "api_ref/objects/EventSet.html#methods",
    "href": "api_ref/objects/EventSet.html#methods",
    "title": "EventSet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "api_ref/objects/Elevate.html",
    "href": "api_ref/objects/Elevate.html",
    "title": "Elevate",
    "section": "",
    "text": "objects.Elevate()\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Elevate"
    ]
  },
  {
    "objectID": "api_ref/objects/Elevate.html#attributes",
    "href": "api_ref/objects/Elevate.html#attributes",
    "title": "Elevate",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Elevate"
    ]
  },
  {
    "objectID": "api_ref/objects/Buyout.html",
    "href": "api_ref/objects/Buyout.html",
    "title": "Buyout",
    "section": "",
    "text": "objects.Buyout()\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Buyout"
    ]
  },
  {
    "objectID": "api_ref/objects/Buyout.html#attributes",
    "href": "api_ref/objects/Buyout.html#attributes",
    "title": "Buyout",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Buyout"
    ]
  },
  {
    "objectID": "api_ref/api_index.html",
    "href": "api_ref/api_index.html",
    "title": "Flood Adapt v0.3.8",
    "section": "",
    "text": "Class that contains the main functionality of FloodAdapt.\n\n\n\nFloodAdapt\n\n\n\n\n\n\n\nConfiguration settings for FloodAdapt.\n\n\n\nSettings\nThe configuration settings for the FloodAdapt database and integrator.\n\n\nSite\nThe expected variables and data types of attributes of the Site class.\n\n\n\n\n\n\nObject models in FloodAdapt are the components that are saved in the database. They define the configuration, input and output of the model kernels. The database stores Objects, and returns Objects when queried.\n\n\n\nObject\nBase class for FloodAdapt objects.\n\n\n\n\n\nVarious flood protection and mitigation measures available that can interact with the models. Can be impact measures or a hazard measures, where impact measures do not affect the hazard model at all, and hazard measures do.\n\n\n\nMeasure\nThe expected variables and data types of attributes common to all measures.\n\n\nMeasureType\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\n\n\nSelectionType\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\n\n\nFloodWall\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\nGreenInfrastructure\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\nPump\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\nBuyout\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\nElevate\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\nFloodProof\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\n\n\n\nA collection of measures that can be used to define a strategy for flood risk management.\n\n\n\nStrategy\nClass representing a strategy in FloodAdapt.\n\n\n\n\n\n\nEvent types including historical, synthetic, and hurricane events.\n\n\n\nEvent\nThe accepted input for an event in FloodAdapt.\n\n\nSyntheticEvent\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\nHistoricalEvent\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\nHurricaneEvent\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\nEventSet\nBaseModel describing the expected variables and data types for parameters of EventSet.\n\n\nTimeFrame\nClass representing a time frame for a simulation.\n\n\nIForcing\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\nForcingType\nEnum class for the different types of forcing parameters.\n\n\nTemplate\nClass describing the accepted input for the variable template in Event.\n\n\nMode\nClass describing the accepted input for the variable mode in Event.\n\n\nSubEventModel\nThe accepted input for a sub event in FloodAdapt.\n\n\n\n\n\n\nClimate and socio-economic projections for future scenario analysis.\n\n\n\nProjection\nThe accepted input for a projection in FloodAdapt.\n\n\nPhysicalProjection\nThe accepted input for a physical projection in FloodAdapt.\n\n\nSocioEconomicChange\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\n\n\n\nScenario modeling for assessing different flood risk management approaches. Scenarios consist of a combination of event, projection, and strategy.\n\n\n\nScenario\nBaseModel describing the expected variables and data types of a scenario.\n\n\n\n\n\n\nBenefit calculation for different flood risk management strategies. Benefits can be used to perform cost benefit analysis on a strategy, which is calculated based on the impact of the event on the population and infrastructure.\n\n\n\nBenefit\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\nCurrentSituationModel\nThe accepted input for a current situation in FloodAdapt.\n\n\n\n\n\n\n\nUnit system for FloodAdapt. The unit system is used to convert between different units of measurement, and to define the units of the input and output of the models.\n\n\n\nValueUnitPair\nRepresents a value with associated units.\n\n\nUnitfulLength\nCombination of length and unit.\n\n\nUnitfulHeight\nCombination of height and unit.\n\n\nUnitfulArea\nCombination of area and unit.\n\n\nUnitfulVelocity\nCombination of velocity and unit.\n\n\nUnitfulDirection\nCombination of direction and unit.\n\n\nUnitfulDischarge\nCombination of discharge and unit.\n\n\nUnitfulIntensity\nCombination of intensity and unit.\n\n\nUnitfulVolume\nCombination of volume and unit.\n\n\nUnitfulTime\nCombination of time and unit.\n\n\nUnitfulLengthRefValue\nCombination of length and unit with a reference value.\n\n\nUnitTypesLength\nUnits of length.\n\n\nUnitTypesArea\nUnits of area.\n\n\nUnitTypesVolume\nUnits of volume.\n\n\nUnitTypesVelocity\nUnits of velocity.\n\n\nUnitTypesDirection\nUnits of direction.\n\n\nUnitTypesTime\nUnits of time.\n\n\nUnitTypesDischarge\nUnits of discharge.\n\n\nUnitTypesIntensity\nUnits of intensity.\n\n\nVerticalReference\nVertical reference for height.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "api_ref/api_index.html#floodadapt",
    "href": "api_ref/api_index.html#floodadapt",
    "title": "Flood Adapt v0.3.8",
    "section": "",
    "text": "Class that contains the main functionality of FloodAdapt.\n\n\n\nFloodAdapt",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "api_ref/api_index.html#setup-and-configuration",
    "href": "api_ref/api_index.html#setup-and-configuration",
    "title": "Flood Adapt v0.3.8",
    "section": "",
    "text": "Configuration settings for FloodAdapt.\n\n\n\nSettings\nThe configuration settings for the FloodAdapt database and integrator.\n\n\nSite\nThe expected variables and data types of attributes of the Site class.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "api_ref/api_index.html#object-models",
    "href": "api_ref/api_index.html#object-models",
    "title": "Flood Adapt v0.3.8",
    "section": "",
    "text": "Object models in FloodAdapt are the components that are saved in the database. They define the configuration, input and output of the model kernels. The database stores Objects, and returns Objects when queried.\n\n\n\nObject\nBase class for FloodAdapt objects.\n\n\n\n\n\nVarious flood protection and mitigation measures available that can interact with the models. Can be impact measures or a hazard measures, where impact measures do not affect the hazard model at all, and hazard measures do.\n\n\n\nMeasure\nThe expected variables and data types of attributes common to all measures.\n\n\nMeasureType\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\n\n\nSelectionType\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\n\n\nFloodWall\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\nGreenInfrastructure\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\nPump\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\nBuyout\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\nElevate\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\nFloodProof\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\n\n\n\nA collection of measures that can be used to define a strategy for flood risk management.\n\n\n\nStrategy\nClass representing a strategy in FloodAdapt.\n\n\n\n\n\n\nEvent types including historical, synthetic, and hurricane events.\n\n\n\nEvent\nThe accepted input for an event in FloodAdapt.\n\n\nSyntheticEvent\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\nHistoricalEvent\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\nHurricaneEvent\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\nEventSet\nBaseModel describing the expected variables and data types for parameters of EventSet.\n\n\nTimeFrame\nClass representing a time frame for a simulation.\n\n\nIForcing\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\nForcingType\nEnum class for the different types of forcing parameters.\n\n\nTemplate\nClass describing the accepted input for the variable template in Event.\n\n\nMode\nClass describing the accepted input for the variable mode in Event.\n\n\nSubEventModel\nThe accepted input for a sub event in FloodAdapt.\n\n\n\n\n\n\nClimate and socio-economic projections for future scenario analysis.\n\n\n\nProjection\nThe accepted input for a projection in FloodAdapt.\n\n\nPhysicalProjection\nThe accepted input for a physical projection in FloodAdapt.\n\n\nSocioEconomicChange\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\n\n\n\nScenario modeling for assessing different flood risk management approaches. Scenarios consist of a combination of event, projection, and strategy.\n\n\n\nScenario\nBaseModel describing the expected variables and data types of a scenario.\n\n\n\n\n\n\nBenefit calculation for different flood risk management strategies. Benefits can be used to perform cost benefit analysis on a strategy, which is calculated based on the impact of the event on the population and infrastructure.\n\n\n\nBenefit\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\nCurrentSituationModel\nThe accepted input for a current situation in FloodAdapt.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "api_ref/api_index.html#unit-system",
    "href": "api_ref/api_index.html#unit-system",
    "title": "Flood Adapt v0.3.8",
    "section": "",
    "text": "Unit system for FloodAdapt. The unit system is used to convert between different units of measurement, and to define the units of the input and output of the models.\n\n\n\nValueUnitPair\nRepresents a value with associated units.\n\n\nUnitfulLength\nCombination of length and unit.\n\n\nUnitfulHeight\nCombination of height and unit.\n\n\nUnitfulArea\nCombination of area and unit.\n\n\nUnitfulVelocity\nCombination of velocity and unit.\n\n\nUnitfulDirection\nCombination of direction and unit.\n\n\nUnitfulDischarge\nCombination of discharge and unit.\n\n\nUnitfulIntensity\nCombination of intensity and unit.\n\n\nUnitfulVolume\nCombination of volume and unit.\n\n\nUnitfulTime\nCombination of time and unit.\n\n\nUnitfulLengthRefValue\nCombination of length and unit with a reference value.\n\n\nUnitTypesLength\nUnits of length.\n\n\nUnitTypesArea\nUnits of area.\n\n\nUnitTypesVolume\nUnits of volume.\n\n\nUnitTypesVelocity\nUnits of velocity.\n\n\nUnitTypesDirection\nUnits of direction.\n\n\nUnitTypesTime\nUnits of time.\n\n\nUnitTypesDischarge\nUnits of discharge.\n\n\nUnitTypesIntensity\nUnits of intensity.\n\n\nVerticalReference\nVertical reference for height.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "api_ref/ValueUnitPair.html",
    "href": "api_ref/ValueUnitPair.html",
    "title": "ValueUnitPair",
    "section": "",
    "text": "unit_system.ValueUnitPair()\nRepresents a value with associated units.\n\n\n\nvalue : float\n\nThe numerical value.\n\nunits : Unit\n\nThe units of the value.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert\nReturn the value converted to the new units.\n\n\ntransform\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\n\n\nunit_system.ValueUnitPair.convert(new_units: TUnit)\nReturn the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nconverted_value : float\n\nThe converted value.\n\n\n\n\n\n\nunit_system.ValueUnitPair.transform(new_units: TUnit)\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nvalue_unit_pair : ValueUnitPair\n\nThe new ValueUnitPair instance with the value converted to the new units and the new units.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "api_ref/ValueUnitPair.html#attributes",
    "href": "api_ref/ValueUnitPair.html#attributes",
    "title": "ValueUnitPair",
    "section": "",
    "text": "value : float\n\nThe numerical value.\n\nunits : Unit\n\nThe units of the value.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "api_ref/ValueUnitPair.html#methods",
    "href": "api_ref/ValueUnitPair.html#methods",
    "title": "ValueUnitPair",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconvert\nReturn the value converted to the new units.\n\n\ntransform\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\n\n\nunit_system.ValueUnitPair.convert(new_units: TUnit)\nReturn the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nconverted_value : float\n\nThe converted value.\n\n\n\n\n\n\nunit_system.ValueUnitPair.transform(new_units: TUnit)\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nvalue_unit_pair : ValueUnitPair\n\nThe new ValueUnitPair instance with the value converted to the new units and the new units.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "api_ref/UnitfulVelocity.html",
    "href": "api_ref/UnitfulVelocity.html",
    "title": "UnitfulVelocity",
    "section": "",
    "text": "unit_system.UnitfulVelocity()\nCombination of velocity and unit.\n\n\n\nvalue : float\n\nThe velocity value, must be greater than or equal to 0.\n\nunits : UnitTypesVelocity\n\nThe unit of velocity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVelocity"
    ]
  },
  {
    "objectID": "api_ref/UnitfulVelocity.html#attributes",
    "href": "api_ref/UnitfulVelocity.html#attributes",
    "title": "UnitfulVelocity",
    "section": "",
    "text": "value : float\n\nThe velocity value, must be greater than or equal to 0.\n\nunits : UnitTypesVelocity\n\nThe unit of velocity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVelocity"
    ]
  },
  {
    "objectID": "api_ref/UnitfulLengthRefValue.html",
    "href": "api_ref/UnitfulLengthRefValue.html",
    "title": "UnitfulLengthRefValue",
    "section": "",
    "text": "unit_system.UnitfulLengthRefValue()\nCombination of length and unit with a reference value.\n\n\n\nvalue : float\n\nThe length value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of length.\n\ntype : VerticalReference\n\nThe vertical reference for the length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLengthRefValue"
    ]
  },
  {
    "objectID": "api_ref/UnitfulLengthRefValue.html#attributes",
    "href": "api_ref/UnitfulLengthRefValue.html#attributes",
    "title": "UnitfulLengthRefValue",
    "section": "",
    "text": "value : float\n\nThe length value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of length.\n\ntype : VerticalReference\n\nThe vertical reference for the length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLengthRefValue"
    ]
  },
  {
    "objectID": "api_ref/UnitfulIntensity.html",
    "href": "api_ref/UnitfulIntensity.html",
    "title": "UnitfulIntensity",
    "section": "",
    "text": "unit_system.UnitfulIntensity()\nCombination of intensity and unit.\n\n\n\nvalue : float\n\nThe intensity value, must be greater than or equal to 0.\n\nunits : UnitTypesIntensity\n\nThe unit of intensity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulIntensity"
    ]
  },
  {
    "objectID": "api_ref/UnitfulIntensity.html#attributes",
    "href": "api_ref/UnitfulIntensity.html#attributes",
    "title": "UnitfulIntensity",
    "section": "",
    "text": "value : float\n\nThe intensity value, must be greater than or equal to 0.\n\nunits : UnitTypesIntensity\n\nThe unit of intensity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulIntensity"
    ]
  },
  {
    "objectID": "api_ref/UnitfulDischarge.html",
    "href": "api_ref/UnitfulDischarge.html",
    "title": "UnitfulDischarge",
    "section": "",
    "text": "unit_system.UnitfulDischarge()\nCombination of discharge and unit.\n\n\n\nvalue : float\n\nThe discharge value, must be greater than or equal to 0.\n\nunits : UnitTypesDischarge\n\nThe unit of discharge.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDischarge"
    ]
  },
  {
    "objectID": "api_ref/UnitfulDischarge.html#attributes",
    "href": "api_ref/UnitfulDischarge.html#attributes",
    "title": "UnitfulDischarge",
    "section": "",
    "text": "value : float\n\nThe discharge value, must be greater than or equal to 0.\n\nunits : UnitTypesDischarge\n\nThe unit of discharge.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDischarge"
    ]
  },
  {
    "objectID": "api_ref/UnitfulArea.html",
    "href": "api_ref/UnitfulArea.html",
    "title": "UnitfulArea",
    "section": "",
    "text": "unit_system.UnitfulArea()\nCombination of area and unit.\n\n\n\nvalue : float\n\nThe area value, must be greater than or equal to 0.\n\nunits : UnitTypesArea\n\nThe unit of area.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulArea"
    ]
  },
  {
    "objectID": "api_ref/UnitfulArea.html#attributes",
    "href": "api_ref/UnitfulArea.html#attributes",
    "title": "UnitfulArea",
    "section": "",
    "text": "value : float\n\nThe area value, must be greater than or equal to 0.\n\nunits : UnitTypesArea\n\nThe unit of area.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulArea"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesVelocity.html",
    "href": "api_ref/UnitTypesVelocity.html",
    "title": "UnitTypesVelocity",
    "section": "",
    "text": "unit_system.UnitTypesVelocity()\nUnits of velocity.\n\n\n\nmps : meters per second\n\n\n\nknots : nautical miles per hour\n\n\n\nmph : miles per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVelocity"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesVelocity.html#attributes",
    "href": "api_ref/UnitTypesVelocity.html#attributes",
    "title": "UnitTypesVelocity",
    "section": "",
    "text": "mps : meters per second\n\n\n\nknots : nautical miles per hour\n\n\n\nmph : miles per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVelocity"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesLength.html",
    "href": "api_ref/UnitTypesLength.html",
    "title": "UnitTypesLength",
    "section": "",
    "text": "unit_system.UnitTypesLength()\nUnits of length.\n\n\n\nmeters : meters\n\n\n\ncentimeters : centimeters\n\n\n\nmillimeters : millimeters\n\n\n\nfeet : feet\n\n\n\ninch : inch\n\n\n\nmiles : miles",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesLength"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesLength.html#attributes",
    "href": "api_ref/UnitTypesLength.html#attributes",
    "title": "UnitTypesLength",
    "section": "",
    "text": "meters : meters\n\n\n\ncentimeters : centimeters\n\n\n\nmillimeters : millimeters\n\n\n\nfeet : feet\n\n\n\ninch : inch\n\n\n\nmiles : miles",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesLength"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesDischarge.html",
    "href": "api_ref/UnitTypesDischarge.html",
    "title": "UnitTypesDischarge",
    "section": "",
    "text": "unit_system.UnitTypesDischarge()\nUnits of discharge.\n\n\n\ncfs : cubic feet per second\n\n\n\ncms : cubic meters per second",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDischarge"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesDischarge.html#attributes",
    "href": "api_ref/UnitTypesDischarge.html#attributes",
    "title": "UnitTypesDischarge",
    "section": "",
    "text": "cfs : cubic feet per second\n\n\n\ncms : cubic meters per second",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDischarge"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesArea.html",
    "href": "api_ref/UnitTypesArea.html",
    "title": "UnitTypesArea",
    "section": "",
    "text": "unit_system.UnitTypesArea()\nUnits of area.\n\n\n\nm2 : square meters\n\n\n\ndm2 : square decimeters\n\n\n\ncm2 : square centimeters\n\n\n\nmm2 : square millimeters\n\n\n\nsf : square feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesArea"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesArea.html#attributes",
    "href": "api_ref/UnitTypesArea.html#attributes",
    "title": "UnitTypesArea",
    "section": "",
    "text": "m2 : square meters\n\n\n\ndm2 : square decimeters\n\n\n\ncm2 : square centimeters\n\n\n\nmm2 : square millimeters\n\n\n\nsf : square feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesArea"
    ]
  },
  {
    "objectID": "api_ref/Template.html",
    "href": "api_ref/Template.html",
    "title": "Template",
    "section": "",
    "text": "objects.Template()\nClass describing the accepted input for the variable template in Event.\n\n\n\nSynthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template."
  },
  {
    "objectID": "api_ref/Template.html#attributes",
    "href": "api_ref/Template.html#attributes",
    "title": "Template",
    "section": "",
    "text": "Synthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template."
  },
  {
    "objectID": "api_ref/SubEventModel.html",
    "href": "api_ref/SubEventModel.html",
    "title": "SubEventModel",
    "section": "",
    "text": "objects.SubEventModel()\nThe accepted input for a sub event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event."
  },
  {
    "objectID": "api_ref/SubEventModel.html#attributes",
    "href": "api_ref/SubEventModel.html#attributes",
    "title": "SubEventModel",
    "section": "",
    "text": "name : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event."
  },
  {
    "objectID": "api_ref/SocioEconomicChange.html",
    "href": "api_ref/SocioEconomicChange.html",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "objects.SocioEconomicChange()\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\npopulation_growth_existing : float\n\nThe existing population growth rate. default=0.0\n\neconomic_growth : float\n\nThe economic growth rate. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth rate for new developments. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of new developments. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of new developments. default=None."
  },
  {
    "objectID": "api_ref/SocioEconomicChange.html#attributes",
    "href": "api_ref/SocioEconomicChange.html#attributes",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "population_growth_existing : float\n\nThe existing population growth rate. default=0.0\n\neconomic_growth : float\n\nThe economic growth rate. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth rate for new developments. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of new developments. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of new developments. default=None."
  },
  {
    "objectID": "api_ref/Settings.html",
    "href": "api_ref/Settings.html",
    "title": "Settings",
    "section": "",
    "text": "Settings()\nThe configuration settings for the FloodAdapt database and integrator.\nPrecedence is as follows: user arguments &gt; environment variables &gt; defaults in this class. When loading is done, the settings are validated and the environment variables are updated with the loaded values.\nIf any required settings are missing or invalid, a ValidationError is raised.\n\n\nfrom flood_adapt import Settings\nOne of the following:\n\nLoad settings from environment variables, if no environment variables are set, use defaults defined in the class: settings = Settings()\nLoad settings from a .toml file, overwriting any environment variables set: settings = Settings.read(toml_path: Path)\nLoad settings from keyword arguments, overwriting any environment variables: settings = Settings(DATABASE_ROOT=\"path/to/database\", DATABASE_NAME=\"database_name\")\n\n\n\n\n\ndatabase_name : str\n\nThe name of the database.\n\ndatabase_root : Path\n\nThe root directory of the database.\n\ndelete_crashed_runs : bool\n\nWhether to delete crashed/corrupted runs immediately after they are detected.\n\nsfincs_path : Path\n\nThe path to the SFINCS binary.\n\nfiat_path : Path\n\nThe path to the FIAT binary.\n\nvalidate_allowed_forcings : bool\n\nWhether to validate the forcing types and sources against the allowed forcings in the event model.\n\nvalidate_bin_paths : bool\n\nWhether to validate the existence of the paths to the SFINCS and FIAT binaries.\n\n\n\n\n\ndatabase_path : Path The full path to the database.\n\n\n\n\n: ValidationError\n\nIf required settings are missing or invalid.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nread\nParse the configuration file and return the parsed settings.\n\n\nwrite\nWrite the configuration settings to a .toml file.\n\n\n\n\n\nSettings.read(toml_path: Path)\nParse the configuration file and return the parsed settings.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : Settings\n\nThe parsed configuration settings.\n\n\n\n\n\n\n: ValidationError\n\nIf required configuration values are missing or if there is an error parsing the configuration file.\n\n\n\n\n\n\nSettings.write(toml_path: Path)\nWrite the configuration settings to a .toml file.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Settings.html#usage",
    "href": "api_ref/Settings.html#usage",
    "title": "Settings",
    "section": "",
    "text": "from flood_adapt import Settings\nOne of the following:\n\nLoad settings from environment variables, if no environment variables are set, use defaults defined in the class: settings = Settings()\nLoad settings from a .toml file, overwriting any environment variables set: settings = Settings.read(toml_path: Path)\nLoad settings from keyword arguments, overwriting any environment variables: settings = Settings(DATABASE_ROOT=\"path/to/database\", DATABASE_NAME=\"database_name\")",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Settings.html#attributes",
    "href": "api_ref/Settings.html#attributes",
    "title": "Settings",
    "section": "",
    "text": "database_name : str\n\nThe name of the database.\n\ndatabase_root : Path\n\nThe root directory of the database.\n\ndelete_crashed_runs : bool\n\nWhether to delete crashed/corrupted runs immediately after they are detected.\n\nsfincs_path : Path\n\nThe path to the SFINCS binary.\n\nfiat_path : Path\n\nThe path to the FIAT binary.\n\nvalidate_allowed_forcings : bool\n\nWhether to validate the forcing types and sources against the allowed forcings in the event model.\n\nvalidate_bin_paths : bool\n\nWhether to validate the existence of the paths to the SFINCS and FIAT binaries.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Settings.html#properties",
    "href": "api_ref/Settings.html#properties",
    "title": "Settings",
    "section": "",
    "text": "database_path : Path The full path to the database.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Settings.html#raises",
    "href": "api_ref/Settings.html#raises",
    "title": "Settings",
    "section": "",
    "text": ": ValidationError\n\nIf required settings are missing or invalid.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Settings.html#methods",
    "href": "api_ref/Settings.html#methods",
    "title": "Settings",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nread\nParse the configuration file and return the parsed settings.\n\n\nwrite\nWrite the configuration settings to a .toml file.\n\n\n\n\n\nSettings.read(toml_path: Path)\nParse the configuration file and return the parsed settings.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : Settings\n\nThe parsed configuration settings.\n\n\n\n\n\n\n: ValidationError\n\nIf required configuration values are missing or if there is an error parsing the configuration file.\n\n\n\n\n\n\nSettings.write(toml_path: Path)\nWrite the configuration settings to a .toml file.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "api_ref/Scenario.html",
    "href": "api_ref/Scenario.html",
    "title": "Scenario",
    "section": "",
    "text": "objects.Scenario()\nBaseModel describing the expected variables and data types of a scenario.\nA scenario is a combination of an event, a projection, and a strategy, that all should be saved in the database.\n\n\n\nevent : str\n\nThe name of the event.\n\nprojection : str\n\nThe name of the projection.\n\nstrategy : str\n\nThe name of the strategy."
  },
  {
    "objectID": "api_ref/Scenario.html#attributes",
    "href": "api_ref/Scenario.html#attributes",
    "title": "Scenario",
    "section": "",
    "text": "event : str\n\nThe name of the event.\n\nprojection : str\n\nThe name of the projection.\n\nstrategy : str\n\nThe name of the strategy."
  },
  {
    "objectID": "api_ref/Projection.html",
    "href": "api_ref/Projection.html",
    "title": "Projection",
    "section": "",
    "text": "objects.Projection()\nThe accepted input for a projection in FloodAdapt.\nA projection is a combination of a physical projection and a socio-economic change.\n\n\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers."
  },
  {
    "objectID": "api_ref/Projection.html#attributes",
    "href": "api_ref/Projection.html#attributes",
    "title": "Projection",
    "section": "",
    "text": "physical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers."
  },
  {
    "objectID": "api_ref/Object.html",
    "href": "api_ref/Object.html",
    "title": "Object",
    "section": "",
    "text": "objects.object_model.Object()\nBase class for FloodAdapt objects.\n\n\n\nname : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nsave\nSave object to disk.\n\n\nsave_additional\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\n\n\n\n\n\nobjects.object_model.Object.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.object_model.Object.save(toml_path: Path | str | os.PathLike)\nSave object to disk.\n\n\n\ntoml_path : Path | str | os.PathLike\n\nPath to the file to save.\n\n\n\n\n\n\nobjects.object_model.Object.save_additional(\n    output_dir: Path | str | os.PathLike,\n)\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\nThis method should be overridden if the object has additional files.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "api_ref/Object.html#attributes",
    "href": "api_ref/Object.html#attributes",
    "title": "Object",
    "section": "",
    "text": "name : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "api_ref/Object.html#methods",
    "href": "api_ref/Object.html#methods",
    "title": "Object",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nsave\nSave object to disk.\n\n\nsave_additional\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\n\n\n\n\n\nobjects.object_model.Object.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.object_model.Object.save(toml_path: Path | str | os.PathLike)\nSave object to disk.\n\n\n\ntoml_path : Path | str | os.PathLike\n\nPath to the file to save.\n\n\n\n\n\n\nobjects.object_model.Object.save_additional(\n    output_dir: Path | str | os.PathLike,\n)\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\nThis method should be overridden if the object has additional files.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "api_ref/MeasureType.html",
    "href": "api_ref/MeasureType.html",
    "title": "MeasureType",
    "section": "",
    "text": "objects.MeasureType()\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\nEach type of measure is associated with a category (hazard or impact) and can be used to determine the type of measure.\n\n\n\nfloodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure."
  },
  {
    "objectID": "api_ref/MeasureType.html#attributes",
    "href": "api_ref/MeasureType.html#attributes",
    "title": "MeasureType",
    "section": "",
    "text": "floodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure."
  },
  {
    "objectID": "api_ref/IForcing.html",
    "href": "api_ref/IForcing.html",
    "title": "IForcing",
    "section": "",
    "text": "objects.IForcing()\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\n\n\n\nName\nDescription\n\n\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory."
  },
  {
    "objectID": "api_ref/IForcing.html#methods",
    "href": "api_ref/IForcing.html#methods",
    "title": "IForcing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory."
  },
  {
    "objectID": "api_ref/HistoricalEvent.html",
    "href": "api_ref/HistoricalEvent.html",
    "title": "HistoricalEvent",
    "section": "",
    "text": "objects.HistoricalEvent()\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "api_ref/HistoricalEvent.html#attributes",
    "href": "api_ref/HistoricalEvent.html#attributes",
    "title": "HistoricalEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "api_ref/ForcingType.html",
    "href": "api_ref/ForcingType.html",
    "title": "ForcingType",
    "section": "",
    "text": "objects.ForcingType()\nEnum class for the different types of forcing parameters.\n\n\n\nRAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level."
  },
  {
    "objectID": "api_ref/ForcingType.html#attributes",
    "href": "api_ref/ForcingType.html#attributes",
    "title": "ForcingType",
    "section": "",
    "text": "RAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level."
  },
  {
    "objectID": "api_ref/FloodProof.html",
    "href": "api_ref/FloodProof.html",
    "title": "FloodProof",
    "section": "",
    "text": "objects.FloodProof()\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "api_ref/FloodProof.html#attributes",
    "href": "api_ref/FloodProof.html#attributes",
    "title": "FloodProof",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "api_ref/EventSet.html",
    "href": "api_ref/EventSet.html",
    "title": "EventSet",
    "section": "",
    "text": "objects.EventSet()\nBaseModel describing the expected variables and data types for parameters of EventSet.\nAn EventSet is a collection of events that can be used to create a scenario and perform a probabilistoc risk assessment.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path."
  },
  {
    "objectID": "api_ref/EventSet.html#attributes",
    "href": "api_ref/EventSet.html#attributes",
    "title": "EventSet",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set."
  },
  {
    "objectID": "api_ref/EventSet.html#methods",
    "href": "api_ref/EventSet.html#methods",
    "title": "EventSet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path."
  },
  {
    "objectID": "api_ref/Elevate.html",
    "href": "api_ref/Elevate.html",
    "title": "Elevate",
    "section": "",
    "text": "objects.Elevate()\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "api_ref/Elevate.html#attributes",
    "href": "api_ref/Elevate.html#attributes",
    "title": "Elevate",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "api_ref/Buyout.html",
    "href": "api_ref/Buyout.html",
    "title": "Buyout",
    "section": "",
    "text": "objects.Buyout()\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "api_ref/Buyout.html#attributes",
    "href": "api_ref/Buyout.html#attributes",
    "title": "Buyout",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "6_demo/king_tides.html",
    "href": "6_demo/king_tides.html",
    "title": "King tides are already a problem ‚Äì how will that look with sea level rise?",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "6_demo/army_corps.html",
    "href": "6_demo/army_corps.html",
    "title": "The Army Corps has a surge-protection plan for the peninsula ‚Äì what about the rest of Charleston?",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_update_model/objects.html",
    "href": "5_update_model/objects.html",
    "title": "Adding / updating objects in the exposure data",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_update_model/dem.html",
    "href": "5_update_model/dem.html",
    "title": "Updating the DEM",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_update_model/aggregation_areas.html",
    "href": "5_update_model/aggregation_areas.html",
    "title": "Adding new aggregation areas",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_technical_docs/dem.html",
    "href": "5_technical_docs/dem.html",
    "title": "Updating the DEM",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_technical_docs/EventScenario.html",
    "href": "5_technical_docs/EventScenario.html",
    "title": "Event scenario",
    "section": "",
    "text": "The FloodAdapt calculation framework to calculate flooding and impacts for an event scenario will be described here, first for the flooding (hazard calculation) and then for the impact calculation.\nThe calculation framework includes the open-source, process-based compound flood model SFINCS that can accurately predict compound flooding due to tide, surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. It also includes the open-source flood impact assessment tool Delft-FIAT which rapidly calculates flood damages to individual buildings and roads. When FloodAdapt is set up in a new location, baseline SFINCS and Delft-FIAT models must be set up as part of that process. FloodAdapt then updates these baseline models to reflect user-defined scenarios, runs the simulations, and post-processes the output to make the evaluation of the scenario as easy as possible for the user. The FloodAdapt setup guide provides guidance for setting up these baseline models: click the links to view the SFINCS setup guide and Delft-FIAT setup guide.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/EventScenario.html#hazard-calculation",
    "href": "5_technical_docs/EventScenario.html#hazard-calculation",
    "title": "Event scenario",
    "section": "Hazard calculation",
    "text": "Hazard calculation\nThrough the use of the FloodAdapt user interface, users enter information on (1) a hydrometeorological event, (2) a projection of future conditions, and (3) a strategy composed of adaptation measures. These three ‚Äòingredients‚Äô define an event scenario. FloodAdapt uses this information to initiate the workflow to calculate flooding and impacts for the event scenario. Figure¬†1 zooms in on the hazard calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.\nIn FloodAdapt there is the option to include two SFINCS models - an ‚Äúoffshore‚Äù model and an ‚Äúoverland‚Äù model. The offshore model is typically a coarser model with an offshore domain adjacent to the area of interest. It is forced by astronomic tide and wind, pressure, and precipitation fields, and calculates nearshore water level time series that serve as boundary conditions for the overland model. The overland model is typically finer resolution and its domain is a hydrological area over land that includes the project area of interest. Only the overland model is strictly necessary in FloodAdapt, but some event types will not be possible without an offshore model, most notably hurricanes.\n\n\n\n\n\n\nFigure¬†1: Hazard calculation framework for an event scenario\n\n\n\nThe hydro-meteorological event is defined by an ‚Äúevent type‚Äù. This is either (1) a historical hurricane, (2) a historical non-hurricane, or (3) a synthetic event. For a historical non-hurricane, there are further two options - (2a) the user has nearshore observed time series of coastal water levels, or (2b) the user does not have observed time series and needs to run an offshore model to generate the nearshore water level time series. Each of these four types has a unique workflow for calculating the overland flooding, which will be described in the coming paragraphs.\nWhat is common to all the overland flooding workflows is the handling of adaptation measures. There are three measure types in FloodAdapt that affect the flood modeling: (1) levee or floodwall, (2) pump, and (3) urban green infrastructure. All of these choices initiate modifications to the overland SFINCS model schematization. When users specify a levee or floodwall as an adaptation measure, FloodAdapt coordinates the updating of the ‚Äúweir‚Äù file in the SFINCS overland model. This file contains coordinates of linear features and their elevation, and serve to block flow in the overland model up to the specified height of the floodwall or levee. The FloodAdapt user interfaces allows users to click a polyline on a map, or import a polyline, and then uses the specifications (location and elevation) to update the weir file. When users specify a pump as (part of) an adaptation measure, FloodAdapt coordinates the updating of the ‚Äúdrn‚Äù (drainage) file in the SFINCS overland model. This file contains the coordinates of the intake and outfall locations and the pump capacity. When a user specifies green infrastructure as a measure, FloodAdapt coordinates the creation or updating of a storage volume input for the SFINCS overland model, based on the green infrastructure area and storage specified. SFINCS ‚Äòstores‚Äô this water volume (defined per cell) before any overland flooding takes place.\nFor historical hurricanes, the track information is pulled by the user interface from the National Hurricane Center HURDAT2 database. The first step in the workflow is to translate the track information, like maximum wind speeds and radius, into the wind, pressure, and precipitation fields needed by the offshore SFINCS model. The wind and pressure fields are generated using the Holland 2010 method and the rainfall field is generated using the IPET method. This translation is done by an open-source python package called the Coastal Hazard Toolkit - Cyclone, or CHT-cyclone. The astronomic tidal boundary for the offshore SFINCS model is obtained using another CHT package called CHT-tide. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The wind, pressure, and precipitation fields and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels (tide + surge). The input to the SFINCS overland model includes the simulated nearshore water level time series, the wind, pressure, and precipitation fields generated from the track, and any river discharge time series specified by the user in the user interface (when rivers are present in the site). It is also possible in FloodAdapt for a user to ‚Äúturn off‚Äù the rainfall in the overland model, for example to explore the difference in flooding with and without the inclusion of rainfall. Using these inputs, the SFINCS overland model is run and the resulting maximum flood depth maps are returned. Additionally, if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured, water level time series will be saved for these locations.\nFor a historical event without observed nearshore water levels, FloodAdapt orchestrates the downloading of gridded wind, pressure, and precipitation data from the NOAA global forecasting system reanalysis data. These data are available at a spatial resolution of 0.5 degrees for dates prior to February 2021, and 0.25 degrees after. The downloading and formatting of these data are done with the Coastal Hazard Toolkit package CHT-meteo. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The gridded wind, pressure, and precipitation data and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels. For this event type, users are able to specify rainfall, wind, and river discharge inputs for the overland flood model. These values, together with the simulated nearshore water levels are input into the overland flood model which outputs maximum flood depth maps and - if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.\n\n\n\n\n\n\nSea level offset for offshore simulations\n\n\n\nFor hazard simulations that use the offshore SFINCS model, the nearshore water levels are returned relative to mean sea level. However, sea levels have risen since the mean sea level was set for the 1983-2001 epoch. This discrepancy results in predicted/simulated nearshore water levels that are lower than what would be observed at a tide gauge. Trend analysis can be done to determine an appropriate level of ‚Äúoffset‚Äù to correct mean sea level to present day conditions. This value is set in the FloodAdapt site configuration file, and can be modified by an advanced user. The offset is applied in the workflow where the future-condition sea level rise is added. This is only done for offshore events, because nearshore gauged data represent observed water levels and will already include sea level increases in the measurements. Similarly, for synthetic events, it is assumed that users will select a nearshore water level of interest, and any sea level rise of interest will be captured as a projection relative to current conditions.\n\n\n\n\n\n\n\n\nVertical datum references in the offshore and overland models\n\n\n\nIf there is a difference in vertical datum between the offshore and overland model, FloodAdapt automatically corrects the water level time series output from the offshore model to the datum used in the overland model prior to running the overland model.\n\n\nFor a historical event with observed nearshore water levels, FloodAdapt offers the user the choice to upload their own time series data of nearshore water levels, or the user can specify a start and stop time of the event and click the ‚ÄòDownload water levels button‚Äô which downloads the time series data from the NOAA website. More details about this and how users can specify or import rainfall, wind, and river discharge data for the event are provided in the user manual here. If the user has specified sea level rise in their scenario future-conditions projection, it will be added to the specified nearshore water levels at this point in the workflow prior to running the overland model. For this event type, only the SFINCS overland model needs to be run. The water level time series, rainfall, wind, and river discharge inputs are used to force the overland model, which then outputs maximum flood depth maps and - if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.\nFor a synthetic event, the workflow to derive the flood map and simulated water level time series at observation points is identical to the workflow for the historical event with observed nearshore water levels. It only differs in terms of the specification of the forcing data. To see more details on how users can specify synthetic events in the user manual here.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/EventScenario.html#impact-calculation",
    "href": "5_technical_docs/EventScenario.html#impact-calculation",
    "title": "Event scenario",
    "section": "Impact calculation",
    "text": "Impact calculation\nOnce a hazard calculation is complete, FloodAdapt initiates the impact calculation, making use of the simulated flood depth map. Figure¬†2 zooms in on the impact calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.\nIn the user interface, the user is able to specify impact-related future conditions (economic growth and/or population growth) and impact-reducing adaptation options: buyout, elevate, and floodproof. The user manual describes how a user can specify impact-related projections here and impact-reducting adaptation options here. When a scenario is created containing any of these features it initiates a modification of the baseline Delft-FIAT model.\n\n\n\n\n\n\nFigure¬†2: Impact calculation framework for an event scenario\n\n\n\nThere are three impact-reducing adaptation measures in FloodAdapt that affect the impact model schematization: (1) buyouts (2) elevate, and (3) floodproof. These are all measures taken at the building level. When users specify a buyout measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù, setting them both to zero for buildings selected for buyout. This ensures that these buildings no longer accrue any damage during flood events. When users specify an elevate measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attribute ‚Äúfinished floor height‚Äù, setting it to the user-specified height. Users are able to elevate buildings to a specified height above base flood elevation (BFE) if they have included a BFE map during system setup. In this case, FloodAdapt calculates the elevation of the finished floor using the BFE and specified height above BFE, and then subtracts the ground elevation at the building location to determine the required finished floor height. The ground elevation is an attribute of the building in the Delft-FIAT exposure data (which should be aligned with the DEM used in the flood model, something that is arranged during system setup). When users specify a floodproofing measure, FloodAdapt coordinates the updating of the depth-damage curves for the buildings selected for floodproofing. It sets the damage fraction to zero in the depth-damage curve up to the floodpoofing height. After that height, the depth-damage curve resumes its original shape.\nFuture socio-economic projections also initiate updating of the Delft-FIAT model. Users can choose economic growth or population growth. For population growth there are two options: (1) the population increases in the current built area or (2) population increases in currently undeveloped areas. For the former, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù by the percentage population increase specified. The idea is that the building stock density will increase, and hence also the potential damages during flood events. For population growth in currently-undeveloped areas, FloodAdapt coordinates the creation of a hybrid exposure asset with the footprint of the specified to-be-developed area. The attributes of this hybrid asset are a weighted average of the existing exposed assets, meaning the new area is assumed to reflect the make-up (in terms of building types) of the existing built area. This method was implemented to evaluate future development and assess how it will contribute to risk in the future. The method allows for users to specify the finished floor height of the new development buildings, helping to provide a foundation for ordinances on new development heights. NOTE: the ‚Äúpopulation growth in new development areas‚Äù feature is under-tested and is considered by the FloodAdapt development team to be in need of improvements before it reaches its potential. When users enter a percentage for economic growth, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù by the percentage economic growth specified.\nOnce the Delft-FIAT model schematization has been updated, FloodAdapt coordinates the running of Delft-FIAT with the simulated flood depth map from the hazard calculation. The calculation method of Delft-FIAT follows a standard approach and is described in the Delft-FIAT github documentation and in the Delft-FIAT setup documentation. Figure¬†3 shows conceptually how Delft-FIAT calculates damages. Note that no indirect damages are calculated with Delft-FIAT, only direct damages to assets in the exposure dataset.\n\n\n\n\n\n\nFigure¬†3: Overview of the calculation method in Delft-FIAT\n\n\n\nThe impact calculation returns inundation depths and economic damages for every asset in the Delft-FIAT model. These results are passed through a post-processing toolkit. This aggregates the damages to aggregation levels specified during system setup, creates vector files of impacts, and generates the FloodAdapt infographic and metrics.\nTo read more about the output from an event scenario calculation, please see the user manual section on Output here.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/BenefitCalc.html",
    "href": "5_technical_docs/BenefitCalc.html",
    "title": "Benefit Calculation",
    "section": "",
    "text": "Flood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits. The user guide section on benefits provides comprehensive guidance on preparing and evaluating benefits in FloodAdapt. This technical documentation is limited to the description of the benefit calculation.\nThe benefit calculation uses output from four scenarios:\n\nThe risk without the strategy implemented in current conditions\nThe risk with the strategy implemented in current conditions\nThe risk without the strategy implemented in future conditions\nThe risk with the strategy implemented in future conditions\n\nWhen a user runs a benefit analysis in FloodAdapt, the following benefit calculations are carried out:\n\nThe risk-reduction benefit under current conditions is calculated as the difference in the risk without the strategy and with the strategy under the ‚Äúcurrent‚Äù projection (representing current conditions).\nThe risk-reduction benefit under future conditions (for the year specified in the end-of-analysis situation) is calculated as the difference in the risk without the strategy and with the strategy under the future projection specified in the end-of-analysis situation when you created your benefit analysis.\nThe annual risk-reduction benefits are calculated by linearly interpolating between the risk-reduction benefits under current conditions (in the current year) and the risk-reduction benefits under future conditions (in the end-of-analysis year).\nThe annual discounted benefits (\\(B_d(t)\\)) are calculated as\n\\(B_d\\ (t)=B(t)/(1+r)^t\\ \\)\nwhere \\(B(t)\\) is the risk-reduction benefit in year \\(t\\), \\(t\\) is the year since implementation, and \\(r\\) is the discount rate.\nThe (present value of the) benefits are calculated as the sum of the annual discounted benefits over the analysis duration (\\(N\\) years).\n\\(Benefits\\ =\\ \\sum_{t=0}^N B_d\\ (t)\\ \\)\n\nWhen cost information is provided, FloodAdapt additionally calculates:\n\nThe (present value of the) costs - calculated only when implementation and/or maintenance costs are provided in the benefit analysis input. This is calculated in the same way as the present value of the benefits: \\(Costs\\ =\\ \\sum_{t=0}^N C_d\\ (t)\\ \\)\nwhere \\(C_d(t)\\) is the discounted cost in year \\(t\\).\nThe benefit-cost ratio (BCR) is calculated as the present value of the benefits divided by the present value of the costs.\nThe net present value (NPV) is the difference in annual discounted benefits and costs, summed up over the analysis period.\n\\(NPV\\ =\\ \\sum_{t=0}^N [(B(t)-C(t))/(1+r)^t]\\ \\)\nThe internal rate of return (IRR) represents the discount rate at which the NPV would be equal to zero. Higher IRR indicates a better investment, because in this case the benefits weigh strongly against the costs.\n\n\n\n\n\n\n\nSome metrics are only calculated when cost information is provided!\n\n\n\nThe present value of the costs, benefit cost ratio, net present value, and internal rate of return are only calculated if the user has provided information on implementation and/or maintenance costs when they created their benefit analysis. When this information is not provided, the benefits are calculated, but none of the metrics that require comparison with costs.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Benefit Calculation"
    ]
  },
  {
    "objectID": "4_user_guide/site_tab.html",
    "href": "4_user_guide/site_tab.html",
    "title": "Site tab",
    "section": "",
    "text": "Don‚Äôt feel like reading? No problem! Check out our video about the FloodAdapt site tab: \nThe user interface opens by default to the Site tab, shown for the example of Charleston, South Carolina in Figure¬†1. The site tab shows the aggregation areas that have been defined for the site. If more than one type of aggregation area has been defined, the user can select which one they want to view from the drop-down box ‚ÄòAggregation Areas Type‚Äô. Examples of aggregation area types are census blocks, neighborhoods, or zip codes. The ‚ÄòAggregation Areas‚Äô box populates with the different areas for the selected aggregation type. The user can hover over an area and see the name of that area. Similarly, they can select an area of the ‚ÄòAggregation Areas‚Äô list and that area will become highlighted on the map.\n\n\n\n\n\n\nFigure¬†1: The site tab, shown here for the example of Charleston, South Carolina\n\n\n\nThe site tab also shows the extent of the flood model. This can be substantially larger than the area of interest. If a user zooms out they can see the extent of the area, as show in Figure¬†2\n\n\n\n\n\n\nFigure¬†2: The site tab, zoomed out to show the full flood model extent (in red)\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Site tab"
    ]
  },
  {
    "objectID": "4_user_guide/scenario_results/single_event.html",
    "href": "4_user_guide/scenario_results/single_event.html",
    "title": "Single-event scenario output",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/scenario_results/event_set.html",
    "href": "4_user_guide/scenario_results/event_set.html",
    "title": "Event-set (probabilistic risk) scenario output",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/projections/index.html",
    "href": "4_user_guide/projections/index.html",
    "title": "Projections",
    "section": "",
    "text": "FloodAdapt can simulate future climate and socio-economic conditions.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt can simulate future climate projections - sea level rise, increased tropical storm frequencies, precipitation changes, and socio-economic projections - population growth and economic growth\n\n\n\nOn the Projections Tab in FloodAdapt, click ‚ÄòAdd Projection‚Äô to open the projections window (see Figure¬†2)\n\n\n\n\n\n\nFigure¬†2: Projections window on the Projections tab in FloodAdapt\n\n\n\nIn this window you can specify a climate projection, a socio-economic projection, or a combination (for example: 10% population growth with 1 foot of SLR).\nClick the following links to learn more about how climate and socio-economic projections can be specified in FloodAdapt, and how they are represented in the modeling.\nClimate projections\nSocio-economic projections\n\n\n\n Back to top",
    "crumbs": [
      "Projections"
    ]
  },
  {
    "objectID": "4_user_guide/output/index.html",
    "href": "4_user_guide/output/index.html",
    "title": "Output",
    "section": "",
    "text": "The FloodAdapt Output tab displays flood and impact maps, time series of water levels at observation points, a tabulated summary of metrics, and a visual infographic for simulated scenarios to help users understand and evaluate their scenarios. The output for event scenarios and risk scenarios differs slightly, but output for both types of scenarios is accessible from the Output tab. FloodAdapt additionally places scenario output locally on your computer in an Output folder within your FloodAdapt database.",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "4_user_guide/output/index.html#floodadapt-output-tab",
    "href": "4_user_guide/output/index.html#floodadapt-output-tab",
    "title": "Output",
    "section": "FloodAdapt output tab",
    "text": "FloodAdapt output tab\nThe Output tab has a map window and below it a panel (see Figure¬†1). The left section of the panel contains a scenario table with the scenarios that have been simulated. These can be sorted by name, date created, or by scenario components (event, projection, strategy). Selecting a scenario in this panel will load the output results for that scenario. The middle section of the panel contains different map visualization options, and the right section contains tabulated metrics. The collapsible frame on the Output tab can be used to view the scenario infographic (see Figure¬†2 and Figure¬†3). Note that the creation of the infographic is optional (specified at system setup). When an infographic is not configured for a site, the collapsible frame will display the documentation instead of the infographic.\n\n\n\n\n\n\nFigure¬†1: Output tab in FloodAdapt\n\n\n\n\n\n\n\n\n\nViewing the infographic\n\n\n\nThe infographic is visible in the map window‚Äôs collapsible frame. The user can view the infographic by clicking the little white triangle on the border of the frame to the right of the map window (see Figure¬†1).\n\n\n\nMetrics and infographic\nThe metrics and infographic will contain different information for a risk scenario and an event scenario. This information is configured separately for event scenarios and risk scenarios at system set-up (see information on how the infometrics and infographic are configured in the setup guide). Figure¬†2 shows an example of the infographic for an event scenario and Figure¬†3 shows an example of the infographic for a risk scenario. The basic structure of the infographic, highlighted in the figures, is fixed but the information within that structure can be tailored at system setup.\n\n\n\n\n\n\nFigure¬†2: Infographic for an event scenario\n\n\n\n\n\n\n\n\n\nFigure¬†3: Infographic for a risk scenario\n\n\n\n\n\nTime series at observation points\nIf observation points have been configured for a site (these are optional), the time series of modeled water levels at these points can be viewed by clicking on the observation points in the map window (see Figure¬†4). A graph window will pop up and show the modeled water level time series over the duration of the event. If one of the observation points is located at a water level gauge, the measured water levels will also be displayed. To make the time series popup disappear, click anywhere else in the map window.\n\n\n\n\n\n\nFigure¬†4: Time series of water levels at observation points\n\n\n\n\n\nMap visualization options for an event scenario\nWhen an event scenario is selected in the scenario panel, there are four map visualization options (see Figure¬†1). Clicking the check boxes next to any of these four options will display the corresponding layer in the map window.\n\nFlood map - shows the extent and depth of flooding for the scenario.\nBuilding damages - displayed as a heat map when zoomed out (this helps identify which areas are interesting to look at in more detail). Zooming in transitions the heat map to a display of building-level damages.\nAggregated damages - show the damages summed up over different areas, such as census blocks or neighborhoods. The areas will correspond to the aggregation areas that are shown in the site tab; these areas are specified at system setup. The aggregation drop-down menu to the right of the ‚ÄúAggregated damages‚Äù check box can be used to switch between different areas.\nRoad flooding - shows the water depth on the roads.\n\nIn addition to the four map layers, there is also the option to select an additional layer to view in the map window. This is found in the ‚ÄúShow Layer‚Äù drop-down menu. The specific layers available will depend on how the system was configured at setup, but could contain layers like income, social vulnerability index, or aggregation areas. These layers are often useful to visualize in combination with building level damages or flooding, to better understand who is being impacted in the scenario.\n\n\n\n\n\n\nHow accurate are the building-level damages?\n\n\n\nThe building-level damages show what appear to be precise damage amounts; for example, a building could show $67,233 of damage. In reality, there is uncertainty around this estimate. The uncertainty stems from multiple sources including the accuracy of the flood map at the building location, the correctness of the depth-damage curve for the building, and the accuracy of the exposure data (such as building value or finished floor height). At this moment, uncertainty bands are not provided with the damage estimates in FloodAdapt, but it is important to be aware that these values are not as precisely known as they appear.\n\n\n\n\n\n\n\n\nKeeping things clean\n\n\n\nIt is possible to have all the map layers visible at the same time, but we recommend turning off the other layers when selecting aggregated damages. It makes for a cleaner map!\n\n\n\n\nMap visualization options for a risk scenario\nA risk scenario calculates return period flooding and damages, and also combines this information to calculate risk in terms of expected annual damages. The risk scenario map visualization options allow users to view both return period and risk output.\nWhen a risk scenario is selected, two radio buttons will appear: ‚ÄúReturn period‚Äù and ‚ÄúRisk‚Äù (see Figure¬†5). If you select ‚ÄúReturn period‚Äù, a drop-down window appears from which you can select a return period for which you want to view output. For individual return periods, the map visualization options are identical to those for the event scenario.\n\n\n\n\n\n\nFigure¬†5: Map visualization options for a risk scenario, showing both ‚Äòreturn period‚Äô options and ‚Äòrisk‚Äô options\n\n\n\nWhen the ‚ÄúRisk‚Äù radio button is selected (see Figure¬†5), two map layers can be viewed:\n\nBuilding damages - these damages represent the annual expected damages. When zoomed out this layer is displayed as a heat map (this helps identify which areas are interesting to look at in more detail). Zooming in transitions the heat map to a display of building-level expected annual damages.\nAggregated damages - this layer shows the expected annual damages (risk) summed up over different areas, such as census blocks or neighborhoods. The aggregation drop-down menu to the right of the ‚ÄúAggregated damages‚Äù check box can be used to switch between different areas.\n\nThere are a couple of special notes about the map visualization options for risk results compared to the return period or event scenario results:\n\nEquity weighting\nNext to the Risk radio button there is a checkbox ‚ÄúEquity-weighted‚Äù. Checking it allows users to see equity-weighted risk estimates. Equity weights are calculated in FloodAdapt using information on income. These weights are then multiplied by the damages to derive the equity-weighted risk estimates. This visualization is only available at the same scale for which income data is available. This will typically be census block level. Figure¬†6 shows the difference with and without equity weights, highlighting how it affects low-income and high-income neighborhoods. The low income neighborhoods are represented with blue stars and the high-income with yellow stars. Note that the equity-weighted risk for the low-income neighborhoods is higher than the risk when equity weights are not used.\nNo flood maps\nIn the case of risk results, the flood map and road flooding options are disabled because risk is a damage metric that is integrated over several different flood events, and does not correspond to any single flood event.\n\n\n\n\n\n\n\nFigure¬†6: Aggregated risk map, without equity weighting on the left and with equity weighting on the right. The yellow stars indicate high-income areas and the blue stars indicate low-income areas. The equity-weighted risk is higher for the low-income neighborhoods than without equity weighting, providing a more equitable interpretation of the risk burden for lower-income areas\n\n\n\nIn addition to the output map layers, there is also the option to select an additional layer to view in the map window. This is found in the ‚ÄúShow Layer‚Äù drop-down menu. The specific layers available will depend on how the system was configured at setup, but could contain layers like income, social vulnerability index, or aggregation areas. These layers are often useful to visualize in combination with building level (expected annual) damages, to better understand who is being impacted in the scenario.",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "4_user_guide/output/index.html#output-folder",
    "href": "4_user_guide/output/index.html#output-folder",
    "title": "Output",
    "section": "Output folder",
    "text": "Output folder\nThe output from a simulated scenario is saved on a user‚Äôs computer, aspiring to provide full access and transparency. This section will describe the output folder structure for both an event and a risk scenario.\n\n\n\n\n\n\nWhere can I find the output folder?\n\n\n\nFigure¬†7 shows where the output folder is located within the FloodAdapt database. The database root directory could contain multiple site databases, for different locations, or even variations of databases for the same location. The output folder is located directly inside the site database folder.\n\n\n\n\n\n\nFigure¬†7: Location of the ‚Äúoutput‚Äù folder within the FloodAdapt folder structure\n\n\n\n\n\nThe output folders for the event scenarios and risk scenarios have mostly the same structure; they only differ in the output flood data. Figure¬†8 shows the output structure for an Event scenario and Figure¬†9 shows the output structure for a Risk scenario.\nThe output folder contains a subfolder named ‚Äúscenarios‚Äù. Within this subfolder you will find one folder for each scenario that has been simulated. The name of the folder will be the name of the scenario. Each scenario folder will contain two subfolders: ‚ÄúFlooding‚Äù and ‚ÄúImpacts‚Äù. It will also contain the infographic as an HTML file, a log file with details about the simulation, and the infometrics as CSV files; there will be one CSV for buildling-level metrics and one CSV per aggregation area (e.g.¬†neighborhood or census block group) with aggregated metrics.\nThe ‚ÄúImpacts‚Äù folder will contain multiple files:\n\nDetailed impacts (CSV file) with asset-level information on the assets and their impacts\nImpacts on the buildings, as a geopackage (GPKG) file.\nAggregated impacts, one GPKG file for each aggregation area (e.g.¬†neighborhoods or census block groups)\nImpacts on the roads (GPKG file). Note that these ‚Äúimpacts‚Äù are actually inundation depth on the roads.\n\n\n\n\n\n\n\nInterpreting ‚ÄúImpacts‚Äù for a risk scenario\n\n\n\nFor the risk scenarios, the detailed impacts (CSV file) will have both return period damages and risk per asset. The Impacts on the buildings and the aggregated impacts (GPKG files) will similarly contain return period damages and expected annual damages. For the impacts on the roads (GPKG file), the output will contain the inundation depth on the roads for the different return periods.\n\n\n\nOutput folder structure for an event scenario\nFor an event scenario, the ‚ÄúFlooding‚Äù folder will contain a flood depth map as a GeoTIFF file, a water level map as a NetCDF, and (if observation points have been set up for the site) the water level time series for each observation point at the site, as HTML files (see Figure¬†8).\n\n\n\n\n\n\nFigure¬†8: Folder structure of the ‚Äúoutput‚Äù folder for an event scenario\n\n\n\n\n\nOutput folder structure for a risk scenario\nFor a risk scenario, the ‚ÄúFlooding‚Äù folder will contain the return period water level maps as NetCDF files and the water depth maps as GeoTIFFs (see Figure¬†9).\n\n\n\n\n\n\nFigure¬†9: Folder structure of the ‚Äúoutput‚Äù folder for a risk scenario",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "4_user_guide/measures/hydraulic.html",
    "href": "4_user_guide/measures/hydraulic.html",
    "title": "Hydraulic (grey) measures",
    "section": "",
    "text": "Hydraulic (grey) measures aim to prevent floodwaters from reaching residents and infrastructure through construction of structures or pumps. More natural measures to prevent flooding are described in the section on urban green infrastructure. FloodAdapt can simulate two main types of hydraulic (grey) measures: floodwalls and levees and pumps. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a hydraulic measure, the user goes to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu selects ‚ÄúHydraulic‚Äù (see Figure¬†2). The user can then choose for ‚ÄúMeasure‚Äù one of the measure types: floodwall or levee, or pumps. For each of these measures, the user will choose an ‚ÄúArea type‚Äù. This indicates how the user will specify the location of the measure. There are two options:\nWhen specifying a hydraulic measure, it is useful to see the underlying hazard model grid which helps understand how the measure will be schematized in the model (hydraulic measures are always snapped to the hazard model grid). For this the user can click the ‚ÄúShow Grid‚Äù box. In addition, if you click the ‚ÄúShow Grid Snapper‚Äù box, FloodAdapt will show you how your polyline will be snapped to the hazard model grid. This is especially important when drawing a floodwall or leveel to make sure that the area you want to protect is well-represented once the polyline is snapped to the grid.",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/hydraulic.html#floodwalls-and-levees",
    "href": "4_user_guide/measures/hydraulic.html#floodwalls-and-levees",
    "title": "Hydraulic (grey) measures",
    "section": "Floodwalls and levees",
    "text": "Floodwalls and levees\nFloodwalls and levees are engineered structures designed to provide barriers against flood waters, thereby mitigating flood risks and protecting vulnerable areas from inundation. To implement floodwalls or levees in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúHydraulic‚Äù for the Category\nFrom the Measure drop-down menu, Select ‚ÄúFloowall‚Äù or ‚ÄúLevee‚Äù\nSelect one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù.\n\nIf you selected ‚ÄúDraw polyline‚Äù, you can now begin clicking within the map to draw a polyline where you want to implement your floodwall. When drawing the floodwall or levee, it is useful to turn on the ‚Äúshow grid‚Äù and ‚Äúgrid snapper‚Äù options so you are clear how your floodwall or levee will be implemented in the hydraulic model. We also recommend turning on the topography layer to ensure that your floodwall or levee ties into high ground, so that water does not flow around the edges of your floodwall or levee. Figure¬†3 shows an example of a polyline representing a floodwall without the grid, grid snapper, and topography visible. Figure¬†4 shows the same measure with these features enabled. You can see in Figure¬†4 how the wall will be implemented in the hydraulic model, and that the edges of the wall are tied into high ground.\n\n\n\n\n\n\nFigure¬†3: Implementing a floodwall in FloodAdapt by drawing a polyline\n\n\n\n\n\n\n\n\n\nFigure¬†4: Using the ‚Äúshow grid‚Äù, ‚Äúgrid snapper‚Äù and topography layers to better specify your floodwall or levee\n\n\n\n\n\n\n\n\n\nTurning on the topography layer\n\n\n\nTo turn on the topography layer, go to the top menu bar in FloodAdapt, click the ‚ÄúView‚Äù menu, and then from the drop-down menu click ‚ÄúTopography‚Äù. The topography layer will turn on. To turn the layer back off, again go to ‚ÄúView‚Äù, and again click ‚ÄúTopography‚Äù and the layer will disappear.\n\n\nOnce you have drawn your polyline or selected to import a polyline, a specification window opens (see Figure¬†5 for the example of a floodwall). In the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, and the elevation of the floodwall or levee. Once you enter the information and click ‚ÄúOK‚Äù, your floodwall or levee will show up in the measures window.\n\n\n\n\n\n\nFigure¬†5: Specifying information for a floodwall or levee\n\n\n\n\nEditing a floodwall or levee\nOnce you have created a floodwall or levee, you can edit it as long as you have not yet included it in a strategy. You can edit either the geometry or the parameters (the elevation) of the floodwall or levee.\nHere are the steps to edit the geometry of a floodwall or levee:\n\nSelect the measure in the ‚ÄúMeasures‚Äù tab\nClick ‚ÄúEdit measure‚Äù\nA pop-up window appears asking if you want to edit the geometry or parameters; select ‚ÄúGeometry‚Äù\nThe polyline is now ‚Äòclickable‚Äô\nClick the orange dots to reshape the polyline. If you have the grid snapper shown, the snapped floodwall or levee will automatically update as you edit the polyline (see Figure¬†6)\nWhen you are finished editing the polyline, click anywhere else on the map\nA pop-up window asks you if you would like to keep the new geometry; click yes\nThe geometry is now updated\n\n\n\n\n\n\n\nFigure¬†6: Editing a floodwall or levee\n\n\n\nHere are the steps to edit the parameters of a floodwall or levee:\n\nSelect the measure in the ‚ÄúMeasures‚Äù tab\nClick ‚ÄúEdit measure‚Äù\nA pop-up window appears asking if you want to edit the geometry or parameters; select ‚ÄúParameters‚Äù\nThe specification window opens\nYou may change the description or the elevation of the floodwall or levee\nWhen you are finished, click ‚ÄúOK‚Äù\nThe parameters are now updated",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/hydraulic.html#pumps",
    "href": "4_user_guide/measures/hydraulic.html#pumps",
    "title": "Hydraulic (grey) measures",
    "section": "Pumps",
    "text": "Pumps\nPumps remove water from low-lying areas or drainage systems to mitigate flooding. They are needed when gravity alone cannot allow for floodwaters to escape, or in combination with floodwalls which - without the inclusion of pumps - can trap rainwater within the area shielded by the floodwall. To implement floodwalls or levees in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúHydraulic‚Äù for the Category\nFrom the Measure drop-down menu, Select ‚Äúpump‚Äù\nSelect one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù.\n\nIf you selected ‚ÄúDraw polyline‚Äù, you can now click on the map. While FloodAdapt allows you to click multiple points in your polyline, the only points that will be retained for a pump are the first and last point. The first point will be treated as the ‚Äòintake‚Äô location (where the water will enter the pump) and the last point will be treated as the ‚Äòouttake‚Äô location (where the water will be pumped to). When drawing pump intake/outtake points, it is useful to turn on the ‚Äúshow grid‚Äù option so you are sure your intake and outtake points do not fall within the same model grid cell. When you have finished clicking your intake/outtake points, double-click on the last point to open the specification window.\nIn the specification window, you enter a name for the measure (no spaces or special characters), an optional description, and the pump capacity. When you have finished you click ‚ÄúOK‚Äù and the pump will be added and visible from the Measures tab.\n\n\n\n\n\n\nHow are pumps represented in the modeling?\n\n\n\nA pump in FloodAdapt is represented as a discharge between the intake and outtake points, using the discharge rate specified by the user when creating the measure. The discharge within the intake cell influences surrounding cells, causing water from these cells to drain into the intake cell as it is being discharged. However, this setup does not represent a pump connected to drainage infrastructure, and the effects of the pump are fairly localized to the intake location.",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/buildings.html",
    "href": "4_user_guide/measures/buildings.html",
    "title": "Building-level measures",
    "section": "",
    "text": "FloodAdapt can simulate different types of building-level adaptation actions: elevate, buyout, and floodproof properties. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a building-level measure, the user goes to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu selects ‚ÄúBuildings‚Äù (see Figure¬†2). The user can then choose for ‚ÄúMeasure‚Äù one of the three measure types: elevate, buyout, or floodproof properties. For each of these measures, the user will choose an ‚ÄúArea type‚Äù. This indicates how the user will select the buildings to which they want to apply the measure. There are three options:\nWhen selecting buildings using the ‚ÄúDraw polygon‚Äù feature, it is useful to click on the ‚ÄúShow Buildings‚Äù button in the Measures tab (see example in Figure¬†2). This shows the buildings that are in the exposure data of the impact model within FloodAdapt.\nEach of the building-level measures allows users to specify a property type to which the measure should be applied. So, for example, if a user selects a neighborhood, but only wants to apply the measure to the residential properties within the neighborhood, they are able to specify this. The property type is linked to an attribute in the impact model called the ‚Äòprimary object type‚Äô. In the U.S, these are typically residential (RES) commercial (COM), industrial (IND), or public (PUB). You can also choose to apply the measure to all the buildings in the selected area.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/buildings.html#elevate",
    "href": "4_user_guide/measures/buildings.html#elevate",
    "title": "Building-level measures",
    "section": "Elevate",
    "text": "Elevate\nElevating properties refers to raising structures to make them less susceptible to floodwaters. To implement elevating buildings in FloodAdapt, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúElevate properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure (see example in Figure¬†3). When you are finished clicking the polygon, right click or double click to open the measure specification window (see Figure¬†7).\n\n\n\n\n\n\nFigure¬†3: Selecting buildings for applying the elevate measure\n\n\n\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the elevation in feet, a specification what this elevation is relative to (see info box below for more details), and the property type that the measure should be applied to. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab. Note that if the user selects the ‚ÄúAggregation area‚Äù option for selecting buildings, the specification window will automatically open and they will additionally be asked to choose an aggregation area (see Figure¬†5 for the example of buyouts)\n\n\n\n\n\n\nFigure¬†4: Specifying information for an elevate measure\n\n\n\n\n\n\n\n\n\nElevate properties relative to‚Ä¶\n\n\n\nThe elevate properties specification window asks the user to specify what the elevation of the property is relative to. The user can select the datum; in this case, the elevation is the elevation of the finished floor of the property above the specific datum. The user can also select to elevate properties relative to ‚ÄúBase Flood Elevation‚Äù (BFE). In this case the elevation is actually a height above this reference. In the U.S, BFE is a regulatory flood level that is related to insurance, and is often used in ordinances on how high new development must be built. In areas of the world where this is not used, the base flood elevation option may not be visible.\n\n\n\n\n\n\n\n\nHow is elevating properties represented in the modeling?\n\n\n\nThe exposed assets have multiple attributes, one of which is the height of the finished floor above the ground. When a user elevates properties, FloodAdapt adjusts this attribute for the selected properties to represent the user specifications. Whether a user specifies a property elevation as an elevation relative to a datum, or a height above a reference level like base flood elevation, FloodAdapt calculates for each selected property the equivalent height above the ground, and assigns this value to the finished floor height attribute of the elevated property. For example, if a user selects 12 feet above datum, and the ground elevation where a property is located is 10 feet above datum, FloodAdapt calculates that the finished floor height of the property as 2 feet, and assigns this as the finished floor height attribute of the elevated property. Similarly, if a user selects 2 feet above BFE, and the BFE at the location of a property is 9 feet, then the property must be raised to 11 feet relative to datum. If the ground elevation at that location is 8 feet, FloodAdapt would calculate that the finished floor height for the elevated property is 3 feet.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/buildings.html#buyout",
    "href": "4_user_guide/measures/buildings.html#buyout",
    "title": "Building-level measures",
    "section": "Buyout",
    "text": "Buyout\nBuyouts refer to the purchase and subsequent removal of a property, usually one that is high risk or has experienced repetitive flooding. To implement the buyout measure, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúBuyout properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù for the Area type, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure. When you are finished clicking the polygon, right click or double click to open the measure specification window. If you select ‚ÄúAggregation area‚Äù the specification window will automatically open when you click ‚ÄúAdd measure‚Äù and you will additionally choose an aggregation area to apply the measure (see Figure¬†5).\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the property type that the measure should be applied to, and - if you selected ‚ÄúAggregation area‚Äù - the aggregation area where the measure should be applied. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab.\n\n\n\n\n\n\nFigure¬†5: Specifying information for a buyout measure\n\n\n\n\n\n\n\n\n\nHow are buyouts represented in the modeling?\n\n\n\nWhen a property has been bought out and removed, it is no longer an exposed asset in the project area. However, the implementation in FloodAdapt does not actually remove the properties from the exposure data; instead, the selected properties are assigned a maximum potential damage value of zero. The damage is calculated as the damage fraction (based on the inundation depth) multiplied by the maximum potential damage. Because the maximum potential damage is set to zero, the bought out properties will result in damages of zero, regardless of the inundation depth. In this way, it represents the situation that the property has been removed.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/buildings.html#floodproof",
    "href": "4_user_guide/measures/buildings.html#floodproof",
    "title": "Building-level measures",
    "section": "Floodproof",
    "text": "Floodproof\nFloodproofing in FloodAdapt refers to dry floodproofing, which involves sealing a building‚Äôs exterior, typically through barriers or seals, to prevent floodwaters from entering and causing damage. The effect of floodproofing is that the building will not incur any damages until floodwaters exceed the height of the floodproofing seals.\nTo implement floodproofing to buildings in FloodAdapt, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúFloodproof properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure (see example in Figure¬†6). When you are finished clicking the polygon, right click or double click to open the measure specification window (see Figure¬†7).\n\n\n\n\n\n\nFigure¬†6: Selecting buildings for applying the floodproofing measure\n\n\n\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the height of the floodproofing, and the property type that the measure should be applied to. The floodproofing height ensures that damages only occur when the inundation depth is greater than the floodproofing height. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab. Note that if the user selects the ‚ÄúAggregation area‚Äù option for selecting buildings, the specification window will automatically open when they click ‚ÄúAdd measure‚Äù and they will additionally be asked to choose an aggregation area (see Figure¬†5 for the example of buyouts)\n\n\n\n\n\n\nFigure¬†7: Specifying information for a floodproofing measure\n\n\n\n\n\n\n\n\n\nHow is floodproofing represented in the modeling?\n\n\n\nThe impact model uses depth-damage curves that relate inundation depths to fractions of total asset damage. When a user selects a floodproofing height, there will be no damage to the property until the inundation depths exceed that height. This is represented by modifying the depth-damage curve so that the damage fraction is zero below the floodproofing height. Above the floodproofing height, the damage curve is unchanged because once the inundation exceeds the floodproofing height, it is assumed the water will then enter the property and reach the levels it would have reached without the floodproofing barrier.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "4_user_guide/getting_started.html",
    "href": "4_user_guide/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This section covers system requirements for running FloodAdapt, initial installation steps, opening FloodAdapt, and the FloodAdapt database folder structure.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "4_user_guide/getting_started.html#system-requirements",
    "href": "4_user_guide/getting_started.html#system-requirements",
    "title": "Getting Started",
    "section": "System requirements",
    "text": "System requirements\nIn order to run FloodAdapt, the following are required:\n\nYour computer must be running a Windows operating system.\nThe first time the FloodAdapt application is opened must be by a user with administrative rights\nThe computer must have access to the internet\nAt least 2 GB of storage for the FloodAdapt system files and the underlying database\nApproximately 150 MB of storage for each user-generated scenario\n\n\n\n\n\n\n\nWhich windows systems have been tested?\n\n\n\nFloodAdapt has been tested on Windows 10 and 11. It is expected to work on older systems, but has not been tested.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "4_user_guide/getting_started.html#installation-steps",
    "href": "4_user_guide/getting_started.html#installation-steps",
    "title": "Getting Started",
    "section": "Installation steps",
    "text": "Installation steps\nTo download and install FloodAdapt on your computer:\n\nDownload the FloodAdapt installer from the Deltares USA website.\nDouble-click the ‚ÄúFloodAdaptInstaller‚Äù file and the setup wizard will open (see Figure¬†1). Follow the steps of the installation wizard.\n\n\n\n\n\n\n\nFigure¬†1: FloodAdapt installation setup wizard",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "4_user_guide/getting_started.html#opening-floodadapt",
    "href": "4_user_guide/getting_started.html#opening-floodadapt",
    "title": "Getting Started",
    "section": "Opening FloodAdapt",
    "text": "Opening FloodAdapt\nWhen you open the FloodAdapt application you will be prompted to select a database root folder. This is the location where you store one or more FloodAdapt databases. Once you select a root folder, the databases within the root folder will appear. Select the database you want to work with and click ‚ÄúStart‚Äù to open the FloodAdapt application. Each time you open FloodAdapt you have the opportunity to change the database root and/or select a different database.\n\n\n\n\n\n\nFigure¬†2: Database selector when opening FloodAdapt\n\n\n\n\n\n\n\n\n\nWhy do I have to select a database?\n\n\n\nThe FloodAdapt application is a calculation ‚Äúshell‚Äù that requires a FloodAdapt database to work. Details on setting up a FloodAdapt database in a new location are provided in the Setup Guide.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "4_user_guide/getting_started.html#floodadapt-database",
    "href": "4_user_guide/getting_started.html#floodadapt-database",
    "title": "Getting Started",
    "section": "FloodAdapt database",
    "text": "FloodAdapt database\nThe FloodAdapt database uses a normal folder structure so that it is easily accessible by users, without requiring database knowledge. Figure¬†3 shows the overall folder structure. The ‚ÄúDatabase Root Folder‚Äù is folder where you can store one ore more FloodAdapt site databases. Within each site database, there are three folders: Input, Output, and Static. The input and output folders are populated when you use the FloodAdapt application. The input folder contains information about scenario components: events, projections, measures, strategies and scenarios. The output folder contains the flooding and impact output from simulated scenarios, and is described in more detail in the Output section. The Static folder contains information that is prepared when setting up FloodAdapt for a particular site location (see the Setup Guide).\n\n\n\n\n\n\nFigure¬†3: FloodAdapt database folder structure",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "4_user_guide/events/probabilistic_events.html",
    "href": "4_user_guide/events/probabilistic_events.html",
    "title": "Probabilistic event set",
    "section": "",
    "text": "A probabilistic event set is the combination of a set of synthetic events and their occurrence probabilities. These can be both tropical storms (hurricanes), as well as non-tropical events. They should include all event types that can lead to flooding in the site area (now or in the future), and can be compound flood events, meaning a combination of different flood drivers, like water level, rainfall, river discharge, or wind. It can be complicated to set up this set of events, and is therefore recommended to be done by an expert during the set-up of FloodAdapt for the site location (see guidance on setting up an event set in the Setup Guide)\nIn the events tab in FloodAdapt, a probabilistic event set can be recognized by the Type specification at the bottom of the window (see Figure¬†1). These event sets cannot be modified or deleted via the user interface.\n\n\n\n\n\n\nFigure¬†1: Probabilistic event set in the Events window. The Type is specified as Probabilistic Event Set and cannot be modified\n\n\n\n\n\n\n\n\n\nHow are probabilistic event sets used in FloodAdapt?\n\n\n\nWhen a user selects a scenario with a probabilistic event set, FloodAdapt calculates the flooding for each of the events in the event set. Using the flood output for the events and information about the frequencies of the events (also provided as part of the event set), FloodAdapt calculates return period flood maps (such as the 100 year flood map), return period damages, and expected annual damages (risk) for the scenario. Details of how FloodAdapt makes these calculations is presented in the Technical Documentation.\nFor an example how to use a probabilistic event set in a scenario, let‚Äôs say a user wants to explore the risk to their community with 1 foot of sea level rise and with a floodwall in place. Their scenario components would be: projection = 1 ft. sea level rise, strategy = floodwall, event = probabilistic event set. The calculation of risk allows a user to explore the risk-reduction benefits of adaptation options, as well as obtaining more comprehensive insight into how risk is distributed. The page on scenarios gives more examples how users can define scenarios to answer different questions.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Events",
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/index.html",
    "href": "4_user_guide/events/historic_events/index.html",
    "title": "Historical Events",
    "section": "",
    "text": "There are three types of historical events a user can select. Click on one of the links below or navigate via the side bar to learn more about each of these event types.",
    "crumbs": [
      "Events",
      "Historical Events"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/index.html#which-historical-event-type-should-i-choose",
    "href": "4_user_guide/events/historic_events/index.html#which-historical-event-type-should-i-choose",
    "title": "Historical Events",
    "section": "Which historical event type should I choose?",
    "text": "Which historical event type should I choose?\nAre you interested in a hurricane that made landfall at or near the site? Then choose Historical hurricane.\nAre you interested in a historical event that wasn‚Äôt a hurricane, like a king tide or a heavy rainfall event? If your site has a water level gauge, we recommend using the ‚ÄúHistorical event with gauged water levels‚Äù option. The only time the ‚ÄúHistorical event without gauged water levels‚Äù option is recommended is when there is no gauge at the site. Figure¬†1 shows a flow chart for deciding which event type to choose.\n\n\n\n\n\n\nFigure¬†1: Flow chart: which event type should I choose?",
    "crumbs": [
      "Events",
      "Historical Events"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_hurricane.html",
    "href": "4_user_guide/events/historic_events/historic_events_hurricane.html",
    "title": "Historical Hurricanes",
    "section": "",
    "text": "Watch a video about entering a historical hurricane\n\n\n\nDon‚Äôt feel like reading? No problem! Check out our video about how to add a hurricane in FloodAdapt, and also how to shift the hurricane to see how different the flooding and impacts would have been had the hurricane made landfall somewhere else. \n\n\nThe historical hurricane event allows the user to select and shift a historical hurricane from a hurricane track database. When the user selects the ‚ÄúHistorical hurricane‚Äù option from the Events tab, they will see a hurricane selection window appear (see Figure¬†1), which is populated with historical hurricanes from the National Hurricane Center (NHC) HURDAT2 database. This database is updated by the NHC annually and will require an annual maintenance update to keep the hurricane database in FloodAdapt up to date. The user can see all hurricanes within a specified distance of the site, or between specified years.\n\n\n\n\n\n\nHurricanes far offshore\n\n\n\nIt is not recommended to use the Historical hurricane option for a hurricane that passed far offshore of the site. In those cases, it is recommended to use the ‚ÄúHistorical event without gauged water levels‚Äù event type.\n\n\n\n\n\n\n\n\nFigure¬†1: Hurricane selector window. You can search by name, and can filter the selection by distance to the site or time window\n\n\n\nThe historical hurricane event template window is shown in Figure¬†2. After a user selects a hurricane from the hurricane selector window, the event name and description of the hurricane and the timing will be automatically filled in. The user can edit these if desired.\n\n\n\n\n\n\nEditing the hurricane start and stop time\n\n\n\nThe automatically filled-in start and stop time represent the entire duration of the hurricane track. This event duration can be shortened to speed up the calculation. How should you pick the duration? Hover your mouse over the track icons to see date and time stamps. Choose dates from 1-2 days before landfall to 1 day after landfall.\n\n\nUnder the ‚ÄúSurge and Tide‚Äù block, the user can shift the hurricane track by specifying the miles of horizontal or vertical shift. The shifted hurricane will be displayed beside the original track. Note that when shifting a historical hurricane track, the new track will be assigned the attributes of the original hurricane (like wind and pressure fields).\nThe wind and rain are automatically derived from information about the hurricane track. The rainfall is derived from the track using the IPET method. The user does not need to specify any information here.\nThe river discharge represents the discharge at the model boundary and will be automatically filled to a default value specified during system set-up. The user can modify this value. If there are multiple rivers at the model boundary, the user will be able to select each river to view or modify the discharge.\n\n\n\n\n\n\nFigure¬†2: Event template window for a historical hurricane.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical Hurricanes"
    ]
  },
  {
    "objectID": "4_user_guide/events/general_info.html",
    "href": "4_user_guide/events/general_info.html",
    "title": "General event information",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/compare/Compare_table.html",
    "href": "4_user_guide/compare/Compare_table.html",
    "title": "Scenario comparison - metrics",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/benefits.html",
    "href": "4_user_guide/benefits.html",
    "title": "Benefits",
    "section": "",
    "text": "Flood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits.\nWhen you first go to the Benefits tab in FloodAdapt (see Figure¬†1) you will see an empty list box in the lower panel. Once you create benefit analyses these will appear in the list. To the right of the list box there are buttons to add, edit, or delete a benefit analysis. Before creating your first benefit analysis, only the ‚ÄòAdd benefit analysis‚Äô button is active.\nThe following sections will describe how to create a benefit analysis, how benefits are calculated, how to view benefit analysis output in the Benefits tab, and where you can find output on your computer for more detailed investigation.",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "4_user_guide/benefits.html#creating-a-new-benefit-analysis",
    "href": "4_user_guide/benefits.html#creating-a-new-benefit-analysis",
    "title": "Benefits",
    "section": "Creating a new benefit analysis",
    "text": "Creating a new benefit analysis\nFloodAdapt users can evaluate the risk-reduction benefits of any strategy they have created (which can be composed of a single measure or a collection of measures). To do this, go to the Benefits tab in FloodAdapt, and in the bottom panel click on ‚ÄúAdd benefit analysis‚Äù. A popup window will appear within which you will specify important choices about your benefit analysis.\n\n\n\n\n\n\nFigure¬†2: Benefit analysis popup window\n\n\n\nFor the following description please refer to Figure¬†2. To create a new benefit analysis:\n\nAnalysis name: Enter a name for your analysis. This cannot have any spaces or special characters (underscores are ok). Choose a name that will help you identify your analysis easily in the benefits tab; for example ‚Äúbenefits_floodwall‚Äù. You can optionally also add a description.\nStrategy to evaluate: In the ‚ÄúStrategy to evaluate‚Äù panel, select the strategy for which you want to calculate benefits. The baseline strategy is selected for you and consists of the ‚Äòno-measures‚Äô strategy.\nSituation at implementation: The implementation situation consists of the ‚Äòcurrent‚Äô projection representing current climate and socio-economic conditions (pre-selected). The implementation year can be adjusted but by default is set to the ‚Äòcurrent‚Äô year defined during system setup.\nSituation at end of analysis: In the end-of-analysis situation, specify the year that corresponds to the duration over which you want to calculate benefits. In Figure¬†2, the year 2060 is specified. That means benefits will be calculated between the current year up to and including 2060. From the ‚ÄúProjection‚Äù dropdown menu, select the climate and/or socio-economic conditions you expect at this end-of-analysis year. For example, if you expect sea level rise to be 1 foot at the year specified (e.g.¬†2060 in Figure¬†2), then choose a projection with 1 foot of SLR. Note that you must have already created such a projection in order to select it here. The projection dropdown menu will contain all projections that have been created in the Projections tab.\nCosts: If you have information on the implementation and maintenance costs of your project, you can set ‚ÄúAdd costs‚Äù to ‚ÄúYes‚Äù and a ‚ÄúCosts‚Äù panel will appear. Here you can enter the costs. If you do not have this information, set ‚ÄúAdd costs‚Äù to ‚ÄúNo‚Äù and the ‚ÄúCosts‚Äù panel will disappear. When cost information is not available, FloodAdapt will only calculate the risk-reduction benefits. When cost information is available, it will additionally calculate the benefit-cost ratio, net present value, and internal rate of return. These latter two are saved on your computer but not presented in the Benefits tab.\nDiscount rate: Enter a discount rate. A discount rate is used in benefit-cost analysis to discount future benefits and costs. It reflects the idea that benefits and costs are worth more if they are experienced sooner. When discount rates are higher, the overall present value of benefits will be lower than when the discount rate is lower. Users are free to explore different discount rates and the effect these have on the present value of benefits and the benefit-cost ratio.\nCheck scenarios: Once you have entered the above information, click the ‚ÄúCheck scenarios‚Äù button. FloodAdapt helps you to determine which scenarios need to be run in order to carry out the benefit analysis you specified. The risk-reduction benefit analysis requires risk calculations with and without the selected strategy under current conditions and with and without the strategy under the projection selected for the end of the analysis situation. When you click ‚ÄúCheck scenarios‚Äù, the scenarios that need to be run will be shown in the table in the popup window (see Figure¬†3). The column ‚Äúscenario created‚Äù will list the scenario name if the scenario has already been created and will say ‚ÄúNo‚Äù if the scenario has not been created. The column ‚Äúscenario run‚Äù will indicate whether the scenario has already been run (True) or not (False).\nCreate missing scenarios: If any of the required scenarios is missing when you click ‚ÄúCheck scenarios‚Äù, you can click ‚ÄúCreate missing scenarios‚Äù and FloodAdapt will automatically create the missing scenarios and place them in the scenarios table in the Scenarios tab.\nClick ‚ÄúOK‚Äù to add the analysis to the Benefits tab\n\n\n\n\n\n\n\nFigure¬†3: The ‚ÄúCheck scenarios‚Äù feature in the Benefit analysis popup window\n\n\n\n\n\n\n\n\n\nRequired scenarios need to be run before running your benefit analysis\n\n\n\nThe ‚ÄúCheck scenarios‚Äù and ‚ÄúCreate missing scenarios‚Äù buttons guide users to ensure the required scenarios are created for the benefit analysis. However, scenarios can only be run from the Scenarios tab. If any of the four required scenarios have not been run, you need to go to the Scenarios tab and run them. If any of the required scenarios have not yet been run, the ‚ÄúCalculate benefits‚Äù button will be greyed out and you will see text beneath it informing you that ‚ÄúYou cannot calculate benefits before running the required scenarios (use Scenarios tab)‚Äù, see Figure¬†4.\n\n\n\n\n\n\nFigure¬†4: All required scenarios must first be simulated before running a benefit analysis",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "4_user_guide/benefits.html#calculating-benefits",
    "href": "4_user_guide/benefits.html#calculating-benefits",
    "title": "Benefits",
    "section": "Calculating benefits",
    "text": "Calculating benefits\nOnce the required scenarios have been simulated, the ‚ÄúCalculate benefits‚Äù button will be active, see Figure¬†5. When the button is clicked, the benefit calculation happens on-the-fly, but because the risk information is already calculated, the benefit calculation happens very quickly and the results appear instantly.\n\n\n\n\n\n\nFigure¬†5: When all scenarios have been run, ‚ÄúCalculate benefits‚Äù button is active\n\n\n\nThe benefit calculation uses output from four scenarios:\n\nThe risk without the strategy implemented in current conditions\nThe risk with the strategy implemented in current conditions\nThe risk without the strategy implemented in future conditions\nThe risk with the strategy implemented in future conditions\n\nWhen the ‚ÄúCalculate benefits‚Äù button is clicked, the following benefit calculations are carried out:\n\nThe risk-reduction benefit under current conditions is calculated as the difference in the risk without the strategy and with the strategy under the ‚Äúcurrent‚Äù projection (representing current conditions).\nThe risk-reduction benefit under future conditions (for the year specified in the end-of-analysis situation) is calculated as the difference in the risk without the strategy and with the strategy under the future projection specified in the end-of-analysis situation when you created your benefit analysis.\nThe annual risk-reduction benefits are calculated by linearly interpolating between the risk-reduction benefits under current conditions (in the current year) and the risk-reduction benefits under future conditions (in the end-of-analysis year).\nThe annual discounted benefits (\\(B_d(t)\\)) are calculated as\n\\(B_d\\ (t)=B(t)/(1+r)^t\\ \\)\nwhere \\(B(t)\\) is the risk-reduction benefit in year \\(t\\), \\(t\\) is the year since implementation, and \\(r\\) is the discount rate.\nThe (present value of the) benefits are calculated as the sum of the annual discounted benefits over the analysis duration (\\(N\\) years).\n\\(Benefits\\ =\\ \\sum_{t=0}^N B_d\\ (t)\\ \\)\n\nWhen cost information is provided, FloodAdapt additionally calculates:\n\nThe (present value of the) costs - calculated only when implementation and/or maintenance costs are provided in the benefit analysis input. This is calculated in the same way as the present value of the benefits: \\(Costs\\ =\\ \\sum_{t=0}^N C_d\\ (t)\\ \\)\nwhere \\(C_d(t)\\) is the discounted cost in year \\(t\\).\nThe benefit-cost ratio (BCR) is calculated as the present value of the benefits divided by the present value of the costs.\nThe net present value (NPV) is the difference in annual discounted benefits and costs, summed up over the analysis period.\n\\(NPV\\ =\\ \\sum_{t=0}^N [(B(t)-C(t))/(1+r)^t]\\ \\)\nThe internal rate of return (IRR) represents the discount rate at which the NPV would be equal to zero. Higher IRR indicates a better investment, because in this case the benefits weigh strongly against the costs.\n\nThe output from these calculation steps can be viewed in the Benefits output tab and can additionally be accessed on the user‚Äôs computer.\n\n\n\n\n\n\nSome metrics are only calculated when cost information is provided!\n\n\n\nThe present value of the costs, benefit cost ratio, net present value, and internal rate of return are only calculated if the user has provided information on implementation and/or maintenance costs when they created their benefit analysis. When this information is not provided, the benefits are calculated, but none of the metrics that require comparison with costs.",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "4_user_guide/benefits.html#viewing-benefit-output-in-the-benefits-tab",
    "href": "4_user_guide/benefits.html#viewing-benefit-output-in-the-benefits-tab",
    "title": "Benefits",
    "section": "Viewing benefit output in the Benefits tab",
    "text": "Viewing benefit output in the Benefits tab\nFigure¬†6 shows the Benefits tab in FloodAdapt once a benefit analysis has been completed. The window is separated into a top panel with a map window on the left and, when using the collapsible frame, a time series of benefits on the right. When a benefit analysis is selected in the list, the measures in the strategy for which benefits are being calculated will appear in the map window. The bottom panel will show a summary of the user-provided input to the benefit analysis, such as discount rate or end-year of the analysis. Once the user clicks the ‚ÄúCalculate benefits‚Äù button, output will appear in the panel. This output consists of the (present value of the) benefits and a benefit-cost ratio (if cost information was provided). The collapsible frame contains a graphic with the risk-reduction benefits calculated under current conditions and under future conditions (green dots in the figure), the interpolated benefits over time (black line), the discounted benefits over time (dark green line), and the area under the discounted benefits curve (green shading) representing the present value of the benefits.\n\n\n\n\n\n\nWhy don‚Äôt I see the NPV and IRR in the Benefits tab?\n\n\n\nIn addition to the above results which can be viewed in the Output tab, FloodAdapt also calculates - when implementation and/or maintenance cost information is provided - the net present value and the internal rate of return. These are provided in a results text file in the benefits output folder.\n\n\n\n\n\n\n\n\nFigure¬†6: The FloodAdapt Benefits tab showing a selected benefit analysis\n\n\n\nThe benefits can also be viewed spatially; the lower panel contains map visualization options (see Figure¬†6). The user can click ‚ÄúAggregated benefits‚Äù to see the spatial distribution of benefits (see Figure¬†7 for an example). They can choose from the ‚ÄúAggregation‚Äù drop-down menu which aggregation level they would like to view, for example neighborhoods or census blocks.\n\n\n\n\n\n\nFigure¬†7: Visualizing the benefits spatially\n\n\n\nIn the map visualization options, there is also an equity-weighted button. When this is checked the distributed (aggregated) benefits are displayed using equity weights, see Figure¬†8. The figure shows the benefits without equity weights on the left and with equity weights on the right. In the figure, blue stars have been added (outside of FloodAdapt) to highlight how the equity weighting affects lower-income census-block groups. When equity weights are applied, the benefits of these lower-income areas will be weighted more heavily; in contrast, high-income area benefits will be weighted less heavily. Equity weights are calculated in FloodAdapt using information on income. Risk estimates are multiplied by the equity weights to derive equity-weighted risk estimates, from which equity-weighted benefits are calculated. This visualization is only available at the same scale for which income data is available. This will typically be census block level.\n\n\n\n\n\n\nFigure¬†8: Visualizing equity-weighted benefits. The blue stars indicate lower-income census block groups. Their benefits are more weighted more heavily when equity-weights are applied (right side versus left side)",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "4_user_guide/benefits.html#benefits-output-folder",
    "href": "4_user_guide/benefits.html#benefits-output-folder",
    "title": "Benefits",
    "section": "Benefits output folder",
    "text": "Benefits output folder\nThe output from a benefit analysis is saved on a user‚Äôs computer, aspiring to provide full access and transparency. This section will describe the output files saved from the benefit analysis.\n\n\n\n\n\n\nWhere can I find the output folder?\n\n\n\nFigure¬†9 shows where the output folder is located within the FloodAdapt database. The database root directory could contain multiple site databases, for different locations, or even variations of databases for the same location. The output folder is located directly inside the site database folder.\n\n\n\n\n\n\nFigure¬†9: Location of the ‚Äúoutput‚Äù folder within the FloodAdapt folder structure\n\n\n\n\n\nThe output folder contains a subfolder named ‚ÄúBenefits‚Äù. Within this subfolder you will find one folder for each benefit analysis that has been run. The name of the folder will be the name of the benefit analysis. Each folder will contain several files (see Figure¬†10):\n\nBenefits graphic (HTML file) that contains the same graphic displayed in the collapsible frame in the Benefits tab.\nBenefits per aggregation area, one CSV file for each aggregation scale defined for the site (e.g.¬†neighborhoods or census block groups). For the aggregation scale for which income data is available (usually census block group), the CSV file will contain a column on benefits and one on equity-weighted benefits.\nSpatial benefits as geopackage (GPKG) files, one file for each aggregation scale defined for the site.\nSummary results of the benefit analysis as a text file (TOML file). This file always contains the total benefits (present value). If cost information was provided when setting up the benefit analysis, this file will also contain costs (present value), net present value (NPV), the benefit cost ratio (BCR), and the internal rate of return (IRR).\nA time series of annual risk with and without the strategy implemented, annual costs and benefits (absolute and discounted), and annual profit as the difference between benefits and costs (absolute and discounted).\n\n\n\n\n\n\n\nFigure¬†10: Benefits output folder",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html",
    "href": "3_setup_guide/risk_analysis.html",
    "title": "Event Set",
    "section": "",
    "text": "This guidance provides support for preparing an event set to be used in FloodAdapt to calculate probabilistic flood maps, impacts, and risk. An event set consists of a set of events, defined by variables like surge, tide, and rainfall, and their occurrence frequencies. To see how FloodAdapt uses an event set to calculate risk, take a look at the FloodAdapt technical documentation on risk analysis, particularly the part about the probabilistic calculator.\nThe method described in this guidance is known as the Joint Probability Method (JPM). In the JPM, all types of hydro-meteorological events that may lead to flooding in an area of interest are identified. Subsequently, a representative set of (synthetic) events is selected, covering as much as possible the whole range of events that may contribute substantially to the overall flood risk. The likelihood of occurrence of each event is estimated from key statistics of the relevant flood drivers like rainfall, river discharge, and sea level.\nNote that this guide focuses on non-hurricane events. For the derivation of a hurricane event set, which can be combined with a set of non-hurricane events, please see the comprehensive FEMA guide from 2023.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#steps-to-prepare-an-event-set",
    "href": "3_setup_guide/risk_analysis.html#steps-to-prepare-an-event-set",
    "title": "Event Set",
    "section": "Steps to prepare an event set",
    "text": "Steps to prepare an event set\nThis guide is organized around key steps in preparing an event set.\n\nIdentify flood drivers and define variables\nDetermine the flood drivers that have a significant impact on the flood risk in the area (e.g.¬†rainfall, river discharge, sea levels), and select appropriate variables that best represent the characteristics of the identified flood drivers.\nCalculate probabilities of variables\nCalculate the probability distribution of the flood driver variables.\nCalculate joint probabilities\nCalculate correlation between variables and the joint probability of occurrence of the flood driver variables.\nSelect events and calculate their frequencies\nSelect a set of events (defined as a combination of flood driver variables) and quantify their occurrence frequencies.\nFormat the events for FloodAdapt\nPrepare the set of events (event specs and frequencies) in the format required for FloodAdapt.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#identify-relevant-define-variables",
    "href": "3_setup_guide/risk_analysis.html#identify-relevant-define-variables",
    "title": "Event Set",
    "section": "Step 1 - Identify flood drivers and define variables",
    "text": "Step 1 - Identify flood drivers and define variables\nThe initial step in setting up a probabilistic flood risk assessment involves identifying the most relevant flood drivers in the project area. In coastal zones, floods may be caused by (combinations of) intense rainfall (pluvial flooding), high river discharges (fluvial flooding), groundwater tables rising above the ground surface (groundwater flooding), and high tides, storm surges, and waves (coastal flooding). In a probabilistic analysis, these flood drivers are represented by variables that quantify a specific characteristic of the flood driver, such as daily rainfall or peak storm surge. These variables are sometimes referred to as ‚Äústochastic variables‚Äù or ‚Äúrandom variables,‚Äù acknowledging the fact that they can take on a range of values that have probabilities of occurrence/exceedance associated with them.\nThe choice of the most suitable variable to represent a flood driver depends on the system under consideration. For example, for an assessment of a storm sewage system, a suitable variable may be the 15-minute or 1-hour rainfall, whereas for larger catchments the daily rainfall or multi-day rainfall is more relevant. For the design of river embankments, the peak discharge is a suitable choice, whereas for the design of a reservoir the total volume of flow during the entire flood event is also relevant. In some cases, it may be worth considering representing a flood driver with multiple variables. For example, river discharge can be represented by a combination of peak flow and flow volume.\nLimiting the number of variables in a probabilistic flood risk assessment is crucial due to the exponential increase in the required model simulations, which can impact practical feasibility and computational resources. Consider a scenario where only two variables‚Äîrainfall and storm surge‚Äîare selected, each with five possible realizations. This setup yields 25 possible combinations (5√ó5), necessitating 25 model runs to assess flood conditions and impacts. This number of simulations is generally manageable. However, increasing the variables to four, each with five realizations, results in 625 possible combinations (5√ó5√ó5√ó5), significantly increasing the simulation time. If the number of variables increases to six, this leads to a staggering 15,625 combinations (5^6), which may not all need simulation but illustrate the potential scale of the assessment.\nWhile a comprehensive analysis ideally covers all relevant flood events, practical constraints often necessitate a balance. The choice of the number of model simulations is a trade-off between accuracy and simulation time. It is important to understand the relationship between the flood drivers and flood response, which may come from existing knowledge of the area or from exploratory simulations with a Hydrologic/Hydraulic (H&H) model. Conducting a sensitivity analysis with the H&H model for each candidate variable allows quantification of the sensitivity of the flood hazard and impact. Variables for which this sensitivity is relatively small can be replaced by a constant value, reducing the complexity of the analysis and computation times. For example, while the peak river discharge is a critical variable if a project area is along a river, in coastal areas where water levels are dominated by the sea, a constant river discharge might suffice, verified through sensitivity analysis to assess its impact. This demonstrates the essential balance between accuracy and practicality in setting up probabilistic flood risk assessments, aiming to include as many variables as necessary but as few as possible to maintain manageability and effectiveness, particularly if scenarios need to be re-evaluated frequently due to changing climate conditions or socio-economic factors.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#quantify-probs",
    "href": "3_setup_guide/risk_analysis.html#quantify-probs",
    "title": "Event Set",
    "section": "Step 2 - Calculate probabilities of variables",
    "text": "Step 2 - Calculate probabilities of variables\nFlood events are described as a combination of realizations of the selected flood driver variables. For each event considered in the probabilistic analysis, the probability of occurrence is needed to be able to quantify the contribution of such an event to the overall risk. The event probabilities are derived from probabilities of the flood event variables. In some cases, probability distributions of variables are readily available. NOAA, for example, offers nation-wide statistics on rainfall (NOAA rainfall). In other instances, probabilities need to be derived either from gauge records or from expert judgement.This section focuses on deriving probabilities/statistics from gauge data.\nThe main steps in deriving (joint) probabilities of the flood variables are:\n\nData gathering and validation - this step involves collecting and ensuring the quality of time series of the variables for which we want to derive probability distributions\nCorrecting for non-stationarity - this step involves correcting for changes in the system or trends which would make distribution fitting techniques invalid\nExtreme value analysis- this step fits distributions to the extreme tails of the flood variable distributions\nCombining statistics of extreme events and average conditions - this step creates a distribution that is correct for both average values of the variables and extreme values\n\n\nData Gathering and Validation\nData gathering is a critical step in flood risk assessment. Important considerations include the record length, temporal resolution, number of stations, and data validation processes. Long records are preferable as they provide more comprehensive information on ‚Äúextremes,‚Äù which are crucial for analyzing flood risks.\n\nRecord Length: Longer records are more valuable because they include more rare events, which are important for understanding the full range of possible scenarios. They also allow for more robust statistical analyses.\nTemporal Resolution: The temporal resolution of the data should align with the scale of the hydrological processes being modeled. For urban drainage studies, minute-by-minute data may be necessary, whereas for river basin studies, daily values may suffice.\nNumber of Stations: Gathering data from multiple stations is generally preferred over using data from only one station. This provides valuable information on spatial variability. Furthermore, comparing data between nearby stations is an excellent way to validate data.\nData Validation: It is critical to validate the data to ensure its accuracy and reliability. This involves checking for anomalies or errors, such as outliers that might indicate data recording errors, especially for extreme values.\n\n\n\nDealing with Non-Stationarities\nSometimes, data is collected from a period when the system under consideration was significantly different from the current situation. As a result, the recorded time series may be non-stationary, meaning that probabilities of occurrence/exceedance can change over time. Various factors could cause changes in the system over the years, including climate change, sea level rise, urbanization, morphological changes, and human interventions like reservoirs. In such cases, caution is needed when using this data, as it could lead to over- or underestimation of current flood risk. One option is to discard earlier data, but this removes potentially useful information and may leave too little data to derive reliable statistics. Alternatively, ‚Äòcorrections‚Äô can be applied to make the data set (approximately) stationary again. The aim of these corrections is to estimate what the observed time series would have looked like if the system conditions had been the same as they are today.\nFor coastal systems, corrections for sea level rise are almost always necessary. Due to sea level rise, the exceedance probabilities of sea water levels increase over time, making early observations non-representative of current conditions. A simple correction is to add the amount of observed sea level rise since year Y to all observations from that year. For instance, if sea levels have risen by 0.5 ft since 1990, all water levels observed in 1990 should be increased by 0.5 ft to reflect current conditions. This adjustment requires an understanding of the extent of sea level rise, which is complicated by year-to-year fluctuations that can obscure the long-term trend. To address this, a trend line might be fitted through the data, although this process can be somewhat subjective.\n\n\n\n\n\n\nFigure¬†1: Observed annual mean sea levels, linear trend line from NOAA and fitted LOWESS trendline\n\n\n\nFigure¬†1 illustrates annual average observed sea water levels from 1996-2020 in Charleston, SC (blue dots), with the black line representing a linear trend line as derived by NOAA (NOAA SWL trend), and the red line showing a non-linear trend line using the LOWESS method (Cleveland, 1979). The estimated average sea level in 2020 differs by approximately 0.3 feet between the two methods, indicating that the choice of method can significantly influence the estimated flood risk. The linear fit does not account for the notable increase in sea water levels observed since 2014, suggesting the LOWESS fit might be more appropriate. However, this increase could be an anomaly; a similar sharp rise occurred in the 1940s, but by the late 1950s, the data returned to align with the linear trend. This variability demonstrates that past sea level rise is uncertain, and it may be prudent to consider both trend lines when assessing potential impacts on flood risk.\nIn cases like these (sea level rise, implementation of a reservoir) the recorded time series are clearly non-stationary and the cause of the non-stationarity is known. In other situations, there may be an observed trend for which it is unclear if this is due to a change in the system or if it is merely a coincidence. In that case, statistical tests can be applied to assess the likelihood of the trend being just a coincidence. IExamples of such tests are the Mann-Kendall test (Mann, 1945; Kendall, 1975) and the Wilcoxon-Mann-Whitney test (Wilcoxon, 1945; Mann and Whitney, 1947).\n\n\nExtreme Value Analysis\nExtreme value analysis is used to derive statistics of the ‚Äúextremes‚Äù in a record, based on limited information. For floods, this is important because often it is the extreme values of the flood variables that lead to a flood event, but these occur infrequently. Extreme value analysis involves selecting peaks (either annual maxima or peaks over threshold) and fitting them to appropriate probability distribution functions.\n\nSelection of peaks\nThe first step in the process is to select a subset of the record that contains the extreme variable values. This is generally either the set of highest recordings in each year, known as annual maxima (AM) or the set of recordings that exceed a user defined threshold, known as peaks over threshold (POT).\nFor annual maxima the selection can be done for each calendar year, but it can also be done for a ‚Äúwater year‚Äù which may have a different start date than January 1st. The start of the water year should preferably be chosen in a season where little or no extremes are expected. This way, the chance is small an extreme event occurs right around the start of the year and is selected as the annual maximum for two consecutive years (for example, if high peaks occur on December 31st and January 1st that are caused by the same meteorological event).\nFor peaks over threshold, only a single value per event should be selected. So, for example, if a river discharge exceeds the threshold for five consecutive days, these can all be considered part of the same event and only the highest observed discharge during these five days should be selected as the peak discharge. It is recommended to define a time window during which only one peak can be selected to assure the selected peaks all represent independent events. The size of the window depends on the system/process under consideration. For a small mountain stream, a window of one or two days may suffice, whereas for a large river basin (&gt; 25,000 square miles) the window should be at least 10 days. A suitable choice of the threshold in a POT analysis also depends on the system under consideration. A lower threshold has the advantage that a larger number of peaks is selected which decreases the uncertainty in the probability distribution function that is subsequently derived from the selected peaks. On the other hand, it also results in lower peaks to be selected, which may be less representative of the extremes for which probabilities need to be derived, which may not be representative for the extremes for which statistics are derived. A pragmatic strategy is to choose the threshold in such a way that the number of selected peaks is equal to the number of years. This strategy is sometimes referred to as ‚ÄúAnnual Exceedance‚Äù (AE). Note that this series is not the same as AM, even though they both have the same number of peaks.\n\n\nSelection of a probability distribution function\nThe next step is to select a probability distribution function that will be fitted to the selected set of peaks. According to the extreme value theorem, the set of maxima of intervals of a fixed length (such as a year) has a Generalized Extreme Value (GEV) distribution. POT data follows a Generalized Pareto Distribution (GPD). Both GEV and GPD are three-parameter distribution functions with a location-, scale- and shape-parameter.\nThe GEV and GPD are generalized distributions of which other probability distributions are special cases: Gumbel, Fr√©chet and Weibull (GEV) and exponential and Pareto (GPD). The value of the shape parameter determines which of the underlying distributions is applicable for the data. If the shape parameter is approximately equal to zero, the Gumbel (GEV) and exponential (GPD) distribution functions should be used. If the shape parameter differs from zero, the Fr√©chet and Weibull (GEV) and Pareto (GPD) should be used. The value of the shape parameters can be derived from the selected set of peaks (see later this section on fitting distribution functions).\nFigure¬†2 shows examples of these distribution functions for daily rainfall. The rainfall is plotted against the corresponding exceedance probability on a semi-logarithmic scale. It shows that the two distribution functions for which the scale parameter is equal to 0 (Gumbel and exponential) are straight lines on this scale. The Weibull distribution is curved ‚Äúdownward‚Äù, while the Fr√©chet distribution is curved ‚Äúupward‚Äù. Similar upward and downward curves can be seen for the GPD (right plot); in both cases the distribution function is called the Pareto distribution. According to the theory, only the GEV and GPD or one of the underlying probability distribution functions (Gumbel, Fr√©chet, Weibull, exponential and Pareto) should be used to fit the set of selected extremes. In practice, however, other probability distribution functions are used as well. For example, the Log-Pearson Type 3 was adopted by US federal agencies for applications in flood frequency analysis.\n\n\n\n\n\n\nFigure¬†2: Examples of the GEV and GPD and underlying distributions. The plots show the probability of exceedance of annual maxima (left) and Peaks Over Threshold (right). \n\n\n\nThe graphs in Figure¬†2 show the probability of exceedance of annual maxima (left) and peaks over threshold (right) data. The exceedance probability of AM also represents the annual exceedance probability of the variable for which the distribution function was derived. For POT data, this is not the case because the number of peaks in a POT data set can be larger or smaller than the number of years. To convert to an annual exceedance probability, the derived exceedance probabilities of POT data must be multiplied by the average number of exceedances of the selected threshold in a year (denoted \\(\\lambda\\)). Parameter \\(\\lambda\\) can be estimated by dividing the number of selected peaks by the number of years in the record. Note that \\(\\lambda\\) is a frequency of occurrence (per year). Multiplication of this frequency with a probability of exceedance from the POT data results in a frequency of exceedance.\n\n\n\n\n\n\nProbability and Frequency\n\n\n\nThe terms ‚Äúprobability‚Äù and ‚Äúfrequency‚Äù are often used interchangeably to quantify the likelihood of a specific event occurring within a defined period. These two terms are similar, but not the same. Probability refers to the chance that an event will occur in a fixed period, typically a year. Frequency refers to how often such an event will occur on average during a fixed period. For example, at some location the probability of more than 5 inches of rainfall in a day may be estimated at 1/20 per year. That means each year there is a probability of 1 in 20 that more than 5 inches of rainfall is recorded in a day. In this case, the frequency is also equal to 1/20 per year, indicating such an event will occur on average once every 20 years. However, for events that occur more often, probability and frequency differ. For example, an event with more than 2 inches of rainfall in a day may occur on average twice per year. That means such an event has a frequency of 2 (per year). The probability of such an event happening in a year will be less than 1 since probabilities are, by definition, between 0 and 1. Probability is a quantification of the chance of such an event occurring at least once in a year, whereas frequency is a quantification of the number of times such an event occurs on average in a year. For very rare events, probability and frequency are (approximately) equal, because such events are not expected to occur more than once per year.\n\n\n\n\nFitting probability distributions\nThe next step is to fit the selected distribution function to the set of extremes (AM or POT). This means the parameter values of the distribution function are chosen such that key statistical characteristics of the distribution function correspond as much as possible with those of the set of extremes. There are several methods for deriving the parameter values, such as the maximum likelihood method, the method of moments, probability weighted moments and L-moments. Such methods are available in computational programming languages like Matlab, Python and R. Alternatively, dedicated software for flood frequency analysis can be used such as PeakFQ. In principle, any of these methods will do, but it is worth considering applying several methods to verify which one provides the best fit. There are statistical methods to quantify the goodness-of-fit like the Kolmogorov-Smirnov test, the Chi Square test or Anderson-Darling test. Each of these tests compares key characteristics of the data set with the fitted distribution function; smaller differences imply a better fit. The outcome of such a test could be that a fit is ‚Äúrejected‚Äù. In that case an alternative distribution function and/or fit method should be considered. The fact that there are different tests to choose from indicates there is some subjectivity involved in determining the ‚Äúbest‚Äù fit. It is recommended to also visually compare the fitted distribution function with the data, similar to the example of Figure¬†3. If the visual fit is not to satisfaction, a different distribution function and/or different fit methods should be considered.\n\n\n\n\n\n\nFigure¬†3: Example fit of the GPD function to Peaks Over Threshold data.\n\n\n\n\n\n\nCombining statistics of extreme events and average conditions\nIn flood risk analysis, the extremes as described in the previous section are the most relevant subset of the data. However, in areas with compound flooding, extremes of flood drivers do not necessarily coincide in time. For example, high intensity rainfall may occur during a period with negligible, low or moderate storm surge, and vice versa. This may result in a (substantially) different flood hazard compared to when both flood drivers are high/extreme. For a flood risk analysis with multiple flood drivers it is therefore necessary to also consider events where only a subset of the flood drivers is extreme. This means it is required to also derive probabilities of moderate/average conditions of flood drivers.\nSimilar to the extreme value analysis of the previous section, probability distribution functions can be selected and fitted to the available data set. The main difference is that in this case the entire data record is used instead of a small selection. With this larger data set, the use of an empirical distribution may be more practical than fitting a parametric probability distribution function. The advantage of using an empirical distribution functions is that it is relatively straightforward to derive and does not involve subjective choices of a distribution function and fit method. The empirical distribution is a direct reflection of the data set. For example, if a daily rainfall depth of 0.1 inch is exceeded in 12% of all days in the record, this means the exceedance probability of 0.1 inch/day in the empirical distribution function is estimated to be 0.12. So, by simply counting the number of exceedances of each threshold of interest and dividing by the total number of recordings, the empirical probability is obtained.\nTo derive the empirical probability distribution, sort the data in descending order. The largest value has an empirical probability of exceedance of 1/(n+1), where n is the total number of recordings. The second largest value has an empirical probability of exceedance of 2/(n+1), the third largest has an empirical probability of exceedance of 3/(n+1), and this continues all the way down to the smallest value with an empirical probability of exceedance of n/(n+1). Note that these are probabilities per time step of the time series. So, in case of a daily rainfall time series, these are exceedance probabilities per day. These can be translated to exceedance frequencies per year by multiplication with 365 (i.e.¬†the number of days per year). Similarly, derived empirical probabilities of tidal peaks should be multiplied with 705 (i.e., the number of tidal periods in a year) to derive exceedance frequencies per year.\n\n\n\n\n\n\nFigure¬†4: Example combination of an empirical distribution and an extreme value distribution.\n\n\n\nThe variable of interest now has an empirical distribution function, quantifying probabilities of all observed values, and an extreme value distribution function, quantifying exceedance probabilities of extremes. So, for the highest observed values in the record there are two probability estimates available. Ideally, these two probability estimates are the same, but this is often not the case. Especially for variables for which high peaks typically occur in clusters, there will most likely be a substantial difference in the two probability estimates due to the differences in the way these two probabilities were derived. Figure¬†4 shows the empirical probability distribution (black line) and fitted extreme value distribution (red line) of the tidal peaks at an example location. It shows the exceedance frequencies according to the empirical distribution are higher than those according to the extreme value distribution function. The green dashed line shows a pragmatic way to connect the two distributions and combine them into a single probability distribution function. An alternative approach could be to ‚Äúlift‚Äù the extreme value distribution such that is better connects with the empirical distribution. Such methods may seem like they are corrupting the results, but it is a necessary work-around to combine two distributions that are based on different approaches. The first approach (‚Äúeach tidal peak should be included‚Äù) is valid for average/moderate conditions, whereas the second (‚Äúonly the highest peak of each event is included‚Äù) is valid for extreme events.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#calculate-joint-probs",
    "href": "3_setup_guide/risk_analysis.html#calculate-joint-probs",
    "title": "Event Set",
    "section": "Step 3 - Calculate joint probabilities",
    "text": "Step 3 - Calculate joint probabilities\nEvent probabilities are the joint probabilities of the variables that define the event. If the variables are mutually independent, the joint probability can be calculated as the product of the the probabilities of the individual variables. However, some variables may be impacted by the same hydro-meteorological processes, which means they are not independent. For example, a storm event may cause both high storm surges and high rainfall intensities. In that case, high values of rainfall and storm surge are more likely to coincide, which means rainfall and storm surge are not independent. This needs to be accounted for when estimating event probabilities.\nStatistical dependence between two or more variables can be quantified with Pearson‚Äôs correlation coefficient, \\(\\rho\\), which can take any value in the range from -1 to 1. A value of 0 indicates two variables are independent, which means the value of one variable provides no information on the likelihood of the value of the other variable. If \\(\\rho\\) deviates substantially from 0, the variables are dependent. Positive values of \\(\\rho\\) imply that high values of one variable usually coincide with high values of the other variable, and similarly that low values generally coincide as well. Negative values of \\(\\rho\\) imply that high values of one variable usually coincide with low values of the other variable and vice versa. Figure¬†5 shows samples of hypothetical variables x and y for six different values of Pearson‚Äôs correlation coefficient.\n\n\n\n\n\n\nFigure¬†5: Samples of hypothetical variables x and y for six different values of correlation coefficient ÔÅ≤.\n\n\n\nPearson‚Äôs correlation coefficient assumes a linear relation between the correlated variables, which is not always the case. If two variables are perfectly correlated, but their relation is non-linear, the value of \\(\\rho\\) will be less than 1, indicating non-perfect correlation. This is one of the reasons why a rank correlation may be preferred over Pearson‚Äôs correlation coefficient. The two most well-known options are Spearman‚Äôs and Kendall‚Äôs rank correlation coefficients. Similar to Pearson‚Äôs correlation coefficient, these two rank correlation coefficients take on values between -1 and 1.\nEven though the correlation coefficient generally is an informative measure of statistical dependence, it does not provide the complete picture on dependency structures. In some cases, for instance, the dependence between variables is higher for extremes than for moderate events due to a common cause that is especially profound during extreme events. This phenomenon is sometimes observed in discharge records of two neighboring rivers. If one river experiences extremely high discharges, this is likely to be the result of an exceptional rainfall event that may also cause high discharges in the other river.\nAn effective approach to incorporate these types of correlation structures is the use of ‚Äúcopula functions‚Äù or ‚Äúcopulas‚Äù, which model the dependence structure of two or more random variables. A multivariate distribution function is then constructed using the individual probability distribution functions of the variables in combination with the copula. One of the key advantages of this method is that the derived individual probability distributions are preserved, which is not necessarily the case with alternative methods for deriving multivariate statistics.\nFigure¬†6 shows example realizations of copula variables x and y for four different copulas: the Gumbel-Hougard, Frank, Clayton and Gaussian copula. In each case, the correlation coefficient is equal to 0.8, but there are differences in the overall dependence structure. Application of the Gumbel-Hougard copula results in strong dependence for values of x and y close to 1. In other words, if a sample of the first random variable (x) is relatively large, the accompanying sample of the second variable most likely is relatively large as well. The Clayton copula, on the other hand, generates a stronger dependence structure for low values of x and y. In that respect the Frank copula and the Gaussian copula are more symmetrical, where the latter shows stronger correlation in the extremes (both left and right).\n\n\n\n\n\n\nFigure¬†6: Illustration of four different copulas. In all cases the correlation coefficient was assumed to be 0.8.\n\n\n\nCopula variables are uniformly distributed over the interval between 0 and 1. Hydro-meteorological variables like rainfall, river discharge or water level are typically not uniformly distributed and can take on values outside the interval between 0 and 1. Therefore, in order to use the copula to model dependency between hydro-meteorological variables, a statistical transformation is applied. This transformation is done based on ‚Äúequal probability of exceedance‚Äù. The transformation process is illustrated in Figure¬†7.\n\n\n\n\n\n\nFigure¬†7: Transformation from copula-variable y to storm surge variable s. F(s) is the cumulative probability distribution function of s.\n\n\n\nSince copula-variables x and y are correlated, the corresponding real-world variables (e.g.¬†rainfall, surge) will be correlated as well. This way, a set of correlated samples of storm surge and rainfall can be generated. Conversely, the copula function and transformations can also be used to compute the probability of an event of, for example, a river discharge of more than 5,000 cfs in combination with a storm surge of more than 2 feet. To do this, these thresholds of discharge (5,000 cfs) and storm surge (2 feet) need to be translated to their corresponding copula-parameters x and y, using their respective probability distributions.\nFigure¬†6 showed patterns of four copulas, but there are many other copulas available, covering essentially any correlation pattern imaginable. A copula needs to be selected that best matches the observed data. Plotting of observed joint occurrences of correlated variables may reveal which copula(s) best describe the correlation between the variables involved. For example, if the data indicate the dependency increases for large values, the Gumbel-Hougard copula is a possible candidate, whereas if the dependency increases for low values, the Clayton copula is a possible candidate. Another strategy is to try out a large set of copulas and verify which one provides the best fit of the data. There are several statistical tests available that quantify the goodness-of-fit of the copula to the data, similar to the goodness-of-fit tests for extreme value distribution functions. Such methods are available in computational software packages like Python and R.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#select-events",
    "href": "3_setup_guide/risk_analysis.html#select-events",
    "title": "Event Set",
    "section": "Step 4 - Select events and calculate their frequencies",
    "text": "Step 4 - Select events and calculate their frequencies\nWhen considering the selection of events, it is important to remember its purpose: the set of events will be used to calculate return period flooding and expected annual damages. The key to event selection is to ensure that the set of events is sufficient to reliably (consistently) estimate these important variables. There are two primary ways to select events and estimate their occurrence frequencies. One is to use a Monte Carlo approach, which is most recommended when there are a lot of variables that influence the flooding. The second is numerical integration, which is is more straight-forward and advantageous (in terms of required number of events) when the number of variables is limited to two - which may be the case for many areas.\nWith Monte Carlo sampling, a set of synthetic events is generated from the joint probability distribution of the event variables. This can be considered a representative set of possible events that may occur. For example, if an event with a joint occurrence of a peak river discharge between Q1 and Q2 and a peak sea water level between H1 and H2 has a probability of 0.05 per year according to the joint distribution, the sampling will lead to 5% of the simulated years containing an event in this range. However, since the sampling process is random by nature, the resulting percentage can also be lower or higher.\nIn a Monte Carlo Simulation, events are sampled directly from the multivariate probability distribution function of the flood drivers. The event set for FloodAdapt would consist of this set sampled events. The associated probability for each event is set equal to \\(1/n\\), where \\(n\\) is the total number of sampled events. Note that this is not the actual probability of each event. However, by applying this probability as input in FloodAdapt, the computation of flood probabilities will be according to the Monte Carlo Simulation method. In other words, the computed probability of flooding will be equal to the number of sampled events leading to flooding, divided by the total number of simulated events.\nWith numerical integration, the range of potential combinations of flood drivers is discretized in an n-dimensional computational grid (n being the number of flood drivers), so that all combinations are considered. Figure¬†8 shows an example for two flood drivers: river discharge and sea water level. In Figure¬†8, each rectangular grid cell has a center point, representing a single event with that combination of sea water level and river discharge. The event occurrence frequency is then taken as equal to the joint occurrence frequency of the variables. The range of variables that should be included, and the spacing of the computational grid, depend on when the values of interest (flooding probabilities and risk) stabilize. Extreme combinations of variables that have a very low occurrence frequency may not contribute a noticeable amount to flood probabilities or risk. Similarly, high-frequency low values of the variables that do not lead to flooding may also be negligible. For the latter, it is important to consider if they will still be negligible under future conditions before omitting them from the event set.\nBoth for Monte Carlo and for numerical integration, more events means better accuracy, but comes at a computational cost. For the Monte Carlo approach, a higher number of samples leads to better accuracy. For the Numerical Integration approach, a finer discretization of the variables leads to better accuracy. In each case, simulations with FloodAdapt can be done to assess the trade-off between number of events and accuracy of the risk and flood probability metrics.\n\n\n\n\n\n\nFigure¬†8: Schematic view of selected grids for numerical integration.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/risk_analysis.html#format-events",
    "href": "3_setup_guide/risk_analysis.html#format-events",
    "title": "Event Set",
    "section": "Step 5 - Format the events for FloodAdapt",
    "text": "Step 5 - Format the events for FloodAdapt\nOnce you have selected events and calculated their occurrence frquencies, they must be put in the correct format for FloodAdapt. Figure¬†9 shows the overall structure of the event set folder. The folder contains a sub-folder for each event in the event set and an event-set TOML file that gives the event names (which should align with the folder names) and the occurrence frequencies of the events. Each event folder should contain an event TOML file defining the event, and the time series (for the event duration) of the flood variables. More details about the event folder contents and the event set TOML file are given below.\n\n\n\n\n\n\nFigure¬†9: Overview of the setup process for FloodAdapt\n\n\n\n\nEvent folder contents\nEach event folder must contain a TOML file, with the name [EVENT_NAME].TOML, where [EVENT_NAME] should be replaced with the name of your event (which is also the name of the event folder). For example, if your event is called myEvent001, then the event folder should be called myEvent100, and the TOML file should be called myEvent001.TOML. In addition, the event folder must contain a time series file (CSV format) for each of the event variables that are varying over the duration of the event. Figure¬†10 shows the contents for an event named event_001.\n\n\n\n\n\n\nFigure¬†10: Contents of an event folder (example)\n\n\n\nThe time series CSV files are two-column files that contain a datetime in the first column and the variable value in the second column. The units of the variable will depend if you are working with imperial or metric units:\n\nRainfall - inches/hour (imperial) or mm/hour (metric)\nTide - feet+MSL (imperial) or meters+MSL (metric)\nSurge - feet (imperial) or meters (metric)\nRiver discharge - cubic feet per section (imperial) or cubic meters per second (metric)\nWind - knots (imperial) or m^3/s (metric)\n\nThe TOML file specifies the event. Figure¬†11 shows the template for an event TOML file, which includes forcing fields for river discharge, wind, rainfall, tide, and surge. In this example, there are two probabilistic event variables: rainfall and total sea water level (which includes both tide and surge). The river discharge is treated as a constant and wind is omitted because its effects are already accounted for in the total water level (which includes surge). Because the total water level variable includes both tide and surge, the surge variable is omitted (set to ‚Äúnone‚Äù) and the total water level time series is used for the ‚Äútide‚Äù field. A couple of notes about the event specifications:\n\nAll potential flood drivers must be defined, even if they are set to zero or none. For example, in Figure¬†11, the wind is set to ‚Äúnone‚Äù. Similarly, the discharge is set to ‚Äúconstant‚Äù because it is not treated probabilistically in this event set.\nAlthough the events are synthetic they use the ‚ÄúHistorical_nearshore‚Äù template because the event variables are being represented by time series like a historical event. This means that a start time and end time must be given. These can be anything in the past, as long as the duration matches the duration in the variable time series files.\n\n\n\n\n\n\n\nFigure¬†11: Example TOML file for an event named ‚Äúevent_0000‚Äù\n\n\n\n\n\nEvent set TOML file\nThe event set folder must contain an event set TOML file. This file will specify the names and occurrence frequencies of all of the events in the set. Every event specified in this TOML file must also have an associated event folder. Figure¬†12 shows an example of a TOML file for a set named ‚Äúprobabilistic_set‚Äù.\n\n\n\n\n\n\nFigure¬†12: Example TOML file for an event\n\n\n\nThe required fields are:\n\nname - this should also be the name of the event-set folder\ndescription - this can be anything\nmode - this should be set to ‚Äúrisk‚Äù\nsubevent_name - this is a list of the events for which event folders have been created\nfrequency - this is a list of occurrence frequencies for the events in the subevent_name list\n\nOnce the event set folder is created, you can reference it in the database builder configuration file and it will be included in the FloodAdapt database so users can calculate risk and risk-reduction benefits of adaptation options.",
    "crumbs": [
      "Event Set"
    ]
  },
  {
    "objectID": "3_setup_guide/database.html",
    "href": "3_setup_guide/database.html",
    "title": "Database-Builder",
    "section": "",
    "text": "The FloodAdapt database-builder is intended to greatly simplify the process of setting up FloodAdapt in a new location. The FloodAdapt software is an ‚Äòempty shell‚Äô that must be connected to a site-specific database. The database-builder aids the user in setting up this database.\nThe most critical components of the FloodAdapt database are the SFINCS and Delft-FIAT models, both of which can now be generated with greater ease using the SFINCS model-builder and the Delft-FIAT model-builder. Once these have been created, users can run the FloodAdapt database-builder to generate a complete database for a functioning FloodAdapt application at their site.\nTo run the database-builder, a user double-clicks the FloodAdapt database-builder executable. This opens a screen where the user can enter a file path to the database-builder configuration file.\nThis documentation will describe the FloodAdapt database-builder configuration file. Depending on the amount of information included in the configuration file, different FloodAdapt functionalities will be activated. This is described in the section FloodAdapt capabilities based on configuration. It starts by outlining the minimum information required to generate a functional FloodAdapt system, and then specifies additional functionalities and the required information in the configuration file to activate them. The section Configuration file attributes specifies all of the attributes that can be included in the database-builder configuration and includes details about their format and use.",
    "crumbs": [
      "Database-Builder"
    ]
  },
  {
    "objectID": "3_setup_guide/database.html#floodadapt-capabilities-based-on-configuration",
    "href": "3_setup_guide/database.html#floodadapt-capabilities-based-on-configuration",
    "title": "Database-Builder",
    "section": "FloodAdapt capabilities based on configuration",
    "text": "FloodAdapt capabilities based on configuration\nThere are different functionalities that are activated in FloodAdapt depending on the information contained in the configuration file. This section starts by describing the information needed for the baseline FloodAdapt configuration, which is the minimum needed to set up a functional FloodAdapt system. Note that an important requirement is that a Delft-FIAT model and an overland SFINCS model have been set up for the site. The subsequent sections then describe additional FloodAdapt functionality that is activated with additional configuration input.\n\nBaseline FloodAdapt configuration\nA baseline FloodAdapt configuration is a functional version of FloodAdapt that requires the minimum amount of configuration file input. This version allows users to run event scenarios for either a synthetic event or a historical gauged event. All measures and future projections are available for analysis. Note that because it only supports event scenarios, the risk and benefits options are not available for this baseline configuration.\nA baseline FloodAdapt configuration allows users to get started with FloodAdapt with relatively little required information. The following is all that is required for a baseline configuration:\n\nA name for your site\nThe path to your overland SFINCS model folder\nThe path to your Delft-FIAT model folder\nThe unit system you want to work in (imperial or metric)\nMax values for output maps displayed in the FloodAdapt user interface\n\n\n\n\n\n\n\nIncluding the baseline configuration attributes in the database configuration file\n\n\n\nThe name of your site, paths to your SFINCS and Delft-FIAT models, and the unit system are all specified in the header section of the configuration file which is described under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section. The max values for output maps are specified in the GUI attributes section.\n\n\n\n\nRisk and benefit analysis\nThe baseline FloodAdapt configuration allows users to simulate event scenarios, which can be very insightful. However, risk scenarios allow users to understand the current and future risk to a community (considering many types of events), with and without adaptation options, and to calculate the risk-reduction benefits of adaptation strategies. To activate the risk scenario and benefit analysis functionality, a probabilistic event set is required. When this set is included in the FloodAdapt database, FloodAdapt can calculate the flooding for all the events in the set and uses a probabilistic calculator to calculate return period flooding, impacts, and risk.\n\n\n\n\n\n\n\nIncluding a probabilistic event set in the database configuration file\n\n\n\nSpecifying a probabilistic event set is done in the Header section of the configuration file. See the attributes in the Header section under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section.\n\n\n\n\nSimulating hurricane events and ‚Äòungauged‚Äô historical events\nFor FloodAdapt users to simulate a scenario with a historical hurricane, or to simulate a historical event for which there are no measured nearshore water levels, an offshore SFINCS model needs to be included in the FloodAdapt database (this can be created with the SFINCS model-builder). Once an offshore model is included, users will see additional event types that can be selected when they click ‚ÄúAdd Event‚Äù in the FloodAdapt Events tab (see Figure¬†1). If a specific cyclone basin is specified in the database configuration file, only hurricanes in the specified basin will be included in the database and displayed in the hurricane selector window (which appears when the ‚ÄòHistorical - hurricane‚Äô option is chosen); see Figure¬†2. Note that if hurricanes are not relevant in an area, but an offshore model is included to simulate ungauged historical events, the hurricane event option can be ‚Äúturned off‚Äù in the database configuration file. \n\n\n\n\n\n\nFigure¬†1: Adding an offshore model activates the ability to select a hurricane event, as well as an ‚Äòungauged‚Äô historical event. Both of these event types make use of the offshore model. The left window shows the ‚ÄúAdd event‚Äù popup window for the baseline FloodAdapt configuration, and the right shows with the addition of an offshore model\n\n\n\n\n\n\n\n\n\nFigure¬†2: Hurricane selection window when a user has selected ‚ÄúNA‚Äù for North America as the ‚Äòcyclone basin‚Äô\n\n\n\n\n\n\n\n\n\nIncluding an offshore model and cyclone basin in the database configuration file\n\n\n\nSpecifying an offshore SFINCS model and a cyclone basin is done in the Header section of the configuration file. See the attributes in the Header section under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section.\n\n\n\n\nDownloading historical water levels\nFloodAdapt allows users to simulate historical events. In the baseline FloodAdapt configuration, FloodAdapt users need to import their own water level time series for historical events. When a tide gauge (or alternatively a long time series CSV file) is added to the FloodAdapt database, this activates a ‚ÄòDownload Observed Water Levels‚Äô button in the specification window for a historical event. FloodAdapt users can then easily download water levels for a historical event by selecting a start and end date and clicking that button. Figure¬†3 shows the baseline FloodAdapt configuration on the left and with the inclusion of a tide gauge on the right. For sites in the U.S. tide gauges can be added automatically based on the site location via the NOAA COOPS website. The NOAA site also includes datum differences at gauge locations, so that users have the option to view water levels relative to a (potentially) more familiar datum (see Figure¬†3).\n\n\n\n\n\n\nFigure¬†3: Adding a tide gauge allows a user to activate the ‚ÄòDownload observed water levels‚Äô button. Additionally, it also allows users to specify different references they can view with the water level time series, and to set a different reference level (‚Äòzero‚Äô) than mean sea level (MSL). The left window shows the baseline FloodAdapt configuration, and the right shows with the addition of a tide gauge.\n\n\n\n\n\n\n\n\n\nIncluding a tide gauge in the database configuration file\n\n\n\nDetails how to include a tide gauge (or long water level time series) to activate the ‚ÄòDownload Observed Water Levels‚Äô button are described under ‚ÄòConfiguration file attributes‚Äô in the Tide Gauge section.\n\n\n\n\nSocial vulnerability insights\nFloodAdapt automatically generates an infographic and a metrics table which helps FloodAdapt users understand the impacts of a simulated scenario. Social vulnerability is based on a collection of socio-economic attributes that indicate a longer or harder recovery from a flood event. When a social vulnerability index (SVI) layer is included in the FloodAdapt database, FloodAdapt shows additional information in the infographic and metrics table related to how socially vulnerable people are affected in a simulated scenario. Users can also view the SVI layer in both the Measures and Output tabs, helping to identify where to explore measures and understand the impacts to socially vulnerable people. Figure¬†4 highlights the added information in the infographic and metrics table. It shows the baseline configuration on the left, and the configuration with an SVI layer added on the right. With the SVI layer included, users can see in the infographic the proportion of highly-vulnerable residential buildings that were damaged and destroyed. In the metrics table, they can see how many highly vulnerable residential properties were flooded.\n\n\n\n\n\n\nFigure¬†4: When an SVI layer and a threshold are included, the infographic will include an additional graphic showing the distribution of residential impacts on high and low socially vulnerable homes \n\n\n\n\n\n\n\n\n\nIncluding an SVI layer in the database configuration file\n\n\n\nThe attributes needed to include an SVI layer are described under ‚ÄòConfiguration file attributes‚Äô in the Social vulnerability index section.\n\n\n\n\nVisualizing water level output time series\nFloodAdapt allows users to view modeled water level time series at observation points in the FloodAdapt Output tab. The spatial flood map in the FloodAdapt Output tab is static and represents the maximum flood depth during an event. Having observation points helps users understand how the water levels evolved during an event. To activate this functionality, observation points can be added to the database-builder configuration file.\n\n\n\n\n\n\nFigure¬†5: Adding observation points activates the functionality to view water level time series output at these points in the FloodAdapt Output tab. The left window shows the baseline FloodAdapt configuration, and the right shows with the addition of observation points.\n\n\n\n\n\n\n\n\n\nIncluding observation points in the database configuration file\n\n\n\nThe attributes needed to include observation points are described under ‚ÄòConfiguration file attributes‚Äô in the Observation Points section.\n\n\n\n\nElevating buildings above base flood elevation (BFE)\nFloodAdapt allows users to explore home elevations as an adaptation measure. With the base configuration, FloodAdapt users can specify how high a home should be elevated relative to a datum. However, in the U.S. standards for home elevations or elevations of new buildings are often specified relative to base flood elevation (BFE). This is a regulatory 100-year flood level calculated by the federal government. When users reference a base flood elevation layer in the configuration file, FloodAdapt users can choose to elevate homes above a datum or to a height above BFE.\n\n\n\n\n\n\nIncluding a BFE layer in the database configuration file\n\n\n\nThe attributes needed to include a BFE layer are described under ‚ÄòConfiguration file attributes‚Äô in the Base Flood Elevation section.\n\n\n\n\n\n\n\n\nFigure¬†6: Adding a base flood elevation (BFE) layer activates the ability to elevate homes relative to BFE in addition to elevating relative to datum\n\n\n\n\n\nSea level rise scenario selection\nFloodAdapt allows users to explore the flooding and impacts for future sea level rise projections. In the base configuration case, users have access to this functionality, and can enter a sea level rise explicitly, for example ‚Äú0.5 feet‚Äù. However, FloodAdapt users may want to explore flooding and impacts at a specific point in the future, for example in 15 or 20 years, and they may not know the sea level rise to expect in that future year. To facilitate these users, a sea level rise scenario CSV file can be included in the database setup. There are many sources for sea level rise scenarios, such as the interagency sea level task force. There is no limit to the number of SLR scenarios a user can include. FloodAdapt uses this file to generate a visualization showing the different SLR scenario curves in the Projections selection window. It also allows a user to enter a future year and select a SLR scenario, and then automatically calculates the sea level rise for that year.\n\n\n\n\n\n\nIncluding SLR scenarios in the database configuration file\n\n\n\nThe attributes needed to specify SLR scenarios are described under ‚ÄòConfiguration file attributes‚Äô in the Sea Level Rise Scenarois section.\n\n\n\n\n\n\n\n\nFigure¬†7: Including a sea level rise scenario CSV file allows a user to select one of the SLR scenarios and a future year, and FloodAdapt automatically calculates the sea level rise\n\n\n\n\n\n\n\n\n\nWhat about when sea level rise scenarios change?\n\n\n\nSea level rise scenarios are updating every few years. Updating the sea level rise scenarios in FloodAdapt is a simple as updating the CSV file with the years and projected sea level rise. FloodAdapt will then automatically use the new information when a FloodAdapt user selects a future year and a sea level rise scenario.",
    "crumbs": [
      "Database-Builder"
    ]
  },
  {
    "objectID": "3_setup_guide/database.html#configuration-file-attributes",
    "href": "3_setup_guide/database.html#configuration-file-attributes",
    "title": "Database-Builder",
    "section": "Configuration file attributes",
    "text": "Configuration file attributes\n\nHeader attributes\nFigure¬†8 shows the mandatory attributes that are given at the top of the configuration file. These are required for all configurations, including the baseline configuration. These will be described below.\n\n\n\n\n\n\nFigure¬†8: Snippet showing the mandatory attributes of the top of the configuration file\n\n\n\nMandatory attributes are:\n\nname - this is the name of the database folder for your site\ndatabase_path - this is the path where your database folder will be saved\nsfincs - this is the location of your SFINCS overland model\nfiat - this is the location of your Delft-FIAT model\nunit system - this is either ‚Äúimperial‚Äù or ‚Äúmetric‚Äù\n\nFigure¬†9 shows the optional attributes that are given at the top of the configuration file. These will be described below.\n\n\n\n\n\n\nFigure¬†9: Snippet showing the optional attributes of the top of the configuration file\n\n\n\nOptional attributes are:\n\nsfincs_offshore - this is the location of your SFINCS offshore model.\ncyclone_basin - this is the region code (given with quotation marks around it, see Figure¬†9) where your site is located, for filtering the tropical cyclones (hurricanes) that show up in the hurricane selection window in FloodAdapt. Region codes are described below this list.\nprobabilistic_set - this is the path to the prepared event set and event frequencies which enable risk analysis\ncyclones - this is by default ‚ÄúTrue‚Äù, but if set to ‚ÄúFalse‚Äù hurricanes will not show up as an option when a user selects ‚ÄúAdd Event‚Äù in FloodAdapt\n\nFor the cyclone_basin the region code options are:\n\nNA = North Atlantic\nSA = South Atlantic\nEP = Eastern North Pacific (which includes the Central Pacific region)\nWP = Western North Pacific\nSP = South Pacific\nSI = South Indian\nNI = North Indian\n\n\n\nGUI attributes\n\n\n\n\n\n\nFigure¬†10: Snippet showing the attributes of the GUI\n\n\n\nFigure¬†10 shows the attributes that are required for the GUI. These are mandatory attributes that must be included in all configuration files, including the base configuration file.\nThe GUI attributes all have to do with maximum values. These are used to create automatic bins for the spatial mapping of flooding, impacts, and benefits.\nStart the GUI attribute section with [gui]. The values that need to be specified are:\n\nmax_flood_depth - this will be the highest legend value in the output flood maps (above which all values get the same color).\nmax_aggr_dmg - this will be the highest legend value in the output aggregated damages maps (above which all values get the same color). A good choice for this value will depend on the size of your aggregation, the density of the building footprints, and the currency value in the application area. It can be difficult to know apriori what to pick here, but the value can always be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\nmax_footprint_dmg - this will be the highest legend value in the output building damages maps (above which all values get the same color), and can be estimated based on the maximum potential values of the buildings in the site area.\nmax_benefits - this is the maximum value for the spatial benefits. This can also be difficult to estimate apriori, but can be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\n\n\n\nBuilding footprints\nThe attributes for building footprints are shown in Figure¬†11. A building footprint layer allows users to visualize the building footprint damages in the output maps (instead of only points). Note that if a building footprint file is not included, the database-builder will automatically add Open Street Map building footprints to support the visualization of building damages in the FloodAdapt application.\n\n\n\n\n\n\nFigure¬†11: Snippet showing the attributes of the baseline configuration\n\n\n\nFor building footprints, start the section with [building_footprints] and provide the following attributes:\n\nfile - this is the path to the building footprint file (this should be a vector file, like a shapefile or a geopackage), making sure to use forward slahses in the paths.\nfield_name - this should be a unique identifier attribute in the vector file, like an Object ID.\n\n\n\nTide Gauge\nThe attributes needed to include a tide gauge are shown in Figure¬†12. The inclusion of a tide gauge allows FloodAdapt users to automatically download water levels for a specified start and end time.\n\n\n\n\n\n\nFigure¬†12: Snippet showing the attributes of the tide gauge configuration\n\n\n\nFor a tide gauge, start the section with [tide_gauge] and provide the following attributes:\n\nsource - this is either ‚Äúnoaa_coops‚Äù if you want to use the closest NOAA gauge station from https://tidesandcurrents.noaa.gov/stations.html (only available in the U.S.) OR ‚Äúfile‚Äù if you will be providing gauge data (water level time series) in a CSV file.\nfile - this is only required if the source is equal to ‚Äúfile‚Äù. It should be the path to a CSV file containing the gauged water level time series. The CSV file should have two columns; the first contains a ‚Äòdatetime‚Äô in the format DD/MM/YYYY HH:MM and the second column contains the water levels relative to mean sea level.\nref - this is an optional attribute; if provided, it will be used as the ‚Äòzero‚Äô when plotting event water levels in the event specification window of FloodAdapt.\n[tide_gauge.max_distance] - this is a section to specify the maximum radius around the site to search for a tidal gauge station. This prevents tide gauges being applied to a site that are too far away to be representative. The attributes that fall under this are value which gives a numeric value for the distance, and units which specifies the unit of the value (e.g.¬†‚Äúmiles‚Äù). See Figure¬†12 for an example.\n\n\n\nSocial vulnerability index (SVI)\nThe attributes needed to include an SVI layer are shown in Figure¬†13. The inclusion of an SVI layer allows FloodAdapt users to get additional information in the infographic related to who is being impacted, and to view the layer in the FloodAdapt Measures and Output tabs.\n\n\n\n\n\n\nFigure¬†13: Snippet showing the attributes of the SVI layer configuration\n\n\n\nFor an SVI layer, start the section with [svi] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the SVI layer\nfield_name - this is the name of the attribute in the geospatial file that contains the social vulnerability index.\nthreshold - this is the value of the SVI above which homes will be considered to have a high social vulnerability.\n\n\n\nBase flood elevation (BFE)\nThe attributes needed to include a BFE layer are shown in Figure¬†14. The inclusion of a BFE layer allows FloodAdapt users to elevate buildings relative to this layer, in addition to being able to elevate relative to datum.\n\n\n\n\n\n\nFigure¬†14: Snippet showing the attributes of the BFE layer configuration\n\n\n\nFor a BFE layer, start the section with [bfe] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the BFE layer\nfield_name - this is the name of the attribute in the geospatial file that contains the base flood elevation.\n\n\n\nSea level rise (SLR) scenarios\nThe attributes needed to include SLR scenarios are shown in Figure¬†15. The inclusion of a SLR scenarios file allows FloodAdapt users to enter a future sea level rise projection by selecting a SLR scenario and a year in the Projections window of FloodAdapt.\n\n\n\n\n\n\nFigure¬†15: Snippet showing the attributes of the SLR scenarios configuration\n\n\n\nFor SLR scenarios, start the section with [slr_scenarios] and provide the following attributes:\n\nfile - this is the path to the CSV file that contains the SLR scenario information. Figure¬†16 shows an example of the CSV file format. The first column should contain the year, the second column the units, and each additional column should contain the projections at the specified years in column 1. Each SLR scenario column should contain a header with the name of the SLR scenario. These are the names that will show up in the Projections window.\nrelative_to_year - this is the year you want the SLR projections relative to. Often SLR scenarios are relative to an older date, for example the year 2000. If you want to know how a recent event would look with SLR, you will want to know the SLR relative to a more recent year. The relative_to_year does not need to be exactly the current year, but should be within a few years of events of interest. When a user selects a SLR scenario and a year, FloodAdapt will then automatically calculate the SLR relative to the date selected here.\n\n\n\n\n\n\n\nFigure¬†16: Snippet showing an example of a SLR scenario CSV file\n\n\n\n\n\nObservation points\nThe attributes needed to include observation points are shown in Figure¬†17. The inclusion of observation points allows FloodAdapt users to visualize a time series of water levels at these points throughout a simulated event (rather than only a maximum flood depth as is shown in the spatial maps).\n\n\n\n\n\n\nFigure¬†17: Snippet showing the attributes of the observation points configuration. In this example there are two observation points included. Each one begins with a the double-bracketed ‚Äúobs_point‚Äù header\n\n\n\nUsers can enter multiple observation points. These are treated as a list, which means that each observation point gets its own section with the same name (obs_point), enclosed in a double square bracket.\nFor observation points, start the section with [[obs_point]] (one for each observation point) and provide the following attributes:\n\nname - this is the name of your observation point. This name cannot contain spaces or special characters.\ndescription - this a descriptive name of your observation point. This will show up at the top of the time series plot in the FloodAdapt Output tab.\nlat - this is the latitude of your observation point.\nlon - this is the longitude of your observation point.",
    "crumbs": [
      "Database-Builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html",
    "title": "SFINCS model-builder",
    "section": "",
    "text": "The SFINCS ModelBuilder is a user-friendly interface built on top of the HydroMT-SFINCS Python package. It simplifies the process of setting up a basic SFINCS model for an area using local data, without requiring programming expertise.\nFigure¬†1 shows the SFINCS ModelBuilder interface, which includes six tabs in the upper section. For generating a SFINCS model compatible with FloodAdapt, you will primarily use the first tab, the ‚ÄòModel Maker‚Äô tab. The other tabs are designed for creating standalone SFINCS models for use outside of FloodAdapt, but can be used for customizations such as editing automatically defined boundary points or setting river discharge points. Within the ‚ÄòModel Maker‚Äô tab, the five sub-tabs at the bottom guide you through the process of creating a SFINCS model.\nThis guide is organized into the following sections:",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-getting-started",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-getting-started",
    "title": "SFINCS model-builder",
    "section": "Getting started",
    "text": "Getting started\nTo get started building your SFINCS model:\n\nOpen the ModelBuilder application; this contains functionality to build a SFINCS and a Delft-FIAT model\nClick ‚ÄúModel‚Äù in the top menu bar and choose ‚ÄúSFINCS (HydroMT)‚Äù\nClick ‚ÄúFile‚Äù in the top menu bar and choose ‚ÄúSelect Working Directory‚Äù\nSelect an existing folder or create a new one where your model will be saved",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-domain",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-domain",
    "title": "SFINCS model-builder",
    "section": "Defining the model domain and grid",
    "text": "Defining the model domain and grid\nThe SFINCS domain defines the area where the model will simulate hydrodynamics. For a fully functional FloodAdapt system, two SFINCS models are typically required:\nSurge (a.k.a. ‚Äúoffshore‚Äù) model: Simulates storm surge over a large area, typically using a coarser grid resolution. Its primary purpose is to generate time series of water levels that serve as input for the overland model.\nOverland model: Uses a finer grid resolution to simulate compound flooding on land.\nThe process of transferring water levels from the surge model to the overland model is known as ‚Äúgrid nesting‚Äù. In this guide, we focus on creating the overland model. Details on setting up a surge model will be provided in future updates.\n\nSelect Overland Model:\n\n\nIn the ‚ÄòModel Maker - Domain‚Äô tab, start by selecting ‚ÄúOverland model‚Äù.\n\n\nDefine the Spatial Coordinate System:\n\n\nCheck ‚ÄúAuto-select UTM Zone‚Äù to automatically set the spatial coordinate system for your model.\nLeave the ‚ÄúAuto-rotate grid‚Äù option unchecked.\n\n\nDefine the domain area:\n\n\nWhen modeling local precipitation (as in FloodAdapt scenarios), ensure full watershed area(s) are included:\n\nCheck ‚ÄúLocal Precipitation‚Äù and click ‚ÄúSelect Watershed‚Äù.\nA pop-up will appear where you can select one or more watersheds for your domain.\n\nOnce you‚Äôve selected the watersheds, click ‚ÄúOK‚Äù.\nYou may also choose to draw a polygon or upload a geospatial file to define the domain area. Take care to ensure that the domain covers the full extent of areas contributing water to the system. Failure to include these areas can cause water to pile up at the boundaries, which is why selecting entire watersheds is recommended.\nThe GUI will prompt you to confirm a coordinate system change based on the domain area that was defined. Click ‚ÄúYes‚Äù to proceed.\n\n\n\nFigure¬†2 shows the ‚ÄòModel Maker - Domain‚Äô tab with the ‚ÄúSelect Watershed‚Äù pop-up.\n\n\n\n\n\n\nFigure¬†2: The SFINCS ModelBuilder ‚ÄòModel Maker - Domain‚Äô tab and ‚ÄúSelect Watershed‚Äù pop-up.\n\n\n\nAfter completing the steps above, a new box will appear for defining the model resolution.\n\nDefine the model resolution:\n\n\nA grid resolution of 50‚Äì100 m is typically appropriate for an overland model.\n\nCoarser resolutions allow faster simulations but may reduce accuracy.\nIt is recommended to test the model in FloodAdapt using a historical flooding event with known outcomes to ensure the chosen resolution is suitable for the location.\n\nOnce you have chosen a resolution, click ‚ÄúGenerate Grid‚Äù. The viewer will display a preview of the model grid.\n\nYou can zoom in on the viewer to inspect grid details and ensure the resolution seems appropriate for features in your area.\n\n\nA summary of the model domain and grid is displayed in the bottom-right corner of the GUI.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-topobathy",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-topobathy",
    "title": "SFINCS model-builder",
    "section": "Mapping topography/bathymetry data to the grid",
    "text": "Mapping topography/bathymetry data to the grid\nTo map topography and bathymetry data onto your model grid, follow these steps:\n\nNavigate to the ‚ÄòModel Maker - TopoBathy‚Äô Tab:\n\n\nClick on the ‚ÄòTopoBathy‚Äô tab at the bottom of the GUI.\n\n\nLoad additional DEM Dataset(s) (Optional):\n\n\nOn the bottom-left of the tab, you‚Äôll see a list of available DEM dataset sources.\nYou may add a dataset by clicking ‚ÄúAdd Dataset‚Äù. The file must be in GeoTIFF format.\n\nEnsure all datasets share the same vertical reference (e.g., NAVD88, MSL) to avoid inconsistencies.\n\n\n\nSelect and Order Datasets:\n\n\nMove the desired datasets to the ‚ÄúSelected Datasets‚Äù box (on the right) by using the arrow button.\nIf using multiple datasets, sort them in order of priority:\n\nThe most detailed and accurate dataset should be at the top.\nAreas not covered by this dataset will be filled using subsequent datasets in the order listed.\n\n\n\nGenerate Bathymetry:\n\n\nOnce satisfied with your dataset selection and order, click ‚ÄúGenerate Bathymetry‚Äù in the bottom-right of the GUI.\nThe topography and bathymetry data will be displayed in the viewer, showing how it is mapped to the model grid.\n\nFigure¬†3 illustrates the ‚ÄòModel Maker - TopoBathy‚Äô tab with a topo-bathymetric dataset mapped to the model grid.\n\n\n\n\n\n\nFigure¬†3: The SFINCS ModelBuilder ‚ÄòModel Maker - TopoBathy‚Äô tab.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-active-cells",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-active-cells",
    "title": "SFINCS model-builder",
    "section": "Defining active cells",
    "text": "Defining active cells\nSFINCS optimizes simulations by only performing computations in ‚Äúactive cells‚Äù ‚Äî grid cells that are within the area of interest. Cells outside this area are marked as inactive and excluded from calculations, speeding up simulations. The following steps detail how to define the active cells:\n\nNavigate to the ‚ÄòModel Maker - Active Cells‚Äô tab:\n\n\nGo to the ‚ÄòModel Maker - Active Cells‚Äô tab at the bottom of the GUI.\nClick ‚ÄúShow Active Cells‚Äù to display the current configuration:\n\nBy default, cells within the selected watersheds are marked as ‚Äúactive‚Äù.\nCells outside the watersheds are ‚Äúinactive‚Äù.\n\n\n\nModify the Active Cell Mask (Optional):\n\n\nIf adjustments are needed, check the box for ‚ÄúManually add/remove cells to/from your active mask.‚Äù\n\nYou can draw or load polygons to include or exclude specific areas.\n\n\n\nAdvanced Mask Settings (Optional):\n\n\nClick ‚ÄúModify Mask Settings‚Äù to define active cells based on:\n\nElevation thresholds (e.g., minimum and maximum elevation).\nIsolated areas:\n\nMaximum area of cells surrounded by active cells to include.\nMaximum area of isolated cells to remove.\n\n\n\n\nRe-click ‚ÄúShow Active Cells‚Äù to see updates.\n\nFigure¬†4 shows the SFINSC model-builder ‚ÄúActive Cells‚Äù tab, with active cells highlighted in yellow.\n\n\n\n\n\n\nFigure¬†4: The SFINCS model-builder ‚ÄòModel Maker - Active Cells‚Äô tab.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-boundary-cells",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-boundary-cells",
    "title": "SFINCS model-builder",
    "section": "Defining boundary cells",
    "text": "Defining boundary cells\nBoundary cells are used to apply water level data to your model. These cells will be forced with data from sources such as: - An offshore model, - Synthetic tidal or surge signals, or - Historical tide gauge measurements.\nTo define the boundary cells, follow these steps:\n\nNavigate to the Boundary Cells Tab:\n\n\nOpen the ‚ÄòModel Maker - Boundary Cells‚Äô tab at the bottom of the GUI.\n\n\nSet the Water Level Boundary:\n\n\nThe goal is to mark the entire offshore edge of the model as a ‚ÄúWater Level boundary.‚Äù\nIn the GUI, these boundary cells will appear as dark blue.\n\n\nCustomize the Boundary Area (Optional):\n\n\nUse polygons to restrict the boundary area if needed.\nAlternatively, use a ‚Äúwater depth threshold‚Äù to automatically select boundary cells.\n\n\n\n\n\n\n\nFigure¬†5: The SFINCS ModelBuilder ‚ÄòModel Maker - Boundary Cells‚Äô tab.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-build-model",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-build-model",
    "title": "SFINCS model-builder",
    "section": "Build model",
    "text": "Build model\nAt this point, the model is ready to be built.\n\nNavigate to the ‚ÄòBuild Model‚Äô tab:\n\n\nOpen the ‚ÄòModel Maker - Build Model‚Äô tab at the bottom of the GUI.\n\n\nReview datasets:\n\n\nThis tab gives a summary of the topo-bathymetric datasets that will be used, and bottom friction datasets.\n\nCurrently the only bottom friction option is the default ‚ÄúConstant values‚Äù.\n\n\n\nBuild the model:\n\n\nIn the bottom right of the GUI, select ‚ÄúBuild Model‚Äù.\nA pop-up will appear that says ‚ÄúGenerating subgrid‚Ä¶‚Äù\n\nDuring this time, the ModelBuilder is generating the SFINCS subgrid files and saving them to the working directory chosen earlier.\n\nNext, you will be prompted, ‚ÄúDo you want to make a FloodAdapt model?‚Äù - choose ‚ÄúYes‚Äù.\n\nThis step configures the SFINCS model in such a way that FloodAdapt will be able to interact with it.\n\nNext, you will be asked ‚ÄúSpecify maximum zoom level(0-20) for tiles:‚Äù\n\nA good default value for this is ~13.\nThis enables smooth zooming capabilities within the FloodAdapt viewer.\nAfter selecting ‚ÄúOK‚Äù, the ModelBuilder will inform that it is writing the tiles.\n\n\n\nDefine boundary points:\n\n\nThe last prompt when building the model is ‚ÄúDo you want to automatically generate water level boundary points?‚Äù. Select ‚ÄúYes‚Äù here.\n\nOnce generated, the boundary points will appear in the GUI as dark blue dots.\nIf your overland model will be nested within a larger offshore SFINCS model, the two are coupled together via these boundary points.\nSee Editing boundary points for details on editing boundary points.\n\n\nThis completes the process of setting up a SFINCS model for FloodAdapt.\n\n\n\n\n\n\nFigure¬†6: The SFINCS ModelBuilder ‚ÄòModel Maker - Build Model‚Äô tab.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-boundary-points",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-boundary-points",
    "title": "SFINCS model-builder",
    "section": "Editing boundary points (Optional)",
    "text": "Editing boundary points (Optional)\nIn order to modify the automatically generated boundary points, visit the ‚ÄòBoundary Conditions - Water levels‚Äô tab (Boundary Conditions is an upper level tab).\n\nNavigate to the ‚ÄòWater levels‚Äô tab:\n\n\nOpen the ‚ÄòBoundary Conditions‚Äô upper tab, and select the ‚ÄòWater levels‚Äô lower tab.\n\n\nModifying Boundary Points:\n\n\nYou can manually add or delete boundary points in this tab.\nHighlighting a point in the bottom right box will highlight the point in the viewer.\nWater level boundary points should be evenly spaced along the water level boundary.\n\n\nSaving Changes:\n\n\nAfter changes are made, select ‚ÄúFile‚Äù then ‚ÄúSave‚Äù.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-river-discharge",
    "href": "3_setup_guide/SFINCS/hydromt_sfincs_gui.html#sec-river-discharge",
    "title": "SFINCS model-builder",
    "section": "Defining river discharge points (Optional)",
    "text": "Defining river discharge points (Optional)\nIn order to define a river discharge point, visit the ‚ÄòBoundary Conditions - Discharge‚Äô tab (Boundary Conditions is an upper level tab).\n\nNavigate to the ‚ÄòDischarge‚Äô tab:\n\n\nOpen the ‚ÄòBoundary Conditions‚Äô upper tab, and select the ‚ÄòDischarge‚Äô lower tab.\n\n\nDefine the river discharge point location:\n\n\nYou can manually add or delete river discharge points in this tab.\nOnce a point is added, you can add a default discharge value in cubic meters per second.\n\nDischarge points act as a source point in the model, water enters the domain at that location at the rate specified.\n\n\n\nSaving Changes:\n\n\nAfter changes are made, select ‚ÄúFile‚Äù then ‚ÄúSave‚Äù.",
    "crumbs": [
      "SFINCS Setup",
      "SFINCS model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html",
    "title": "Delft-FIAT model-builder",
    "section": "",
    "text": "The Delft-FIAT model builder was designed to make it easy for analysts to set up a Delft-FIAT model. The model-builder can be used to automatically generate a Delft-FIAT model or to create a tailored model using local data. In both cases, the user starts by selecting their working directory and choosing their area of interest (model boundary). They can then use the quick-build option to automatically generate a Delft-FIAT model, or they can use additional functionality to build a tailored Delft-FIAT model. Because the quick-build option does not require modeling experience, the model-builder makes the generation of Delft-FIAT models accessible to a wide audience.\nThis guide is organized in six sections:\nFigure¬†1 shows the Delft-FIAT model builder. There are seven tabs shown at the top. For generating an automatic Delft-FIAT model using open data, you will only need to use the first of these tabs, the ‚ÄúModel Boundary | Quick Build‚Äù tab. The remaining tabs are for tailoring your Delft-FIAT model and are described in the tailored Delft-FIAT model section.",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-getting-started-delft-fiat",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-getting-started-delft-fiat",
    "title": "Delft-FIAT model-builder",
    "section": "Getting started",
    "text": "Getting started\nThe initial steps to set up a Delft-FIAT model are the same whether you set up a quickbuild or tailored model. To get started building your Delft-FIAT model:\n\nOpen the Model Builder application; this contains functionality to build a SFINCS and a Delft-FIAT model\nClick ‚ÄúModel‚Äù in the top menu bar and choose ‚ÄúFIAT‚Äù\nClick ‚ÄúFile‚Äù in the top menu bar and choose ‚ÄúSelect Working Directory‚Äù\nSelect an existing folder or create a new one",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#model-boundary",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#model-boundary",
    "title": "Delft-FIAT model-builder",
    "section": "Model boundary",
    "text": "Model boundary\nThe Delft-FIAT model boundary encapsulates the area of interest where you want to calculate flood damages. To specify your model boundary, go to the Model Boundary | Quickbuild tab. In the ‚ÄúModel Boundary‚Äù box, you will select how you would like to specify your model boundary. There are four options:\n\nDraw polygon: Click on the map and draw a polygon. Double click when finished.\nDraw box: Click on the map and draw a box. Double click when finished.\nSFINCS model domain: If you already created a SFINCS model you can select the folder where your SFINCS model is saved. Do not select the region file itself. It will be recognized automatically when you select your SFINCS folder.\nUpload file: You can upload a boundary using a geospatial file (e.g.¬†.gpkg, .geojson).\n\nWhen you are finished, click ‚ÄúGenerate Boundary‚Äù, and your model area will be created.\n\n\n\n\n\n\nWhich model boundary option should I choose?\n\n\n\nWhen setting up FloodAdapt in a project area, you will also have to set up a SFINCS model for the flood estimation. You may want to have your damage model active everywhere where there will be flood information. If that is the case, choose the ‚ÄúSFINCS model domain‚Äù.\nSometimes the flood model extent is actually much larger than your area of interest (this is because water from outside your area of interest may still make its way to your area of interest). In this case, you can choose based on the following considerations:\n\nTo look at damages for an adminstative area like a city or a county, the best option would be to upload the city or county boundary shapefile using the ‚ÄúUpload file‚Äù option\nTo quickly get started if you don‚Äôt have a city or county shapefile on hand, you can draw a polygon or box in the map around the area you are interested in.\n\n\n\n\n\n\n\n\n\n\nWatch a video tutorial for selecting a model boundary with the ‚Äúdraw polygon‚Äù option",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-quickbuild",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-quickbuild",
    "title": "Delft-FIAT model-builder",
    "section": "Quick Build",
    "text": "Quick Build\nThe Quick Build option allows users to set up a Delft-FIAT model anywhere with ease; it doesn‚Äôt require any user input except for defining the model boundary. The quick build option sets up the exposure data for buildings and roads, and assigns the corresponding vulnerability curve to each asset. The model-builder also downloads equity data (income and population) for the equity-weighting functionality in FloodAdapt.\nTo use the quick build option to generate a Delft-FIAT model, simply click the ‚ÄúCreate model‚Äù button on the ‚ÄúModel Boundary | Quick Build‚Äù tab after generating your model boundary. That‚Äôs it!\n\n\n\n\n\n\nWhere does the data for the Quick Build option come from?\n\n\n\nThe Quick Build option uses open data from several sources.\nFor the United States, the data sources are:\n\nExposure: National Structure Inventory (NSI)\nVulnerability curves: FEMA HAZUS 4.0 SQL database, obtained through FEMA FAST repository\nSocio-economic/equity data: US census data\nRoads: Open Street Map (OSM)\n\nOutside the United States, the data sources are (note: no socio-economic data are downloaded by default outside of the U.S&gt;)\n\nExposure: Open Street Maps (OSM)\nVulnerability curves: Joint Research Centre\nRoads: Open Street Map (OSM)\n\n\n\n\n\n\n\n\n\n\nWatch a video tutorial for building a Delft-FIAT model with the Quick Build option",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-tailored_model",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#sec-tailored_model",
    "title": "Delft-FIAT model-builder",
    "section": "Tailored Delft-FIAT model",
    "text": "Tailored Delft-FIAT model\nUsing local data can help improve the accuracy of damage estimates and utility of infometrics. The Delft-FIAT model builder enables you to create a base model and then refine the model using available local data.\nWhen creating a tailored Delft-FIAT model, there are three mandatory steps. These are:\n\nSet up a base exposure dataset\nAdd vulnerability curves\nCreate your Delft-FIAT model\n\nIn addition to these mandatory steps, there are many options to refine data sources and default options. When creating a tailored Delft-FIAT model, you always start by building a base exposure dataset using open data, which can then be refined. The Delft-FIAT model tabs (see Figure¬†1) ‚Äî Exposure, Vulnerability, Equity, and Additional Attributes ‚Äî enable specific refinements, which are highlighted in the list below and detailed in the following sections.\n\nStep 1: Set up a base exposure dataset\nExposure updates \n\nUpdate finished floor heights of buildings\nUpdate the ground elevation at the asset locations\nUpdate the maximum potential damages (structure and content) of the assets\n\nVulnerability\n\nAssign default vulnerability curves\nChange vulnerability curves\n\nEquity\n\nAdd income and population data for equity-weighting in FloodAdapt\n\nAdditional Attributes\n\nAdd flexible attributes that are important for deriving metrics or visualizing in FloodAdapt\n\n\n\nCreate a base exposure dataset\nSimilar to the Quick Build option, the base exposure dataset is generated using open data. When your model is within the United States, National Structure Inventory data is used to generate the base exposure dataset for buildings, and open street map (OSM) is used to generate the data for roads. When your model is outside of the United States, OSM is used to generate the base exposure dataset for both buildings and roads.\nTo set up the base exposure dataset:\n\nGenerate your model boundary.\nOpen the ‚ÄúExposure‚Äù tab from the top panel. From the bottom panel select the ‚ÄúAsset Location‚Äù tab.\nSelect the correct data source for your model.\n\nFor a U.S. based model choose ‚ÄúStart with National Structure Inventory (NSI)‚Äù\nFor a model outside of the U.S. choose ‚ÄúStart with Open Street Map (OSM)‚Äù\n\nInclude road data by checking the checkbox ‚ÄúInclude OSM roads‚Äù.\nClick the button ‚ÄúAdd to model‚Äù.\n\n\n\n\n\n\n\nExtra settings for models outside the U.S.\n\n\n\nWhen choosing to start with open street map, the model-builder asks the user to specify a damage unit and a finished floor height.\n\nDamage unit (currency): Do not change the default currency from Euro to another currency. There is no currency converter tool implemented in the Delft-FIAT model builder yet.\nFinished floor height: OSM exposure data does not include this attribute. The user can select a single value that will be applied to all buildings. They can refine this later using spatial data.\n\n\n\n\n\n\n\n\n\n\nWatch a video tutorial for setting up a base exposure dataset for a Delft-FIAT model in the U.S.\n\n\n\n If this video is not visible for you, try this link\n\n\n\n\nUpdating exposure data\nThe Delft-FIAT model builder allows you to update the following exposure data, covered in the following sections. Click on any of the options to jump to that section:\n\nFinished floor heights\nGround elevation\nMaximum potential damages\n\n\nUpdating finished floor heights\nFinished floor heights refer to the height of the ground floor of a building above ground level. Damage estimates are sensitive to this attribute, and open data is either not available (in the case of OSM) or is not entirely reliable (in the case of NSI). When local data exists on building elevations, these can be incorporated in the Delft-FIAT model using the Delft-FIAT model-builder. The finished floor height data must be point or polygon data (e.g.¬†.gpkg, .geojson).\n\nTo refine the finished floor heights using the Delft-FIAT model-builder:\n\nOpen the Exposure tab from the top panel and select the Finished Floor Height tab in the bottom panel.\nClick the button ‚ÄúSelect Source‚Äù and choose the point or polygon file with your finished floor height data.\nClick the ‚ÄúLoad‚Äù button. This will load the data field names in your file into the ‚ÄúAttribute ID‚Äù drop-down menu.\nIn the ‚ÄúAttribute ID‚Äù drop-down menu, select the field name that corresponds to your finished floor height data.\nClick ‚ÄúAdd to model‚Äù.\n\n\n\n\n\n\n\nOptional settings for spatially joining exposure points and finished floor height data\n\n\n\nIn the ‚ÄúFinished Floor Height‚Äù tab there is a ‚ÄúSettings‚Äù button. This allows you to change default choices related to the spatial join of the exposure data points and the uploaded finished floor height data. Default settings use the nearest method for points and the intersection method for polygons when doing the spatial join. The default maximum distance for the nearest method is 10 meters.\n\n\n\n\n\n\n\n\nWatch a video tutorial for updating the finished floor height of buildings in your Delft-FIAT model\n\n\n\n\n\n\n\n\nUpdating ground elevation\nTo update ground elevation data, you must provide a digital elsevation model (DEM) raster file. The Delft-FIAT model builder calculates the mean elevation within the shape of each asset and assigns this value to the associated asset.\n\n\n\n\n\n\nImportant note for those who will use the FloodAdapt database builder\n\n\n\nIf you will use the FloodAdapt database builder to create your FloodAdapt database, it will automatically overwrite the ground elevation data in your Delft-FIAT model to match what is in your SFINCS model, so you do not need to do that manually here!\n\n\n\nTo update the ground elevation values in your Delft-FIAT model:\n\nOpen the Exposure tab on the top panel and select the Ground Elevation tab in the bottom panel.\nSelect a ground elevation source. There are two options in the drop-down menu:\n\nSFINCS Ground Elevation\n\nIf you have already a SFINCS model set up, select the folder that contains your SFINCS model. The Delft-FIAT model builder knows the location of the DEM file within this folder.\n\nUpload file\n\nSelect a DEM raster file\nSelect the elevation unit for your DEM (meters or feet).\n\n\nClick ‚ÄúAdd to model‚Äù.\n\n\n\nUpdating maximum potential damages\nWhen local data is available on maximum potential values, either for content or structure, these can be incorporated in the Delft-FIAT model using the Delft-FIAT model-builder. The maximum potential damages you want to use must be point or polygon data. Point data would be for asset-level information, and polygon data would be for cases where you want to assign the same values to a larger area. It is necessary to distinguish between structure and content maximum potential damages, as these are treated separately in the damage calculation.\n\nTo update the maximum potential damages:\n\nOpen the Exposure tab on the top panel and select the Max Potential Damages tab in the bottom panel.\nClick ‚ÄúSelect source‚Äù and select the file containing your maximum potential damage data (point or polygon data)\nClick ‚ÄúLoad‚Äù. This will load the data columns in your file into the ‚ÄúAttribute ID‚Äù drop-down menu.\nSelect the column that holds the max. potential damage data.\nSelect the damage type you wish to update, either ‚Äústructure‚Äù or ‚Äúcontent‚Äù.\nAdd to model.\n\n\n\n\n\n\n\nOptional settings for spatially joining exposure points and maximum potential damages\n\n\n\nIn the ‚ÄúMax Potential Damages‚Äù tab there is a ‚ÄúSettings‚Äù button. This allows you to change default choices related to the spatial join of the exposure data points and the uploaded finished floor height data. Default settings use the nearest method for points and the intersection method for polygons when doing the spatial join. The default maximum distance for the nearest method is 10 meters.\n\n\n\n\n\nVulnerability curves\nDelft-FIAT uses vulnerability curves (also known as depth-damage curves) to relate inundation depths to a fraction of total damage. Each building type can have a different depth-damage curve. Delft-FIAT accepts any user-selected or defined depth-damage curve. To make it easy for users to quickly set up a Delft-FIAT model, there is a default damage curve assignment in the Delft-FIAT model-builder. Figure¬†2 shows the selection of default depth-damage curves (for structure damage) for buildings in the United States. This selection can be changed by the user. To assign the default damage curves, you only need to do the following two steps:\n\nOpen the Vulnerability tab on the top panel. The default damage curves are already selected.\nClick ‚ÄúAdd to model‚Äù\n\n\n\n\n\n\n\nFigure¬†2: Default selection of structure depth-damage curves for Delft-FIAT models built in locations in the United States. More discussion about this default selection will be coming soon as will an overview of the default curves for content\n\n\n\n\nUpdating vulnerability curves\nIf you are building your model in the U.S., you can change the damage curve assignment. Updating damage curves is currently only possible in the U.S. The functionality is facilitated by the alignment between HAZUS damage curves and the secondary object types in the National Structure Inventory (see secondary object types in Figure¬†3). Users can only choose new damage curve assignments from existing damage curves within the HAZUS damage curve database. User-defined damage curves are currently not possible from within the Delft-FIAT model builder. Future releases of the Delft-FIAT model builder may offer more flexibility.\n\nHow to change the damage curve assignment (U.S. only):\n\nOpen the Vulnerability tab on the top panel\nClick ‚ÄúSpecify different damage curves‚Äù. A pop-up window appears. In the pop-up window:\n\nSelect from the left panel the secondary object type for which you want to change the damage curve\nSelect a damage curve from the upper right panel (source is HAZUS database); the damage curve will be plotted in the lower right panel\nClick ‚ÄúSelect Source‚Äù underneath the upper right panel to assign the selected damage curve.\nContinue the above procedure for all secondary object types for which you would like to change the curve.\nWhen finished, click ‚ÄúOK‚Äù to close the pop-up window.\n\nClick ‚ÄúAdd to model‚Äù to complete.\n\n\n\n\n\n\n\nFigure¬†3: Secondary occupancy type definitions from the HAZUS technical manual, Table 3.2. Note: ‚Äúoccupancy class‚Äù and ‚Äúobject type‚Äù are used interchangeably.\n\n\n\n\n\n\n\n\n\n\nWatch a video tutorial for changing depth-damage curves for a U.S. Delft-FIAT model\n\n\n\n\n\n\n\n\n\nEquity\nFloodAdapt allows you to evaluate equity-weighted damages and benefits. To prepare the income and population data needed to calculate equity weights, per capita income and population are obtained from the U.S. Census Bureau at the block group scale. Adding this data to your Delft-FIAT model is easy, and described in the steps below:\n\nOpen the Equity tab on the top panel.\nIn the bottom panel, specify the year you for which census data will be downloaded.\nCheck the checkbox to download Equity data.\nClick ‚ÄúAdd to model‚Äù\n\n\n\nAdditional Attributes\n\nFloodAdapt allows users to tailor-define metrics that will be automatically calculated when scenarios are run. An example metric is ‚Äúnumber of homes impacted for families with low income brackets‚Äù, or ‚Äúnumber of homes impacted who live in a FEMA flood zone‚Äù. To facilitate the calculation of tailored metrics, additional layers (in these examples, a spatial income layer or a FEMA flood zone map) can be added to your Delft-FIAT model. Any additional layer (e.g.¬†landuse, administrative boundaries) can be added to your model.\n\nTo add an additional attribute layer to your model:\n\nOpen the Additional Attributes tab on the top panel.\nClick ‚ÄúSelect source‚Äù and choose your file.\nClick ‚ÄúLoad‚Äù. This will load the data columns in your file into the ‚ÄúAttribute ID‚Äù drop-down menu.\nFrom the ‚ÄúAttribute ID‚Äù drop-down, select the attribute you wish to add to your model.\nAdd a name in the ‚ÄúLabel‚Äù box. This label will be the column name of your attribute in the Delft-FIAT exposure (and output) data.\nClick ‚ÄúAdd‚Äù. The layer will appear in the table in the ‚ÄúOverview attribute‚Äù table.\nIn the bottom of the ‚ÄúOverview attribute‚Äù panel, you can check the ‚ÄúDisplay Attribute‚Äù checkbox to verify your data was added correctly.\nYou can repeat this process for as many layers as you wish.\nWhen finished adding layers, click ‚ÄúAdd to model‚Äù.\n\n\n\n\n\n\n\n\nWatch a video tutorial for adding additional attributes to your Delft-FIAT model\n\n\n\n\n\n\n\n\nCreate model\nAt this point you are ready to create your Delft-FIAT model. Open the Create Model tab on the top panel and verify the data sources in the bottom tab are as expected. If so, click ‚ÄúCreate Delft-FIAT model‚Äù.",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#visualize-your-model",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#visualize-your-model",
    "title": "Delft-FIAT model-builder",
    "section": "Visualize your model",
    "text": "Visualize your model\nOnce you have created your model, you can visualize different model attributes on the View Model tab. The attributes that can be displayed in the map window are:\n\nAsset classification (primary or secondary)\nFinished floor height\nMax potential damages (structure or content)\nGround elevation\nAdditional attributes\nRoads\n\nThere is also a button ‚ÄúExposure output‚Äù. This opens the full model data, which is also stored as a CSV in the model output folder. This allows you to quickly view the complete dataset without having to look for the file on your computer.",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#delft-fiat-model-folder-structure",
    "href": "3_setup_guide/Delft_Fiat/hydromt_fiat_gui.html#delft-fiat-model-folder-structure",
    "title": "Delft-FIAT model-builder",
    "section": "Delft-FIAT model folder structure",
    "text": "Delft-FIAT model folder structure\nOnce you have created your model, the model folder you specified when you chose your working directory in the getting started step will be populated with the Delft-FIAT model files. Below you can see what the folder structure looks like for a comprehensive model, saved in a working directory named ‚ÄúDelft-FIAT‚Äù. When you create a basic model (without using QuickBuild or any advanced options), the resulting folder structure will contain fewer folders and files. The additional folders and files that appear when using QuickBuild or adding additional attributes to your model are highlighted in the figure below, indicating that the folders (incl.¬†files within) are generated only under those specific conditions.\n‚îú‚îÄ‚îÄ‚îÄüìÅ Delft-FIAT/\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ exposure/\n    ‚îÇ      ‚îú‚îÄ‚îÄ‚îÄüìÅ additional_attributes/ (advanced model)\n    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ‚îÄ üìÑ base_zone.gpkg\n    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ‚îÄ üìÑ land_use.gpkg\n        ‚îÇ     ‚îú‚îÄ‚îÄ‚îÄüìÅ aggregation_areas/ (quickbuild/advanced model)\n    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ‚îÄ üìÑ block_groups.gpkg\n        ‚îÇ     ‚îú‚îÄ‚îÄ‚îÄüìÅ equity/ (quickbuild/advanced model)\n    ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ‚îÄ üìÑ equity_data.gpkg\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ buildings.gpkg\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ exposure.csv\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ region.gpkg\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ roads.gpkg\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ vulnerability/\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ vulnerability_curves.csv\n    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄüìÑ vulnerability_identifiers.csv\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ hazard/\n    ‚îÇ\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ output/\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÑ hydromt.log\n    ‚îú‚îÄ‚îÄ‚îÄüìÑ settings.toml\n    ‚îî‚îÄ‚îÄ‚îÄüìÑ spatial_joins.toml (quickbuild/advanced model)",
    "crumbs": [
      "Delft FIAT Setup",
      "Delft-FIAT model-builder"
    ]
  },
  {
    "objectID": "2_installation_guide/software_req.html",
    "href": "2_installation_guide/software_req.html",
    "title": "CFRSS system requirements",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "2_installation_guide/index.html",
    "href": "2_installation_guide/index.html",
    "title": "Getting started with FloodAdapt",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_introduction/terminology.html",
    "href": "1_introduction/terminology.html",
    "title": "Terminology",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_introduction/overview_floodadapt.html",
    "href": "1_introduction/overview_floodadapt.html",
    "title": "Overview of FloodAdapt",
    "section": "",
    "text": "FloodAdapt is a flood adaptation decision-support tool, which aims to advance and accelerate flooding-related adaptation planning. It integrates rapid, physics-based compound flood modeling and detailed impact modeling into a user-friendly system, ensuring accessibility for end-users, regardless of their technical backgrounds. This enables users to define and evaluate meaningful ‚Äúwhat-if‚Äù scenarios, which can be combinations of weather events, climate or socio-economic future conditions, and adaptation strategies. FloodAdapt rapidly generates high-quality flood and impact maps, equity-focused aggregations, and informative metrics, providing valuable support for planning and facilitating genuine stakeholder engagement. Beyond its usefulness for end-users, FloodAdapt acts as a vital bridge between scientific advancements and practical needs, enhancing the adoption and impact of adaptation research and development.\n\nFloodAdapt was developed as a rapid planning tool with a straightforward graphical user interface for scenario generation, simulation, and visualization of spatial flooding and flooding impacts. Decision-making needs at the community level were central to the design of FloodAdapt. Users can answer planning questions like: ‚ÄúHow will potential adaptation options reduce flood impacts?‚Äù, ‚ÄúHow will those options perform for different types of events, like hurricanes, king tides, or heavy rainfall?‚Äù, ‚ÄúWhich neighborhoods will benefit most?‚Äù, ‚ÄúHow will those options hold up in the future?‚Äù\nUsers specify what-if scenarios composed of historic or synthetic weather events, climate or socio-economic future projections, and adaptation measures. They are able to evaluate flooding and impacts due to compound weather events, like hurricanes, king tides, and rainfall events. Users can evaluate flooding, impacts, and risk considering user-specified projections of sea level rise, precipitation increase, storm frequency increase, population growth, and economic growth. They can also test out adaptation options, like sea walls, levees, pumps, urban green infrastructure, home elevations, buyouts and floodproofing.\nThe backend of FloodAdapt leverages the open-source, state-of-the-art process-based compound flood model SFINCS that can accurately predict compound flooding due to surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. The damage model included in FloodAdapt is the Deltares-developed flood impact assessment tool Delft-FIAT. It calculates the flood damages to individual buildings and roads, and ‚Äì when social vulnerability data is available ‚Äì aggregates these damages over vulnerability classes.\nWhen a user specifies a what-if scenario, the backend of FloodAdapt automatically makes changes to the SFINCS and Delft-FIAT models to represent the user choices, the way an expert modeller would. It then simulates the scenario and returns flood and impact maps, scenario comparison visualizations, summary metrics, and an infographic to highlighting flooding or impacts of particular concern to a community. In this way, FloodAdapt allows end-users to unleash the power of advanced models without requiring the technical background, or the laborious pre- and post-processing of models that is usually required for this type of analysis.\n\n\n\n\n\n\nFigure¬†1: Schematic showing the design concepts behind the FloodAdapt software\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "1_introduction/index.html",
    "href": "1_introduction/index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to the FloodAdapt documentation!\nIn this introduction, you will find an overview of FloodAdapt, information on its intended uses, and reader guidance explaining the information you will find in this documentation."
  },
  {
    "objectID": "1_introduction/index.html#overview",
    "href": "1_introduction/index.html#overview",
    "title": "Introduction",
    "section": "Overview",
    "text": "Overview\nFloodAdapt is a flood adaptation decision-support tool, which aims to advance and accelerate flooding-related adaptation planning. It integrates rapid, physics-based compound flood modeling and detailed impact modeling into a user-friendly system, ensuring accessibility for end-users, regardless of their technical backgrounds. This enables users to define and evaluate meaningful ‚Äúwhat-if‚Äù scenarios, which can be combinations of weather events, climate or socio-economic future conditions, and adaptation strategies. FloodAdapt rapidly generates high-quality flood and impact maps, equity-focused aggregations, and informative metrics, providing valuable support for planning and facilitating genuine stakeholder engagement. Beyond its usefulness for end-users, FloodAdapt acts as a vital bridge between scientific advancements and practical needs, enhancing the adoption and impact of adaptation research and development.\n\n\nFloodAdapt was developed as a rapid planning tool with a straightforward graphical user interface for scenario generation, simulation, and visualization of spatial flooding and flooding impacts. Decision-making needs at the community level were central to the design of FloodAdapt. Users can answer planning questions like: ‚ÄúHow will potential adaptation options reduce flood impacts?‚Äù, ‚ÄúHow will those options perform for different types of events, like hurricanes, king tides, or heavy rainfall?‚Äù, ‚ÄúWhich neighborhoods will benefit most?‚Äù, ‚ÄúHow will those options hold up in the future?‚Äù\nUsers specify what-if scenarios composed of historic or synthetic weather events, climate or socio-economic future projections, and adaptation measures. They are able to evaluate flooding and impacts due to compound weather events, like hurricanes, king tides, and rainfall events. Users can evaluate flooding, impacts, and risk considering user-specified projections of sea level rise, precipitation increase, storm frequency increase, population growth, and economic growth. They can also test out adaptation options, like sea walls, levees, pumps, urban green infrastructure, home elevations, buyouts and floodproofing.\nThe backend of FloodAdapt leverages the open-source, state-of-the-art process-based compound flood model SFINCS that can accurately predict compound flooding due to surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. The damage model included in FloodAdapt is the Deltares-developed open-source flood impact assessment tool Delft-FIAT. It calculates the flood damages to individual buildings and roads, and ‚Äì when social vulnerability data is available ‚Äì aggregates these damages over vulnerability classes.\nWhen a user specifies a what-if scenario, the backend of FloodAdapt automatically makes changes to the SFINCS and Delft-FIAT models to represent the user choices, the way an expert modeller would. It then simulates the scenario and returns flood and impact maps, scenario comparison visualizations, summary metrics, and an infographic to highlighting flooding or impacts of particular concern to a community. In this way, FloodAdapt allows end-users to unleash the power of advanced models without requiring the technical background, or the laborious pre- and post-processing of models that is usually required for this type of analysis.\n\n\n\n\n\n\nFigure¬†1: Schematic showing the design concepts behind the FloodAdapt software"
  },
  {
    "objectID": "1_introduction/index.html#intended-uses-of-floodadapt",
    "href": "1_introduction/index.html#intended-uses-of-floodadapt",
    "title": "Introduction",
    "section": "Intended Uses of FloodAdapt",
    "text": "Intended Uses of FloodAdapt\nFloodAdapt was developed to support adaptation and resilience planning, to provide community understanding of the flooding and impacts resulting from different scenarios of interest, to understand the urgency of actions in different areas, to aid in prioritizing investments, and to assess the effectiveness and longevity of different adaptation options.\nFloodAdapt is a powerful and physics-based system that can provide realistic flood and impact responses for user-defined scenarios. This is important because accuracy builds community trust in the tool. The underlying models and data in FloodAdapt can be continuously improved by the local or regional agencies who are operating it. The accuracy of the model results will depend on the accuracy of the input data. FloodAdapt can also help illuminate which data are missing or need improvement and should be collected when resources allow.\nFloodAdapt is not intended for use in the detailed engineering design of adaptation measures, particularly hydraulic ones. Once FloodAdapt has helped the community identify strategies and priority areas for improvements, the specific design requirements for these strategies should be done using more comprehensive modeling tools available. These may need to include detailed drainage infrastructure systems, groundwater, or other components not currently built into FloodAdapt."
  },
  {
    "objectID": "1_introduction/index.html#reader-guidance",
    "href": "1_introduction/index.html#reader-guidance",
    "title": "Introduction",
    "section": "Reader Guidance",
    "text": "Reader Guidance\nFloodAdapt is intended for end-users who have some technical background, but do not need to be subject-matter experts in flood and impact modeling. Setting up FloodAdapt in a new location requires additional capabilities.\n\nUser Guide The user guide provides information on how to get started with FloodAdapt, and describes how to use all the FloodAdapt functionalities.\nSetup Guide - The setup guides users in setting up FloodAdapt in their area of interest.\nTechnical docs - The technical docs provide detailed information on the calculation methods within FloodAdapt."
  },
  {
    "objectID": "1_introduction/intended_use.html",
    "href": "1_introduction/intended_use.html",
    "title": "Intended use of FloodAdapt",
    "section": "",
    "text": "FloodAdapt was developed to support adaptation and resilience planning, to provide community understanding of the flooding and impacts resulting from different scenarios of interest, to understand the urgency of actions in different areas, to prioritize investments, and to assess the effectiveness and longevity of different adaptation options.\nFloodAdapt is a powerful and physics-based system that can provide realistic flood and impact responses for user-defined scenarios. This is important because accuracy builds community trust in the tool. The underlying models and data in FloodAdapt can be continuously improved by the local or regional agencies who are operating it. The accuracy of the model results will depend on the accuracy of the input data. FloodAdapt can also help illuminate which data are missing or need improvement and should be collected when resources allow.\nFloodAdapt is not intended for use in the detailed engineering design of adaptation measures, particularly hydraulic ones. Once FloodAdapt has helped the community identify strategies and priority areas for improvements, the specific design requirements for these strategies should be done using more comprehensive modeling tools available. These may need to include detailed drainage infrastructure systems, groundwater, or other components not currently built into FloodAdapt.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_introduction/reader_guidance.html",
    "href": "1_introduction/reader_guidance.html",
    "title": "Reader Guidance",
    "section": "",
    "text": "FloodAdapt is intended for end-users who have some technical background, but do not need to be subject-matter experts in flood and impact modeling. Set-up of FloodAdapt and developing a set of events and probabilities for risk assessment require additional capabilities. Figure¬†1 provides a reading guide for this documentation. It shows the intended reader and the relative technical skills required for the different sections in this documentation.\nThe Setup Guide is intended for those who will ‚Äúbuild‚Äù or configure FloodAdapt for a new site and set of end-users.\nThe Installation Guide helps an end-user get FloodAdapt installed and ready to run on their machine and explains the folder structure of FloodAdapt.\nThe User Guide walks the user through all the functionality of FloodAdapt.\nThe section on Updating FloodAdapt describes the steps involved in updating the database of FloodAdapt. This would be done whenever new or improved data becomes available.\nChapter 6 provides a demonstration of a CFRSS application, to help the reader understand how FloodAdapt can support adaptation and resilience planning. Appendix A is a technical write-up walking a user through the preparation of a probabilistic event set for calculating risk with FloodAdapt. A tutorial video has been prepared that aligns with the demonstration in Chapter 6 and can be found at the following link: Add link.\n\n\n\n\n\n\nFigure¬†1: Guidance to this documentation, showing the different sections, the intended reader, and an indicator of the relative technical skill required to make use of the section\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "2_installation_guide/folder_struct.html",
    "href": "2_installation_guide/folder_struct.html",
    "title": "Folder Structure",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "2_installation_guide/installation.html",
    "href": "2_installation_guide/installation.html",
    "title": "Installation steps",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "2_installation_guide/system_req.html",
    "href": "2_installation_guide/system_req.html",
    "title": "CFRSS system requirements",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/index.html",
    "href": "3_setup_guide/Delft_Fiat/index.html",
    "title": "Delft-FIAT",
    "section": "",
    "text": "Delft-FIAT is the open-source flood impact model implemented in FloodAdapt. When setting up FloodAdapt in a new location, it is required to first set up a Delft-FIAT model in the project area. This is considered the ‚Äòbaseline‚Äô Delft-FIAT model, which FloodAdapt users can then modify through the FloodAdapt user interface - for example, by elevating buildings. To facilitate the setup of a Delft-FIAT model, the Delft-FIAT model-builder was created.\nFigure¬†1 shows the flood impact modeling concept on which Delft-FIAT is based. It relates a hazard (the flood waters), exposure (buildings or roads that might be flooded), and vulnerability (the propensity of assets to be damaged when flooded).\nFigure¬†2 illustrates how damages are calculated in Delft-FIAT. The steps involved in a Delft-FIAT calculation are:\nDelft-FIAT is considered a ‚Äòcalculation engine‚Äô, which means it is designed to make damage calculations, but does not come prepopulated with data. When we say ‚Äòsetting up a Delft-FIAT model‚Äô for a project location, this refers to collecting and formatting exposure and vulnerability data for the area. This document provides an overview of the data needed to set up a Delft-FIAT model, and a user guide on how to build a Delft-FIAT model in your project location using the Delft-FIAT model-builder. This model-builder makes it easy to rapidly prepare a Delft-FIAT model using open data, but also supports tailored model-building by allowing you to bring in local or more accurate data when available.",
    "crumbs": [
      "Delft FIAT Setup"
    ]
  },
  {
    "objectID": "3_setup_guide/Delft_Fiat/index.html#overview-of-delft-fiat-data-requirements",
    "href": "3_setup_guide/Delft_Fiat/index.html#overview-of-delft-fiat-data-requirements",
    "title": "Delft-FIAT",
    "section": "Overview of Delft-FIAT data requirements",
    "text": "Overview of Delft-FIAT data requirements\nThis section describes the exposure and vulnerability requirements to set up a Delft-FIAT model.\nThe exposure data describe the assets within a project area. Figure¬†3 shows the types of exposure data needed (and also optionally accepted) to set up a Delft-FIAT model.\n\n\n\n\n\n\nFigure¬†3: Exposure data used to build a Delft-FIAT model - including both required and optional fields\n\n\n\n\n\n\n\n\n\nWhy are some data optional?\n\n\n\nThe optional socio-economic variables and aggregation areas are used by FloodAdapt to post-process the damages to gain insight into how damages are distributed spatially or by social-economic sectors (such as damages to high social vulnerability residents). They are very useful for gaining insight, but not required; if they are not provided, FloodAdapt users will still be able to use all of the FloodAdapt functionality.\nThe secondary occupancy type can be optional, but will sometimes be required. The primary and secondary occupancy types tell Delft-FIAT which depth-damage curves should be used for which building. When the depth-damage curves are defined by the secondary occupancy type, this will be a required input. This is the case when using HAZUS damage curves. When using other damage curves, such as those from the Joint Research Center, which are identified only on primary object type, the secondary object type will be optional.\n\n\nVulnerability data in Delft-FIAT are captured in depth-damage curves. These translate inundation depths at an asset to a fraction of total damage (Figure¬†4). The depth-damage curve is related to the building type (e.g.¬†‚Äòresidential 1-story building‚Äô) and the inundation depth during a flood event. Different types of assets incur different degrees of damage at varying inundation levels.\n\n\n\n\n\n\nFigure¬†4: Example of depth-damage functions",
    "crumbs": [
      "Delft FIAT Setup"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/index.html",
    "href": "3_setup_guide/SFINCS/index.html",
    "title": "Setting up a SFINCS model",
    "section": "",
    "text": "SFINCS is an open-source model for simulating compound flooding that can be integrated into the FloodAdapt platform. To set up FloodAdapt in a new location, you first need to create a SFINCS model for the project area. This initial model, called the ‚Äúbaseline‚Äù SFINCS model, can then modified through FloodAdapt‚Äôs user interface to simulate scenarios such as hurricanes or synthetic events, and include future conditions like sea level rise.\nSFINCS is designed to simulate compound flooding caused by various drivers, including storm surge, tides, rainfall, and river discharge (Figure¬†1). A fully functional FloodAdapt setup typically includes two SFINCS models:\nIn some scenarios (e.g., historical events with gauged water levels or synthetic events), the offshore model isn‚Äôt required. Instead, tide gauge data or synthetic water level signals are directly imposed at the overland model‚Äôs water level boundary.",
    "crumbs": [
      "SFINCS Setup"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/index.html#components-of-a-sfincs-model",
    "href": "3_setup_guide/SFINCS/index.html#components-of-a-sfincs-model",
    "title": "Setting up a SFINCS model",
    "section": "Components of a SFINCS Model",
    "text": "Components of a SFINCS Model\nA SFINCS model is comprised of three key components:\n\nModel grid: The spatial framework for simulations.\nTopography and bathymetry data: These are mapped to the grid to define the terrain and underwater features.\nInitial and boundary conditions: Describe starting water levels and how they change over time at model boundaries (or throughout the domain with respect to rainfall, or at a source point with respect to river discharge).\n\nUsing this information, SFINCS calculates water levels within the model boundaries and saves the maximum inundation results mapped throughout the model area and time series of water levels at selected points.\nThe SFINCS Model-Builder tool simplifies the creation of SFINCS models for FloodAdapt. It allows users to:\n\nCreate the model grid\nMap topography and bathymetry data to the grid\nDefine active cells\nDefine the water level boundaries\nDefine boundary points for offshore-overland model communication\nDefine discharge points for river discharge\n\nFigure¬†2 is a schematic overview of the SFINCS model components:\n\n\n\n\n\n\nFigure¬†2: Components of a SFINCS model created using the SFINCS model-builer",
    "crumbs": [
      "SFINCS Setup"
    ]
  },
  {
    "objectID": "3_setup_guide/SFINCS/index.html#sfincs-data-requirements",
    "href": "3_setup_guide/SFINCS/index.html#sfincs-data-requirements",
    "title": "Setting up a SFINCS model",
    "section": "SFINCS Data Requirements",
    "text": "SFINCS Data Requirements\nAfter installing the FloodAdapt Model-Builder, the following folder structure is created:\n‚îú‚îÄ‚îÄ‚îÄüìÅ FloodAdaptModelBuilder/\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ _internal/\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüìÅ data/\n    ‚îÇ   ‚îÇ\n    |   ‚îú‚îÄ‚îÄ‚îÄüìÅ topobathy/\n    |   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄüìÑ dem.tif\n    |   ‚îî‚îÄ‚îÄ‚îÄüìÅ watersheds/\n    |       ‚îî‚îÄ‚îÄ‚îÄüìÑ watersheds.gpkg\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüîµ FloodAdaptModelBuilder.exe\n    |\n    ‚îú‚îÄ‚îÄ‚îÄüîµ unins000.dat\n    |\n    ‚îî‚îÄ‚îÄ‚îÄüîµ unins000.exe\nFor full functionality, users must provide:\n\nDEM (Digital Elevation Model): a .tif file named dem.tif in the topobathy folder.\nWatersheds Geopackage: A .gpkg file named watersheds.gpkg in the watersheds folder.\n\nFor detailed instructions on creating a SFINCS model using the Model-Builder tool, continue to the SFINCS model-builder documentation.",
    "crumbs": [
      "SFINCS Setup"
    ]
  },
  {
    "objectID": "3_setup_guide/index.html",
    "href": "3_setup_guide/index.html",
    "title": "Setup Guide",
    "section": "",
    "text": "The FloodAdapt application can be freely downloaded and used in any coastal community. However, for FloodAdapt to operate, it requires a site-specific database. The FloodAdapt database must contain at minimum an overland flood model (currently the open-source compound flood SFINCS model is supported), a flood impact model (currently the open-source Delft-FIAT model is supported), and some site specific information such as the name and location of the site. The amount of information included in the FloodAdapt database will determine the degree to which its functionalities will be activated (this is described in detail in the database setup section). Most notably, to be able to run risk and benefit calculations, an event set must be prepared.\nTo make it easier for communities to get started with FloodAdapt, supporting tools and guidance have been created. This setup guide walks a technical user through the setup process for FloodAdapt, focusing on three key database ingredients: The SFINCS model, the Delft-FIAT model, and the probabilistic event set for risk analysis. Model-builder software has been created to prepare a SFINCS and Delft-FIAT model, built on open-source model-building functionalities for these two software products. Software was also developed to create the FloodAdapt database once The SFINCS and Delft-FIAT models have been set up. Figure¬†1 shows the workflow for getting a FloodAdapt system operational in a new community. The preparation of the event set is optional. FloodAdapt will be able to run event scenarios with full functionality without an event set.\nThe setup guide consists of the following sections:"
  },
  {
    "objectID": "3_setup_guide/index.html#installation-of-setup-tools",
    "href": "3_setup_guide/index.html#installation-of-setup-tools",
    "title": "Setup Guide",
    "section": "Installation of setup tools",
    "text": "Installation of setup tools\nTo download and install the FloodAdapt model-builder on your computer:\n\nDownload the FloodAdapt model-builder installer from the Deltares USA website.\nDouble-click the ‚ÄúFloodAdaptModelBuilder_Installer‚Äù file and the setup wizard will open (see Figure¬†2). Follow the steps of the installation wizard.\n\n\n\n\n\n\n\nFigure¬†2: FloodAdapt model-builder installation setup wizard\n\n\n\n\nGuidance how to use the model-builder software to build a SFINCS model is provided in the SFINCS setup guide and guidance to use the software to build a Delft-FIAT model is provided in the Delft-FIAT setup guide\n\nTo download and install the FloodAdapt database builder on your computer:\n\nDownload the FloodAdapt database-builder executable from the Deltares USA website.\nThe database-builder is an executable file and does not require any installation. Just double-click to use it.\nGuidance how to use the database-builder is provided in the Database Builder guide"
  },
  {
    "objectID": "4_user_guide/arc_gis/index.html",
    "href": "4_user_guide/arc_gis/index.html",
    "title": "ArcGis",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/compare/Compare_map.html",
    "href": "4_user_guide/compare/Compare_map.html",
    "title": "Scenario comparison - map",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/compare/index.html",
    "href": "4_user_guide/compare/index.html",
    "title": "Compare tabs",
    "section": "",
    "text": "Being able to compare scenarios is important when addressing user questions. For example, consider the question ‚ÄúHow would a historic storm look with sea evel rise?‚Äù This question is best answered by simulating the historic storm without and then with sea level rise and comparing the output to evaluate where and by how much flooding and impacts would increase.\nFloodAdapt supports users in comparing scenarios with two comparison tabs, one to compare spatial output and one to compare scenario metrics. These are described in separate sections below.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "4_user_guide/compare/index.html#comparing-spatial-output",
    "href": "4_user_guide/compare/index.html#comparing-spatial-output",
    "title": "Compare tabs",
    "section": "Comparing spatial output",
    "text": "Comparing spatial output\nThe ‚ÄúCompare - map‚Äù tab in FloodAdapt (see Figure¬†1) allows users to compare the spatial output of two scenarios using a slider bar in the map window. The lower panel has two selection boxes, one to select the scenario that will show up on the left side of the slider bar, and one to select the scenario that will show up on the right side of the slider bar.\nTo compare the spatial output of two scenarios:\n\nGo to the ‚ÄúCompare - map‚Äù tab\nSelect a scenario in the ‚ÄúScenario left‚Äù selection box\nSelect a scenario in the ‚ÄúScenario right‚Äù selection box\nSelect the map layers you wish to view\nIn the map window, drag the slider bar left and right to compare the spatial output\n\n\n\n\n\n\n\nFigure¬†1: Comparing map outputs for two scenarios. This example shows a compound high-tide and rainfall event from 2023 without sea level rise (left scenario) and with sea level rise (right scenario)\n\n\n\n\n\n\n\n\n\nAutomatic scenario filtering\n\n\n\nOnce a selection is made in the ‚ÄúScenario left‚Äù selection box, the ‚ÄúScenario right‚Äù selection box will update to only include scenarios of the same type - either a risk scenario or event scenario. Because the output differs between these scenario types, only scenarios of the same type can be compared.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "4_user_guide/compare/index.html#comparing-output-metrics",
    "href": "4_user_guide/compare/index.html#comparing-output-metrics",
    "title": "Compare tabs",
    "section": "Comparing output metrics",
    "text": "Comparing output metrics\nIn addition to comparing the spatial output, it is informative to compare scenario output metrics, such as residential damages or the number of businesses impacted. This helps summarize the impacts and how they are changing under different scenarios.\nThe ‚ÄúCompare - table‚Äù tab (see Figure¬†2) allows users to select multiple scenarios and add them to a metrics comparison box. There is no limit on the number of scenarios that can be compared.\nTo compare scenario output metrics:\n\nSelect a scenario in the scenario selection box\nClick the ‚ÄúAdd‚Äù button\nRepeat the above steps until all of the scenarios you wish to compare are included in the metric comparison box\n\nIf you want to remove a scenario from the metric comparison box:\n\nSelect the column of the scenario in the metric comparison box\nClick the ‚ÄúRemove‚Äù button\n\n\n\n\n\n\n\nFigure¬†2: Comparing metrics outputs for multiple scenarios. This example shows the metrics for current risk, risk with 1 foot of sea level rise, and risk with 1 foot of sea level rise and a flood wall implemented.\n\n\n\n\n\n\n\n\n\nAutomatic scenario filtering\n\n\n\nSimilar to the spatial comparison tab, once a scenario has been added to the metric comparison box, the scenario selection box will update to only include scenarios of the same type - either a risk scenario or an event scenario. Because the output differs between these scenario types, only scenarios of the same type can be compared.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_gauged.html",
    "href": "4_user_guide/events/historic_events/historic_events_gauged.html",
    "title": "Historical event with gauged water levels",
    "section": "",
    "text": "Watch our video - historical event using gauged water levels\n\n\n\nDon‚Äôt feel like reading? No problem! Check out our video about how to add a historical (gauged) event in FloodAdapt.\nWhen the user selects the ‚ÄúHistorical event - using gauged water levels‚Äù option from the Events tab, they will see the event template window shown in Figure¬†1. This window allows the user to input the historic time series for:",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event with gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_gauged.html#water-levels",
    "href": "4_user_guide/events/historic_events/historic_events_gauged.html#water-levels",
    "title": "Historical event with gauged water levels",
    "section": "Water levels",
    "text": "Water levels\n\n\n\n\n\n\nWhat do we mean: Water levels, tide, and surge\n\n\n\nIn this documentation, we refer to water levels as the combined effect of (1) astronomoical tide and (2) the surge caused by wind.\n\n\nIf the user wants to download water levels automatically from gauge data they should:\n\nSelect a start and stop time for the event\nClick the button ‚ÄúDownload Observed Water Levels‚Äù\n\nThe plot window will then show the time series of the water levels over the duration specified by the start and stop time (see example in Figure¬†1).\nAlternatively, a user can import a water level time series. The water level time series should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, and the second column contains the water level relative to mean sea level (MSL). The units of the water level will depend on how the system is configured. In the event specification window, you will find an ‚Äúi‚Äù button next to the option to import a time series. Clicking this button will display an example of the format required for the csv, including the water level units.\n\n\n\n\n\n\nFigure¬†2: Example of the ‚Äúrequired format‚Äù popup for water levels when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event with gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_gauged.html#rainfall",
    "href": "4_user_guide/events/historic_events/historic_events_gauged.html#rainfall",
    "title": "Historical event with gauged water levels",
    "section": "Rainfall",
    "text": "Rainfall\nThe user has four options for entering the rainfall for the event:\nNone - Selecting this option means that no rainfall will be included in the calculation. This is the default option.\nConstant - For a constant rainfall, the user is asked to enter a rainfall intensity. This rainfall will be applied over the entire duration of the event.\nTimeseries - The user can upload a rainfall time series; this should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, and the second column contains the rainfall intensity (depth/time). The units of the rainfall will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the rainfall source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the rainfall intensity units.\n\n\n\n\n\n\nFigure¬†3: Example of the ‚Äúrequired format‚Äù popup for rainfall when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.\n\n\n\nMap - The map option downloads spatially and temporally varying rainfall at coarse spatial resolution (0.5 degrees for dates prior to February 2021, and 0.25 degrees after) from the NOAA global forecasting system reanalysis data.\n\n\n\n\n\n\nRainfall magnifier with the Timeseries and Map options\n\n\n\nWhen a user inputs rain data as timeseries or uses the Map option, they have the option to increase the rainfall by a specified percentage (referred to as the precipitation magnifier). This is to answer questions like ‚Äúwhat would have happened if the rainfall during that high tide would have been twice as intense?‚Äù",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event with gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_gauged.html#wind",
    "href": "4_user_guide/events/historic_events/historic_events_gauged.html#wind",
    "title": "Historical event with gauged water levels",
    "section": "Wind",
    "text": "Wind\n\n\n\n\n\n\nWhat role does wind play when water levels were measured?\n\n\n\nThe largest effect of wind on flooding is the surge it causes in the water levels. For gauged events, this effect is already included in the meausured water levels. The (more limited) role wind plays in this event type is to skew the water levels from the model boundary (usually near the gauge) to the land. Unless this is of particular interest to a user, the wind can be ignored.\n\n\nThe user has four options for entering wind for the event:\nNone - Selecting none means no wind will be included in the calculation. This is the default option.\nConstant - For a constant wind speed, the user is asked to enter the wind speed and wind direction.\nTimeseries - The user can upload a wind time series; this should be a three-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the wind speed, and the third column contains the wind direction. The units of the wind speed and direction will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the wind source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\n\n\n\n\n\n\nFigure¬†4: Example of the ‚Äúrequired format‚Äù popup for wind when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.\n\n\n\nMap - The map option downloads spatially and temporally varying wind data at coarse spatial resolution (0.5 degrees for dates prior to February 2021, and 0.25 degrees after) from the NOAA global forecasting system reanalysis data.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event with gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_gauged.html#river-discharge",
    "href": "4_user_guide/events/historic_events/historic_events_gauged.html#river-discharge",
    "title": "Historical event with gauged water levels",
    "section": "River discharge",
    "text": "River discharge\nThe river discharge represents the discharge in a river at the model boundary. If there are multiple rivers at the model boundary, the user will be able to select each river to specify the discharge. The user has two options for specifying the river discharge: a constant discharge or a time series.\nConstant - This is the default option. An average discharge value is filled in, which is specified in a FloodAdapt configuration folder at system setup. The user can change the value of the constant discharge in the event specification window.\nTimeseries - - The user can upload a river discharge time series; this should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the river discharge. The units of the river discharge will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the river discharge source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\n\n\n\n\n\n\nFigure¬†5: Example of the ‚Äúrequired format‚Äù popup for river discharge when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event with gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_ungauged.html",
    "href": "4_user_guide/events/historic_events/historic_events_ungauged.html",
    "title": "Historical event - without gauged water levels",
    "section": "",
    "text": "When the user selects the ‚ÄúHistorical event - without gauged water levels‚Äù option from the Events tab, they will see the event template window shown in Figure¬†1. This window allows the user to input timeseries for:\nThis event type is essentially the same as the Historical event with gauged water levels, except that instead of using measured nearshore water levels as input to the overland model, it calculates the nearshore water levels using an offshore model. This is why the section ‚ÄúSurge and tide‚Äù is empty in the event window. When you enter the start and stop time of the event, instead of pulling measured water levels from a gauge, FloodAdapt will pull gridded rain and wind data from NOAA global forecasting system reanalysis data to use as input to the offshore model. This data has a resolution of 0.5 degrees prior to February 2021, and a resolution of 0.25 since then.\nThe wind, rainfall, and river discharge that a user can specify in the event template window will be applied in the overland model, in the same way as is done for the Historical event with gauged water levels. Click here to read more about how events are modelled in FloodAdapt.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event - without gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_ungauged.html#rainfall",
    "href": "4_user_guide/events/historic_events/historic_events_ungauged.html#rainfall",
    "title": "Historical event - without gauged water levels",
    "section": "Rainfall",
    "text": "Rainfall\nThe user has four options for entering the rainfall that the overland model will use for the event:\nNone - Selecting this option means that no rainfall will be included in the calculation. This is the default option.\nConstant - For a constant rainfall, the user is asked to enter a rainfall intensity. This rainfall will be applied over the entire duration of the event.\nTimeseries - The user can upload a rainfall time series; this should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, and the second column contains the rainfall intensity (depth/time). The units of the rainfall will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the rainfall source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the rainfall intensity units.\n\n\n\n\n\n\nFigure¬†2: Example of the ‚Äúrequired format‚Äù popup for rainfall when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.\n\n\n\nMap - The map option downloads spatially and temporally varying rainfall at coarse spatial resolution (0.5 degrees for dates prior to February 2021, and 0.25 degrees after) from the NOAA global forecasting system reanalysis data.\n\n\n\n\n\n\nRainfall magnifier with the Timeseries and Map options\n\n\n\nWhen a user inputs rain data as timeseries or uses the Map option, they have the option to increase the rainfall by a specified percentage (referred to as the precipitation magnifier). This is to answer questions like ‚Äúwhat would have happened if the rainfall during that high tide would have been twice as intense?‚Äù",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event - without gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_ungauged.html#wind",
    "href": "4_user_guide/events/historic_events/historic_events_ungauged.html#wind",
    "title": "Historical event - without gauged water levels",
    "section": "Wind",
    "text": "Wind\n\n\n\n\n\n\nWhat role does wind play in the overland model?\n\n\n\nThe largest effect of wind on flooding is the surge it causes in the water levels. This wind effect is already included in the calculated nearshore water levels. The (more limited) role wind plays in the overland model is to skew the water levels from the model boundary to the land. Unless this is of particular interest to a user, the wind can be left at the default (none).\n\n\nThe user has four options for entering wind that the overland model will use for the event:\nNone - Selecting none means no wind will be included in the calculation. This is the default option.\nConstant - For a constant wind speed, the user is asked to enter the wind speed and wind direction.\nTimeseries - The user can upload a wind time series; this should be a three-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the wind speed, and the third column contains the wind direction. The units of the wind speed and direction will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the wind source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\n\n\n\n\n\n\nFigure¬†3: Example of the ‚Äúrequired format‚Äù popup for wind when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.\n\n\n\nMap - The map option downloads spatially and temporally varying wind data at coarse spatial resolution (0.5 degrees for dates prior to February 2021, and 0.25 degrees after) from the NOAA global forecasting system reanalysis data.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event - without gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/historic_events/historic_events_ungauged.html#river-discharge",
    "href": "4_user_guide/events/historic_events/historic_events_ungauged.html#river-discharge",
    "title": "Historical event - without gauged water levels",
    "section": "River discharge",
    "text": "River discharge\nThe river discharge represents the discharge in a river at the model boundary. If there are multiple rivers at the model boundary, the user will be able to select each river to specify the discharge. The user has two options for specifying the river discharge: a constant discharge or a time series.\nConstant - This is the default option. An average discharge value is filled in, which is specified in a FloodAdapt configuration folder at system setup. The user can change the value of the constant discharge in the event specification window.\nTimeseries - - The user can upload a river discharge time series; this should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the river discharge. The units of the river discharge will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the river discharge source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\n\n\n\n\n\n\nFigure¬†4: Example of the ‚Äúrequired format‚Äù popup for river discharge when choosing the ‚Äútimeseries‚Äù option. This popup will reflect the units specified when your system was configured and may differ from what is shown here.",
    "crumbs": [
      "Events",
      "Historical Events",
      "Historical event - without gauged water levels"
    ]
  },
  {
    "objectID": "4_user_guide/events/index.html",
    "href": "4_user_guide/events/index.html",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt allows users to specify and simulate the flooding and impacts for many different types of (compound) events. These can be either historically-based or synthetic events. The historically-based events use historical water levels or hurricane tracks, but allow users to modify event specifics to create what-if event scenarios, for example by adding or intensifying rainfall or shifting a hurricane track.\nThere are three historically-based event types, which are described in the coming sections:\nTo create an event, the user goes to the Events tab in FloodAdapt (see Figure¬†1). Prior to creating any events, there may be one event already shown in the event list window. This will be a probabilistic event set that is prepared as part of system setup, and is used to calculate risk. Underneath the event set window, the event ‚ÄúType‚Äù is indicated. For event sets this will say ‚ÄúProbabilistic Event Set.‚Äù For events that you create in the Events tab, these will say ‚ÄúSingle Event‚Äù. Next to the event list window there are buttons to add, edit, delete, and copy an event. Prior to creating any events, only the ‚ÄúAdd event‚Äù button will be active.\nWhen a user clicks Add event in the event window, they will be prompted to choose from one of the three historical event types or the synthetic event type. Each selection opens a window where the user can specify event information.\nEach event type will have unique input that is required, but they also share some common input. The user must provide an event name, and - optionally - a description. Additionally, all historic events require a start and stop time of the event.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "4_user_guide/events/index.html#how-are-events-modeled-in-floodadapt",
    "href": "4_user_guide/events/index.html#how-are-events-modeled-in-floodadapt",
    "title": "Events",
    "section": "How are events modeled in FloodAdapt?",
    "text": "How are events modeled in FloodAdapt?\nFloodAdapt supports two levels of hydrodynamic models:\n\nAn offshore model that calculates nearshore water levels based on astronomic tides, wind fields and pressure fields. These nearshore water levels are used to force the overland model.\nAn overland model that calculates the inundation over land due to nearshore water levels, local wind, rainfall, and river discharge.\n\nWhen a user selects a historical hurricane, FloodAdapt will pull in wind and pressure information about the track, and use this information to generate wind and pressure fields using the Holland 2010 method. It also uses the track information to estimate the rainfall field using the IPET method. The wind, pressure, and rainfall fields are used by the offshore model to calculate nearshore water levels. These are then used, together with the same wind, pressure and rainfall fields, to run the overland flood model.\nWhen a user selects a Historical event with gauged water levels, only the overland model will be run, using the gauged water levels as input to the overland model.\nWhen a user selects a Historical event without gauged water levels, the offshore model will first be run using the wind and pressure data from the NOAA Global Forecast System (GFS). The calculated nearshore water levels will then be input to the overland model to calculate the overland flooding.\nWhen a user selects a Synthetic event, only the overland model will be run, using the tide, surge, rainfall, wind, and river discharge information specified by the user.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html",
    "href": "4_user_guide/events/synthetic_events.html",
    "title": "Synthetic events",
    "section": "",
    "text": "When the user selects the ‚ÄúSynthetic‚Äù option from the Events tab, they will see the event template window shown in Figure¬†1. This window allows the user to input synthetic time series for:",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html#duration-of-the-synthetic-event",
    "href": "4_user_guide/events/synthetic_events.html#duration-of-the-synthetic-event",
    "title": "Synthetic events",
    "section": "Duration of the synthetic event",
    "text": "Duration of the synthetic event\nThe duration is specified by the user in the ‚ÄúTiming‚Äù block. The start time is given as a duration before T=0 (in hours), and the end time as a duration after T=0 (hours).\n\n\n\n\n\n\nWhat is T=0 in a synthetic event\n\n\n\nThe time T = 0 is an arbitrary moment when the tide is at its crest. It is essentially a ‚Äòreference time‚Äô to define the duration of an event, and to specify other forcing variables in relation to. Figure¬†2 shows an event with a duration 48 hours before and 12 hours after T=0. You can see the crest of the tide occurs at T=0, and the event runs from 48 hours before until 12 hours after this moment.\n\n\n\n\n\n\nFigure¬†2: T=0 and the duration of a sythetic event",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html#water-levels---tide-surge",
    "href": "4_user_guide/events/synthetic_events.html#water-levels---tide-surge",
    "title": "Synthetic events",
    "section": "Water levels - Tide + Surge",
    "text": "Water levels - Tide + Surge\nFor a synthetic event, the water level is treated as a sum of the tidal and surge components, which are specified separately.\nThe tide is entered as an amplitude above or below mean sea level. The window will open with a default value that was configured when the FloodAdapt system was set up.\nThe surge timeseries is specified as a Gaussian curve. The user specifies the peak surge, the duration of the surge, and the timing of the peak relative to T=0. Figure¬†3 shows an example how a user can adjust the surge timing. The figure shows three panels. The top panel has the tide set to zero, so the timeseries of the surge alone can be viewed. The surge is set as a Gaussian curve with a peak value of 6 ft, and a duration of 12 hours. The second panel shows the timing of the peak surge at -5 hours, with the tide set back to its default value of 3 ft. This is 5 hours before T=0, when the tide was not at its crest. The third panel shows the timing of the peak surge at 0 hours, which is precisely at T=0, when the tide was at its crest. You can s ee that the effect of the surge and high tide coinciding is a much higher total water level than when the peak surge occurs prior to the high tide.\n\n\n\n\n\n\nFigure¬†3: T=0 and the duration of a sythetic event\n\n\n\n\n\n\n\n\n\nThe zero point and the datums in the water level plots\n\n\n\nThere are several datums shown in the water level plot: mean lower low water (MLLW), mean sea level (MSL), and mean higher high water (MHHW). The zero point, which is set to mean lower low water (MLLW) in Figure¬†3, is configurable and chosen at system set-up to be most intuitive for the intended users of the system.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html#rainfall",
    "href": "4_user_guide/events/synthetic_events.html#rainfall",
    "title": "Synthetic events",
    "section": "Rainfall",
    "text": "Rainfall\nFor a synthetic event, can choose none (this is the default option), a constant intensity that will be applied over the entire duration of the event, or a shape, which is a rainfall timeseries based on standard curves.\n\nRainfall curves\nThere are three rainfall curves that a user can select to specify the rainfall timeseries:\n\nGaussian - this is a Gaussian curve where the user specifies the cumulative rainfall, the duration of the rainfall, and the peak time of the rainfall relative to T=0.\nBlock - this is a rectangular shaped curve, which represents constant rainfall intensity over a specified duration. The user specifies the cumulative rainfall and the start and stop time of the rainfall in hours relative to T=0.\nSCS - These curves are often used in practice in the US, and were developed by the Soil Conservation Service (SCS), now known as the National Resources Conservation Service. There are three SCS rainfall curves for different parts of the US. The curve that a user can select in the event teplate window will already be configured for the site location (part of system set-up). The user specifies the cumulative rainfall, the duration of the rainfall, and the start time in hours (relative to T=0).\n\n\n\n\n\n\n\nFigure¬†4: The three rainfall curves for a synthetic event. The top shows the Gaussian curve, the middle shows the SCS curve, and the bottom shows the block curve. All three represent three inches of rainfall over 12 hours (note: the vertical axis ranges are different in each plot)",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html#wind",
    "href": "4_user_guide/events/synthetic_events.html#wind",
    "title": "Synthetic events",
    "section": "Wind",
    "text": "Wind\nFor a synthetic event, the user can only enter either none (default), or a constant wind speed. When entering a constant wind speed, the user is asked to enter both the wind speed and wind direction. The direction should be entered in nautical degrees. This represents the direction where the wind is coming from. A direction of 0 degrees means wind is blowing from the North, 90 degrees means wind is blowing from the East.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/events/synthetic_events.html#river-discharge",
    "href": "4_user_guide/events/synthetic_events.html#river-discharge",
    "title": "Synthetic events",
    "section": "River discharge",
    "text": "River discharge\nThe river discharge represents the discharge in a river at the model boundary. If there are multiple rivers at the model boundary, the user will be able to select each river to specify the discharge. The user has two options for specifying the river discharge: a constant discharge or a shape, which is a synthetic timeseries.\nConstant - A constant discharge is the default option. An average discharge value is filled in, which is specified in a FloodAdapt configuration folder at system setup. The user can change the value of the constant discharge.\nShape - The shape option uses a Gaussian curve. The user must specify the base discharge (this can be left at the default value, which is the average discharge), a peak discharge, a duration, and a peak time. The duration refers to the duration that the river discharge is above its base value.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "4_user_guide/index.html",
    "href": "4_user_guide/index.html",
    "title": "FloodAdapt User Guide",
    "section": "",
    "text": "Welcome to the FloodAdapt user guide! This guide will help you specify and run scenarios to assess current and future flood impacts and risk and evaluate the effectiveness and benefits of adaptation options. The FloodAdapt application supports the creation, running, visualization, and comparison of scenarios. For more background on what FloodAdapt is and does, please visit the Introduction page\n\n\n\n\n\n\nWhat is a scenario in FloodAdapt?\n\n\n\nA FloodAdapt ‚Äúscenario‚Äù refers to a combination of (1) a weather or hydrological ‚Äúevent‚Äù that can lead to flooding, like a hurricane, a Nor‚Äôeaster, a high tide, rainfall, high river discharge, or combinations of these, (2) a ‚Äúprojection‚Äù representing future socio-economic or climate conditions and (3) a ‚Äústrategy‚Äù, representing an adaptation strategy with any number of individual measures (including the option to evaluate a current-situation strategy with no measures).\n\n\n\n\n\n\n\n\nExample user question\n\n\n\nHow would a floodwall have held up in a recent hurricane if the track had made a worst-case landfall?\nTo answer this question, the user would create a scenario: a recent hurricane shifted to make worst-case landfall (event), under current conditions (projection), with and a floodwall (strategy). Viewing the flooding, impacts and summary information will help them evaluate if the floodwall would have been sufficient to protect against this event.\n\n\nFigure¬†1 shows the FloodAdapt application. There are a number of tabs in the lower panel. FloodAdapt is designed for users to walk through these tabs to create events, projections, measures, and strategies. The Scenarios tab then supports the creation and simulation of scenarios, after which results can be viewed in the Output and Comparison tabs. FloodAdapt also supports the evaluation of benefits in the Benefits tab.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt opens to the ‚ÄúSite‚Äù tab. The user walks through the various tabs to create events, projections, measures, strategies, and scenarios for simulation. There are also tabs for viewing output and for creating benefit analyses. This guide describes the process for each of the FloodAdapt tabs\n\n\n\nEach of the FloodAdapt tabs is described briefly below with a link to visit the detailed documentation for that tab. The user guide content can also be found in the left-hand navigation pane. Figure¬†2 presents a diagram showing the tabs of the user interface and highlighting the information needed to run scenarios and benefit analyses, and view results. \n\nThe Site tab is an informative tab where the user is not required to input any information.\nThe Events, Projections, Measures, and Strategy tabs are input tabs where the user will specify the ‚Äòingredients‚Äô for their scenarios.\nThe Scenarios tab is a management tab, where the user can specify and run scenarios.\n\n\n\nThe Output tab is where a user can view maps showing the flooding and impacts and see infometrics and an infographic for scenarios that have been run.\nThe user can compare scenarios spatially (map comparison) in the Compare - map tab and can compare scenarios based on their tabulated metrics in the Compare - table tab.\nThe user can evaluate the risk-reduction benefits of an adaptation strategy, including spatial distribution of benefits, and equity-weighted benefits in the Benefits tab.\n\n\n\n\n\n\n\nFigure¬†2: Tabs of the FloodAdapt user interface. Blue-grey fill indicates required user input, and the arrows show the flow of information from one tab to another.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/measures/green_infra.html",
    "href": "4_user_guide/measures/green_infra.html",
    "title": "Urban green infrastructure",
    "section": "",
    "text": "Urban green infrastructure integrates natural elements like parks, green roofs, and permeable pavements into city landscapes to absorb, slow down, and manage stormwater runoff, thereby reducing flood risk and enhancing urban resilience. FloodAdapt includes a high-level representation of urban green infrastructure that is intended to help users identify the required capacity of urban green infrastructure solutions and the best placement of these options within the city to achieve community objectives. Currently there are three ‚Äòflavors‚Äô of urban green infrastructure that can be simulated and evaluated with FloodAdapt: water square, greening, and total storage. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a green infrastructure measure, go to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu select ‚ÄúGreen infrastructure‚Äù. Then for ‚ÄúMeasure‚Äù choose one of the three measure types: water square, greening, or total storage. Next, choose an ‚ÄúArea type‚Äù. This indicates how you will select the area to which you want to apply the green infrastructure measure. There are three options:\nWhen selecting an area to apply green infrastructure, it is useful to turn on the ‚Äúshow grid‚Äù option so you can see where the measure will be applied in the flood model.",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "4_user_guide/measures/green_infra.html#water-square",
    "href": "4_user_guide/measures/green_infra.html#water-square",
    "title": "Urban green infrastructure",
    "section": "Water Square",
    "text": "Water Square\nA water square is a multi-functional urban space designed to temporarily store excess rainwater during heavy rainfall, reducing flooding while providing recreational and aesthetic benefits during dry periods. A schematic of a water square is shown in Figure¬†2.\n\n\n\n\n\n\nFigure¬†2: A water square schematic, from https://urbangreenbluegrids.com/measures/water-squares/\n\n\n\nTo implement a water square in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúWater square‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\n\n\n\n\n\n\nFigure¬†3: Implementing a water square in FloodAdapt. This water square would affect two cells in the flood model by increasing their storage\n\n\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon that represents the shape of your water square. It is useful to turn on the ‚Äúshow grid‚Äù option so you can see where your water square will be implemented in the flood model. Figure¬†3 shows an implementation of a water square in FloodAdapt. In this example, the water square is implemented over two flood model grid cells, so those cells will have a higher storage capacity because of the water square. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your water square area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\nThe specification window is shown in Figure¬†8. In this window, you enter a name for the measure (no spaces or special characters), an optional description, and the depth of the water square. After entering the depth, click Enter. FloodAdapt will then automatically calculate the area of the water square (based on the selected area for the water square) and the total storage volume by multiplying the area with the specified water square depth. Additionally, there is also a ‚ÄúLook-up table‚Äù button. This shows suggestions for infiltration depths for different types of green infrastructure measures; see Figure¬†5. For the water square measure type, only the entry about water squares would be relevant.\n\n\n\n\n\n\nFigure¬†4: Water square specification window\n\n\n\n\n\n\n\n\n\nFigure¬†5: Lookup table with suggestions on infiltration depths for different types of green infrastructure solutions\n\n\n\n\n\n\n\n\n\nWhere do the suggested infiltration depths come from?\n\n\n\nThe suggested infiltration depths in the green infrastructure lookup-table are based on the default values used in the Climate Reilient Cities Tool, which itself based these values on different sources in literature. Users are free to choose their own infiltration depth when they have more information, but the suggestions are intended to help users who may not know this information but already want to start high-level exploring of green infrastructure solutions in their community.",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "4_user_guide/measures/green_infra.html#greening",
    "href": "4_user_guide/measures/green_infra.html#greening",
    "title": "Urban green infrastructure",
    "section": "Greening",
    "text": "Greening\nGreening in FloodAdapt refers to the implementation of a collection of different types of individual measures that may be part of a green infrastructure design. This option allows you to specify an area and the percentage of that area where green infrastructure will be implemented. For example, let‚Äôs say the area of interest is a neighborhood, and the measure under consideration is a bioswale. In this case, you could estimate the area of the neighborhood where there are roads (for example, let‚Äôs say 10%), and then specify that 10% of the area will have an infiltration depth appropriate for a bioswale (see the lookup table shown in Figure¬†5).\n\n\n\n\n\n\nFigure¬†6: Examples of different green infrastructure measures (source: https://crctool.org/en/set-measure)\n\n\n\nTo implement the greening option in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúGreening‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon for the area where you want to apply green infrastructure. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\n\n\n\n\n\n\nFigure¬†7: Selecting an aggregation area for applying the green infrastructure option ‚Äúgreening‚Äù.\n\n\n\nThe specification window is shown in Figure¬†8. In this window, you enter a name for the measure (no spaces or special characters), an optional description, the percent of the selected area you wish to apply green infrastructure measures, and the infiltration depth of the measures. For this last entry, you can use the Look-up table (see Figure¬†5). This shows suggestions for infiltration depths for different types of green infrastructure measures. After entering the depth, click Enter. FloodAdapt will then automatically calculate the area where the green infrastructure will be applied (based on the selected area and the percent area to green) and the total storage volume by multiplying the green infrastructure area with the specified infiltration depth.\n\n\n\n\n\n\nFigure¬†8: Greening specification window",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "4_user_guide/measures/green_infra.html#total-storage",
    "href": "4_user_guide/measures/green_infra.html#total-storage",
    "title": "Urban green infrastructure",
    "section": "Total storage",
    "text": "Total storage\nTotal storage is the most appropriate option for high-level strategic planning of green infrastructure. It addresses key questions such as, ‚ÄúWhere should we implement green infrastructure?‚Äù and ‚ÄúHow much storage capacity do we need?‚Äù This green infrastructure option involves selecting an area and specifying a total increased storage volume from green infrastructure measures, without focusing on specific measures. This approach allows you to explore different storage capacities and identify what storage capacity you need to meet your planning targets. It also allows you to test out storage in different neighborhoods and see where you get the best result for different rainfall events. This can help give direction to landscape architects, who can look into more detail how to obtain the required storage in different areas of the city. Of course, it is always recommended to verify the increase in storage with more detailed models in the design phase.\nTo implement the Total storage option in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúTotal storage‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon for the area where you want to apply green infrastructure. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\nThe specification window is shown in Figure¬†9. In this window, you enter a name for the measure (no spaces or special characters), an optional description, and the total increased storage volume.\n\n\n\n\n\n\nFigure¬†9: Total storage specification window",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "4_user_guide/measures/index.html",
    "href": "4_user_guide/measures/index.html",
    "title": "Measures",
    "section": "",
    "text": "FloodAdapt can simulate several types of adaptation measures. These fall under three categories within FloodAdapt:\nUsers enter measures in the Measures tab in FloodAdapt (see Figure¬†2). To get started specifying a measure, the user selects three options:\nClick on each of the category types (Hydraulic, Green Infrastructure, or Buildings) to see details about how to enter information for specific measures.",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/index.html#view-layers-in-the-measures-tab",
    "href": "4_user_guide/measures/index.html#view-layers-in-the-measures-tab",
    "title": "Measures",
    "section": "View layers in the Measures tab",
    "text": "View layers in the Measures tab\nAnother feature on the Measures tab is the ability to show a layer that can support or guide a user in determining where to implement measures. For example, a social vulnerability index layer, a disadvantaged communities layer, or an income layer may help the user to see where they want to focus their efforts to support more equitable adaptation planning. The layers that are visible in the Measures tab are configurable, so that communities can include the data that is most relevant for them. To view a layer, the user clicks the ‚ÄúShow Layer‚Äù dropdown menu (see Figure¬†2) and selects the layer they want to view.\n\n\n\n\n\n\nFigure¬†2: Measures tab in FloodAdapt",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "4_user_guide/measures/index.html#copying-editing-and-deleting-measures",
    "href": "4_user_guide/measures/index.html#copying-editing-and-deleting-measures",
    "title": "Measures",
    "section": "Copying, editing and deleting measures",
    "text": "Copying, editing and deleting measures\nFloodAdapt allows users to copy, edit, and delete measures they have already added. Copying measures is an efficient way to create multiple variations of a similar type of measure. For example, a user may want to evaluate elevating the same properties to different heights, or trying different heights for a floodwall.\nEditing measures allows the user to modify either the geometry of a measure or the measure parameters (these are specifications like the height of a wall). When a user selects ‚ÄúEdit measure‚Äù, FloodAdapt asks which of these a user would like to modify. If the user selects the geometry, they are able to modify polylines or polygons in the map. If they select parameters, the measure specification window opens and they can change parameters they specified.\nEditing and deleting measures is not permitted if the measure has already been used to specify a strategy. If the user wants to delete the measure, they must first delete the strategy which includes the measure.",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "4_user_guide/projections/climate.html",
    "href": "4_user_guide/projections/climate.html",
    "title": "Climate projections",
    "section": "",
    "text": "This section will describe how future projections of sea level rise, precipitation and tropical storm frequencies are specified and implemented in FloodAdapt.",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/climate.html#sea-level-rise",
    "href": "4_user_guide/projections/climate.html#sea-level-rise",
    "title": "Climate projections",
    "section": "Sea level rise",
    "text": "Sea level rise\nThere are two ways to specify sea level rise in the projections window: manually and from scenario.\nIf you select manually, you can type a number in the ‚ÄúSea Level Rise‚Äù (see Figure¬†2). You can then give your projection a name and (optionally) a description and click ‚ÄúOK‚Äù and your projection will show up in the FlodoAdapt Projections tab.\n\n\n\n\n\n\nFigure¬†2: Manually entering a sea level rise projection\n\n\n\nIf you select from scenario, a dropdown box will appear from which you can select the sea level rise scenario you want to use (see Figure¬†3). These options are configurable and are specified at system setup. Once you select a scenario, you specify a year and FloodAdapt will automatically calculate the sea level rise for that year, using the selected sea level rise scenario. You can then give your projection a name and (optionally) a description and click ‚ÄúOK‚Äù and your projection will show up in the FlodoAdapt Projections tab.\n\n\n\n\n\n\nFigure¬†3: Using a sea level rise scenario and a year to enter a sea level rise projection\n\n\n\n\n\n\n\n\n\nSea level rise - since when?\n\n\n\nSea level rise scenarios have a starting point where sea level rise is zero (often, but not necessarily, starting at the year 2000). FloodAdapt corrects for this, using the ‚Äòcurrent year‚Äô, which is specified at system setup. So when a user chooses the ‚Äúfrom scenario‚Äù option to input a sea level rise projection for a future year, the sea level rise that is shown in the projections window is relative to the current year. This is done by subtracting the projected rise between the starting point and the current year, for each sea level rise scenario.\n\n\n\n\n\n\n\n\nHow is the sea level rise projection represented in the modeling?\n\n\n\nWhen a user runs a scenario with a sea level rise projection, the sea level rise is added to the flood model‚Äôs coastal boundary condition. FloodAdapt treats this addition differently depending on the type of event. For a recent event using gauged water levels, the sea level rise in the current year relative to mean sea level is already represented in the measured water levels, so only the relative rise between the current year and future year is added. For a recent event without gauged water levels and for a historical hurricane, the offshore model calculates the nearshore coastal water levels relative to mean sea level. To correct for the sea level rise in the current year relative to mean sea level, an ‚Äòoffset‚Äô is added which is specified at system set-up. On top of this, the relative sea level rise between the current year and the future year is added to represent the future conditions.",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/climate.html#increased-precipitation",
    "href": "4_user_guide/projections/climate.html#increased-precipitation",
    "title": "Climate projections",
    "section": "Increased precipitation",
    "text": "Increased precipitation\nAn increase in precipitation is given as a percentage in the projections window (see Figure¬†4). You can give the projection a name and (optionally) a description and click ‚ÄúOK‚Äù and the projection will be added in the projections tab.\n\nWhy is this only for probabilistic event sets?\nIn the projection window, you see an indication that increased precipitation is for probabilistic events only. This is because for a single event, a user can explore a ‚Äòwhat-if‚Äô scenario about increased rainfall by adjusting the rainfall when they define an event (with the precipitation magnifier for a historical event, or with complete flexibility in defining rainfall for a synthetic event). For probabilistic event sets, the precpitation change needs to be applied to every event in the set, something that the user cannot do via the events tab.\n\n\n\n\n\n\nWhat happens if I choose this projection for a single event scenario?\n\n\n\nIf you choose a projection of increased precipitation for a single event, it will work exactly as expected, and is identical to the precipitation magnifier option when you define your event. If you prefer to specify the increased precipitation via the projections tab instead of as a precipitation magnifier in the event tab, that is completely fine! Just be careful not to choose both, or the increase will be applied twice.\n\n\n\n\n\n\n\n\nFigure¬†4: Entering increased precipitation as a percentage increase",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/climate.html#increased-storm-frequency",
    "href": "4_user_guide/projections/climate.html#increased-storm-frequency",
    "title": "Climate projections",
    "section": "Increased storm frequency",
    "text": "Increased storm frequency\nAn increase in storm frequency is given as a percentage in the projections window (see Figure¬†5). This percentage is treated as an increase in the occurrence frequency of each tropical storm event in a probabilistic event set. This influences the return period flood maps and risk estimates, because when storms occur more frequently, the chance of storm flooding, and hence risk, increases.\n\n\n\n\n\n\nExample - increased storm frequency\n\n\n\nFor example, if you select a storm frequency increase of 10%, and a tropical storm in the event set had an occurrence frequency of once in 50 years (0.02), the increased frequency of this storm would be 0.022, or once in about 45 years.\n\n\n\nWhy is this only for probabilistic event sets?\nThe change in storm frequency will only affect the frequency of the storm. This frequency is used in the derivation of return period flood maps and the calculation of expected annual damages. For a single event, this frequency is not used.\n\n\n\n\n\n\nWhat happens if I choose this projection for a single event scenario?\n\n\n\nIf you choose a projection of increased storm frequency for a single event, it will have no effect. The frequency is only used when calculating return period flood maps and risk, and for a single event scenario will play no role. It won‚Äôt do any harm, but it won‚Äôt have any effect on the resulting event-scenario flood and impact results.\n\n\n\n\n\n\n\n\nFigure¬†5: Entering increased storm frequency as a percentage increase",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/socioEconomic.html",
    "href": "4_user_guide/projections/socioEconomic.html",
    "title": "Socio-economic projections",
    "section": "",
    "text": "This section will describe how future projections of population in existing built area, population growth in new development areas and economic growth are specified and implemented in FloodAdapt.",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/socioEconomic.html#population-growth---existing-built-area",
    "href": "4_user_guide/projections/socioEconomic.html#population-growth---existing-built-area",
    "title": "Socio-economic projections",
    "section": "Population growth - existing built area",
    "text": "Population growth - existing built area\nTo represent population growth in existing built areas within the community, the user can choose ‚ÄúPopulation Growth - Existing‚Äù (see Figure¬†1). The user enters a percentage (such as 10%) which represents the percentage of the current existing population. So if there are 100,000 people now living in a community, a 10% increase would represent an additional 10,000 residents.\n\n\n\n\n\n\nFigure¬†1: Entering a percentage population growth in the existing built area\n\n\n\nThe idea of the population growth option in existing built areas within FloodAdapt is that the building stock becomes either more dense (more buildings), or the existing residences are replaced by higher-density buildings like apartment buildings.\nThe implementation of population growthing within FloodAdapt is simplified. This is because users may not know where new buildings will be built or which buildings will be replaced by higher-density buildings to support future population growth. FloodAdapt therefore spreads the increase evenly over the entire building stock, by increasing the maximum potential damages of all the existing buildings. Figure¬†2 shows an example how this is implemented, highlighting one building. This increase is applied to all buildings equally, so that the overall increase in damages is reflective of the future situation with population growth.\n\n\n\n\n\n\nFigure¬†2: Simplification of population growth in the existing built area in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/socioEconomic.html#population-growth---new-development-areas",
    "href": "4_user_guide/projections/socioEconomic.html#population-growth---new-development-areas",
    "title": "Socio-economic projections",
    "section": "Population growth - new development areas",
    "text": "Population growth - new development areas\nTo evaluate future impacts of population growth specifically in new areas considered for development, users can choose the option ‚ÄúPopulation Growth - New (%)‚Äù (see Figure¬†3). This is an innovative feature of FloodAdapt which allows users to evaluate the flooding and impacts in areas considered for future development.\nThe user specifies the percentage of the current existing population that is projected to live in the new development area. For example, if the current population is 100,000, and the new development area is expected to support 1,000 new residents, the user would enter 1% for the population growth in the new area. The user is then asked to provide a shape file (or other spatial polygon file) specifying the boundaries of the new development area. In addition, the user can specify how high the new development will be built off the ground, either relative to a datum, or relative to base flood elevation (BFE). This allows users to explore the impact of regulations on how high new developments need to be built.\n\n\n\n\n\n\nFigure¬†3: Entering a percentage population growth for a new development area\n\n\n\nThe idea of population growth in new areas in FloodAdapt is that people will move to currently-undeveloped areas which will be zoned for residential or commercial use to accommodate population growth. This feature allows users to evaluate potential new development areas in terms of the impacts and risk that result.\nThe implementation of population growth in new areas in FloodAdapt is simplified. The user is not expected to know exactly where each new building will be located, or specifics about each building that are typically needed to calculated damages, such as maximum potential damages, or whether they will be one-story or two-story homes. Instead, FloodAdapt creates a composite building over the entire new development area. This composite building is currently assumed to reflect the make-up of the existing built area. For example, if the current built area is 80% residential, 18% commercial, and 2% government buildings, the new development will have this same composition. The way this is utilized in FloodAdapt is that the composite new-development building is assigned a depth-damage curve that is a weighted average of the depth-damage curves of the existing buildings. The maximum potential damage of the composite building is assumed to be the total maximum potential damages over all the existing buildings multiplied by the percentage population growth. For example, if the total maximum potential damages over all buildings in the area is $1 Billion, the maximum potential damages for a new development area with 1% population growth would be $10 Million. Because the new-development composite building is large, it is likely often partially flooded during flood events. FloodAdapt stores the flood depths over the entire new development area. It takes the average flood depth to calculate damages, but reduces these damages by the fraction of the area that is not flooded. For example, if the average flood depth leads to damages of $1 Million, but only 20% of the area was flooded, FloodAdapt will reduce the damages by 80% to $200,000. Figure¬†4 gives a visual representation of how population growth in new development areas is represented in FloodAdapt.\n\n\n\n\n\n\nFigure¬†4: Implementation of population growth in new development areas in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "4_user_guide/projections/socioEconomic.html#economic-growth",
    "href": "4_user_guide/projections/socioEconomic.html#economic-growth",
    "title": "Socio-economic projections",
    "section": "Economic growth",
    "text": "Economic growth\nTo evaluate economic growth, users can choose the option ‚ÄúEconomic Growth (%)‚Äù (see Figure¬†5). The user enters a percentage increase in economic growth.\nThe economic growth projection is implemented in a simplified way in FloodAdapt by increasing the maximum potential damages of the existing buildings by the specified percentage. This is a simplification intended to represent increasing wealth and value in the community, without specifically accounting for changes in economic activity which would lead to this wealth and value increase.\n\n\n\n\n\n\nFigure¬†5: Implementation of economic growth in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "4_user_guide/scenario_results/index.html",
    "href": "4_user_guide/scenario_results/index.html",
    "title": "Scenario results",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_user_guide/scenarios/index.html",
    "href": "4_user_guide/scenarios/index.html",
    "title": "Scenarios",
    "section": "",
    "text": "A scenario in FloodAdapt is a what-if situation and consists of a hydro-meteorological event, a climate and/or socio-economic projection, and a strategy. For example, a scenario could be ‚ÄúHurricane Ian (event) with 1 foot of sea level rise (projection) with a floodwall (strategy)‚Äù. This scenario could be compared with ‚ÄúHurricane Ian with 1 foot of sea level rise with no measures implemented‚Äù to see how well a floodwall would prevent flooding and damages for this event under future sea level rise. Once you have defined at least one event, projection, and strategy, you are ready to create a scenario. Users can evaluate both event scenarios and risk scenarios. For a risk scenario, users select an event set instead of a single event; event sets are created as part of system setup.\n\n\n\n\n\n\nWhat is the difference between an event scenario and a risk scenario\n\n\n\nFor an event scenario FloodAdapt calculates the flooding and impacts for one single weather event, such as a hurricane or a king tide with rainfall. The scenario can include future projections and measures, but always represents just one single event. For a risk scenario, in contrast, FloodAdapt calculates flooding for a set of events with different probabilities. From this output, FloodAdapt derives return period flood maps (such as the 10-year, 25-year, or 100-year flood maps) and return period damage maps. It then combines this information to further derive expected annual damages, which is the metric associated with economic risk.\n\n\n\nIn the ‚ÄúScenarios‚Äù tab (see Figure¬†1) you will see a tabulated overview of any scenarios that have already been created. You can sort existing scenarios by name, date created, scenario component (event, project, or strategy), or run status (column ‚Äúfinished‚Äù) which indicates whether the scenario has been run (True) or not (False). Next to the table there are buttons to add, edit, or delete scenarios. Note that scenarios can only be edited or deleted if they have not yet been run.\n\n\n\n\n\n\nFigure¬†1: Scenarios tab in FloodAdapt\n\n\n\nTo create a new scenario, click ‚ÄúAdd scenario‚Äù to open the specification window (see Figure¬†2). In this window there are three panels for each of your scenario ingredients: event, projection, and strategy. Select the desired event, projection, and strategy for your scenario. The scenario name will automatically be generated based on your choice. You can keep that name or overwrite it with your own preferred scenario name (no spaces or special characters); you can also enter an optional description. When you have made your selection and are happy with the scenario name, click ‚ÄúOK‚Äù to add the scenario to the scenario window.\n\n\n\n\n\n\nFigure¬†2: Specifying a scenario in FloodAdapt, shown here for the scenario of Hurricane Ian with 1 foot of sea level rise and elevated homes\n\n\n\nTo run a scenario, select the scenario in the table and click the button ‚ÄúRun scenario‚Äù. The simulation will start and a pop-up window will appear informing that the scenario is running (see Figure¬†3). Sometimes the header in the popup window may say ‚ÄúNot Responding‚Äù but this can be ignored. The simulation may take several minutes. While the simulation is running you will not be able to work in the FloodAdapt application. When the simulation is finished, the pop-up window will disappear and the run status for your scenario will change from ‚ÄúFalse‚Äù to ‚ÄúTrue‚Äù.\n\n\n\n\n\n\nFigure¬†3: Popup indicating that a scenario is running\n\n\n\n\n\n\n\n\n\nRun multiple scenarios at once\n\n\n\nBecause scenarios can take several minutes to run, it can be efficient to run many scenarios at once, for example before your lunch break or at the end of the work day. This is also advantageous because the flood model can consume a lot of your computer‚Äôs computing power, which may make other applications run more slowly. To run many scenarios at once, simply select all the scenarios you wish to simulate and click ‚ÄúRun scenario‚Äù. FloodAdapt will then sequentially run the scenarios until they have all been completed.\n\n\n\n\n\n\n\n\nCreating and running event scenarios versus risk scenarios\n\n\n\nCreating an event scenario and a risk scenario follow the same procedure. The only difference is that a risk scenario will select an event set from the event panel instead of a single event. You can identify which ‚Äòevents‚Äô are actually ‚Äòevent sets‚Äô in the Events tab. These events specify that the type is ‚ÄúProbabilistic Event Set‚Äù (see the figure in the description of the probabilistic event set). FloodAdapt recognizes this choice and initiates a risk calculation. Note that risk calculations take much longer because they include the simulation of flooding for every event in the event set. Calculation times for both event scenarios and risk scenarios will depend on the resolution of the underlying flood model, the duration of the event, and the specifications of the user‚Äôs computer. In general, event scenarios run on the order of a few minutes.\n\n\nTo view the output of your scenario you can proceed to the Output tab. To compare scenarios you can make use of the Compare - map and Compare - table tabs.\n\n\n\n Back to top",
    "crumbs": [
      "Scenarios"
    ]
  },
  {
    "objectID": "4_user_guide/strategy/index.html",
    "href": "4_user_guide/strategy/index.html",
    "title": "Strategies",
    "section": "",
    "text": "A strategy in FloodAdapt refers to a combination of measures. Users can define and name these strategies according to their own ideas and terminology. For example, a ‚Äúbusiness as usual‚Äù strategy could consist of no measures; a ‚Äúprotect‚Äù strategy could consist of floodwalls and levees, or an ‚Äúadapt‚Äù strategy could consist of elevating, floodproofing, or buying out properties. Defining at least one strategy is mandatory in FloodAdapt to run a scenario.\nThe ‚ÄúStrategies‚Äù tab (see Figure¬†1) contains an overview of the strategies that have already been created. You can select existing strategies in the left panel and in the right panel see the measures that are included in the strategy. The measures in the selected strategy also appear in the map window. If a description was added to the strategy when it was created, this will also appear to the right for the selected strategy. Next to the left panel there are buttons to add or delete strategies.\n\n\n\n\n\n\nFigure¬†1: Strategy tab in FloodAdapt\n\n\n\nTo create a new strategy, click ‚ÄúAdd strategy‚Äù. A dialogue window opens up (see Figure¬†2) within which you can choose the measures you want to include in your strategy. To add a measure to your strategy, select it in the left-hand panel and click the ‚ÄúApply measure‚Äù button. You can do this multiple times until you have selected all the measures you want to include in the strategy. In the right-hand panel you see the collection of measures that have been selected. If you want to remove one of these, you can select it in the right-hand panel and click the ‚ÄúRemove measure‚Äù button. You can give your strategy a name; this cannot contain any special characters or spaces. You can then (optionally) give a description of your strategy for future reference. Once you have selected the measures in your strategy and provided a name, click ‚ÄúOK‚Äù and the strategy will be added to the strategy window.\n\n\n\n\n\n\nFigure¬†2: Adding a strategy in FloodAdapt\n\n\n\n\n\n\n\n\n\nThe ‚ÄúNo-measure strategy‚Äù\n\n\n\nTo create a no-measure strategy (also commonly referred to as ‚Äúcurrent situation‚Äù or ‚Äúbusiness as usual‚Äù), click ‚ÄúAdd Strategy‚Äù, then simply name the strategy and do not select any measures and click ‚ÄúOK‚Äù. Note that a no-measure strategy may be built in with your starting database, as this is recommended during system setup.\n\n\n\n\n\n\n\n\nMultiple building-level measures are not allowed on the same buildings\n\n\n\nWhen building a strategy, users are not permitted to apply multiple building-level measures to the same buildings. This is because it wouldn‚Äôt make sense to elevate a home and then also buyout or floodproof the same home. If a user does build a strategy that would result in multiple buildling-level measures being applied to the same buildings, the user will get an error like the one shown below.\n\n\n\n\n\n\nFigure¬†3: Error warning when applying multiple building-level measures to the same buildings\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Strategies"
    ]
  },
  {
    "objectID": "5_technical_docs/EquityCalc.html",
    "href": "5_technical_docs/EquityCalc.html",
    "title": "Equity Calculation",
    "section": "",
    "text": "Equity methods seek to compensate for the unfair distribution in income when calculating flood damages. They rely on the concept of marginal utility of income, which holds that a loss of $1 for a rich person is not equivalent to the loss of $1 for a poor person. Utility is defined in economics as the satisfaction, usefulness, or happiness derived from - in this case - income. Equity weights are a way to correct for the inequality in marginal utility across income classes. Essentially, the equity weight represents the relative size of the marginal utility (a loss in utility due to a change in income - brought on in this case by flood damages) compared to the marginal utility for the community‚Äôs average income level. This leads to equity weights greater than 1 for incomes below average, and less than 1 for higher-than-average incomes. The equity weights are then used as a multiplicative factor on flood damages.\n\n\n\n\n\n\nFigure¬†1: Illustration of utility, and the marginal utility for high-income versus low-income community members.\n\n\n\nFloodAdapt includes a module which automatically calculates equity weights and applies them to risk estimates, using methods described in literature (1). The calculation framework of the module is depicted in Figure¬†2.\nInputs to the method are:\n\nMean per capita income (\\(M\\)) and population \\((P)\\) at aggregated scale, for example census block groups. This information can be obtained automatically when setting up the Delft-FIAT model\nReturn period damages per building \\(D\\) (output from the impact module in a risk calculation).\n\nThe module then does the following:\n\nCalculates the weighted average income per capita, weighted by population \\(I_{WA} = \\frac{\\sum (M_i \\cdot P_i)}{P}\\), where \\(i\\) represents the areas, for example census block groups.\nDerives the equity weight for each aggregated area: \\(EW_i = \\left(\\frac{M_i}{I_{WA}}\\right)^\\gamma\\). Note that \\(\\gamma\\) is set to 1.2. This parameter is expected to be made configurable by FloodAdapt users in future releases.\nCalculates for each return period \\(j\\) the equity-weighted damages per aggregation area \\(EWD_{i,j} = EW_i \\cdot D_{i,j}\\)\nIntegrates the equity-weighted damages over the return periods using log-linear interpolation to derive the equity-weighted expected annual damages for each aggreagation area.\n\n\n\n\n\n\n\nFigure¬†2: FloodAdapt calculation framework for equity-weighted risk estimates\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Equity Calculation"
    ]
  },
  {
    "objectID": "5_technical_docs/RiskScenario.html",
    "href": "5_technical_docs/RiskScenario.html",
    "title": "Risk Scenario",
    "section": "",
    "text": "A risk scenario is similar to an event scenario, but instead of running for one single event FloodAdapt runs the flood model for every event in a probabilistic event set. This is a set consisting of specifications for different (compound) events that can lead to flooding in the area and their occurrence frequencies. A paper describing how this event set was prepared for Charleston, South Carolina can be found here.\nThe hazard calculation and impact & risk calculation frameworks for a risk scenario are presented in the sections below.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/RiskScenario.html#hazard-calc",
    "href": "5_technical_docs/RiskScenario.html#hazard-calc",
    "title": "Risk Scenario",
    "section": "Hazard calculation",
    "text": "Hazard calculation\nFigure¬†1 zooms in on the hazard calculation portion of the FloodAdapt workflow for a risk scenario. Referring to the figure can support the description of the calculation.\nFor a risk scenario the hazard calculation involves both simulating the flooding for each event in the event set and the derivation of probabilistic return period maps. FloodAdapt modifies the SFINCS model based on adaptation options and calculates the flooding for each event in the event set in the same way it does for an event scenario. This is indicated in Figure¬†1 by a horizontal line, above which the event scenario and risk scenario are the same, except that the flood model is called multiple times to calculate flooding for each event in the event set. This workflow is described in the event scenario documentation and not repeated here. Below the horizontal line in Figure¬†1, the workflow for the risk scenario hazard is unique. Once the simulation for each event in the event set has been completed, the entire set of flood maps is passed into a probabilistic calculator. This is a routine that uses the event frequencies and simulated flood maps to create a water level-frequency curve for each grid cell in the flood model. It then derives from this curve the flood depth for the return periods specified for the site at system setup. From this output it creates gridded return period flood maps. A detailed description of the probabilistic calculator is given later on this page.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt calculation framework for hazardfor a risk scenario",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/RiskScenario.html#impact-risk-calc",
    "href": "5_technical_docs/RiskScenario.html#impact-risk-calc",
    "title": "Risk Scenario",
    "section": "Impact and risk calculation",
    "text": "Impact and risk calculation\nFigure¬†2 zooms in on the impact and risk calculation portion of the FloodAdapt workflow for a risk scenario. Referring to the figure can support the description of the calculation.\n\n\n\n\n\n\nFigure¬†2: FloodAdapt calculation framework for impacts and risk for a risk scenario\n\n\n\nThe automatic updating of the Delft-FIAT model based on user-specified adaptation options and projections is identical to the handling in the event scenario. This workflow description is not repeated here.\nFor a risk scenario, FloodAdapt imports into Delft-FIAT the set of return period flood maps (calculated in the hazard framework with the use of the probabilistic calcultor). Delft-FIAT has an automatic risk module built in which calculates and outputs the direct economic damages to the assets in the exposure data for each input return period flood map. It uses this output to generate a damage-frequency curve (note that the exceedance frequency is the reciprocal of the return period). The expected annual damages (risk) are then calculated as the area under the damage-frequency curve (see Figure¬†3). The set of return periods will be finite, so Delft-FIAT makes approximations for return periods beyond what is calculated. For return periods higher than the highest calculated, it assumes economic damages equal to the highest calculated. For return periods lower than the lowest calculated, it assumes economic damages of zero. In FloodAdapt, users can choose the return periods for which damages will be calculated, to minimize these approxmiations. For example, users can take an upper limit for the return period of 500 or 1000 years and a lower limit of 1 year.\n\n\n\n\n\n\nFigure¬†3: Schematic of the risk calculation performed in Delft-FIAT. The damage-frequency curve is created using the damages calculated for the return period flood maps, and the risk is calculated as the area under the damage-frequency curve.\n\n\n\nAfter the return period damages and risk have been calculated by Delft-FIAT, FloodAdapt sends the output through a suite of postprocessing scripts to derive aggregated damages, spatial maps, risk metrics, and risk-related infographics. Additionally, FloodAdapt calls an Equity routine that calculates equity weights and applies them to risk estimates at an aggregated level for optional viewing in the user interface.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/RiskScenario.html#probCalculator",
    "href": "5_technical_docs/RiskScenario.html#probCalculator",
    "title": "Risk Scenario",
    "section": "The probabilistic calculator",
    "text": "The probabilistic calculator\nIn Figure¬†1, the simulated flood maps for the events in the event set, and the event occurrence frequencies, are passed into a module called ‚ÄúThe probabilistic calculator‚Äù. This section describes the method in that calculator to determine return period flood maps. The following steps are carried out for each grid cell in the SFINCS overland model. Each step is described below with supporting images.\n\nStep 1: Arrange water levels and frequencies in tables\nStep 2: Sort the water levels in descending order\nStep 3: Calculate the frequency of exceedance of the water levels\nStep 4: Calculate the return periods of the water levels\nStep 5: Calculate the water level associated with the return periods of interest\nStep 6: Convert water levels to water depths\n\n\nStep 1: Arrange water levels and frequencies in tables\nThe water levels for each grid cell (h) and their associated frequencies of occurrence (f) are arranged in two separate matrices with the number of rows equal to the number of events (j) and the number of columns equal to the number of grid cells (n). The example shown in Figure¬†4 illustrates the results for two fictitious grid cells and 10 fictitious events. To allow the reader to follow the approach more easily, the two highest and lowest values and their associated frequencies are highlighted in orange and blue throughout all steps.\n\n\n\n\n\n\nFigure¬†4: Left: Water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of occurrence. The two highest and lowest values and their associated frequencies are highlighted in orange and blue.\n\n\n\n\n\nStep 2: Sort the water levels in descending order\nThe water levels are sorted column-wise in descending order (see Figure¬†5). The matrix with the frequencies of occurrence are sorted in the same manner so that the frequency of occurrence has the same location in the right matrix as its corresponding water level value in the left matrix. The highest water level does not necessarily correspond to the lowest frequency of occurrence as in the example below.\n\n\n\n\n\n\nFigure¬†5: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of occurrence. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 3: Calculate the frequency of exceedance of the water levels\nTo calculate the frequencies of exceedance, the CFRSS cumulatively sums the frequencies of occurrence column-wise from the highest to lowest water level (see Figure¬†6). In the example, the frequency of exceedance for grid cell n=2 in the second row is 2.11E-03. This is the sum of the frequencies of occurrence of the first two rows from Table 6.4 (1.11E-03 + 1.00E-03).\n\n\n\n\n\n\nFigure¬†6: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of exceedance. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 4: Calculate the return periods of the water levels\nThe return periods of water levels in each grid cell are then calculated as the inverse of the frequencies of exceedance (RP = 1/fexc); see Figure¬†7.\n\n\n\n\n\n\nFigure¬†7: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated return periods of exceedance. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 5: Calculate the water level associated with the return periods of interest\nTo calculate the water levels for the return periods of interest specified in the site configuration file, FloodAdapt uses the ‚Äúlookup-table‚Äù from Step 4 (Figure¬†7) to derive the water level associated with each return period. The water levels in the lookup table are log-linearly interpolated between the return periods (see Figure¬†8 for an illustration).\n\n\n\n\n\n\nFigure¬†8: Water level versus return period in computational grid cell n=2. Water level at the desired output return period are interpolated log-linearly between data points.\n\n\n\nFor extrapolation outside of the bounds of the minimum and maximum return period in the lookup table, the following rules are applied:\n\nIf the return period of interest is larger than the maximum return period calculated for a given grid cell, the water level of the maximum return period is assigned to the return period of interest.\nIf the return period of interest is smaller than the minimum return period calculated for a given grid cell, the water level is set to zero in that grid cell for the return period of interest.\n\n\n\nStep 6: Convert water levels to water depths\nThe resulting return-period water levels for each grid cell are mapped onto the raster of the (typically finer-scale) DEM using the indices file that maps each SFINCS grid cell to its corresponding DEM raster cells. The land elevation is then subtracted from the water levels to obtain flood depths. These flood depth maps are then passed to the Delft-FIAT model to calculate impacts and risk.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "5_technical_docs/index.html",
    "href": "5_technical_docs/index.html",
    "title": "FloodAdapt Technical documentation",
    "section": "",
    "text": "Welcome to the FloodAdapt technical documentation. This section is intended for readers with a technical or modeling background who want to better understand the calculations within FloodAdapt.\nThe technical documentation covers the technical details of four calculation frameworks:\nEach of these are introduced below with a link to the detailed documentation."
  },
  {
    "objectID": "5_technical_docs/index.html#event-scenarios",
    "href": "5_technical_docs/index.html#event-scenarios",
    "title": "FloodAdapt Technical documentation",
    "section": "Event scenarios",
    "text": "Event scenarios\n\n\n\n\n\n\nFigure¬†1: Scenario components: a future climate and/or socio-economic projection, a hydro-meteorological event, and a strategy\n\n\n\nAn event scenario in FloodAdapt is a what-if situation and consists of a hydro-meteorological event, a climate and/or socio-economic projection, and a strategy. For example, an event scenario could be ‚ÄúHurricane Ian (event) with 1 foot of sea level rise (projection) with a floodwall (strategy)‚Äù. This scenario could be compared with ‚ÄúHurricane Ian with 1 foot of sea level rise with no measures implemented‚Äù to see how well a floodwall would prevent flooding and damages for this event under future sea level rise. Once you have defined at least one event, projection, and strategy, you are ready to create a scenario. Users can evaluate both event scenarios and risk scenarios.\nClick here to read the technical documentation for an event scenario calculation"
  },
  {
    "objectID": "5_technical_docs/index.html#risk-scenarios",
    "href": "5_technical_docs/index.html#risk-scenarios",
    "title": "FloodAdapt Technical documentation",
    "section": "Risk scenarios",
    "text": "Risk scenarios\nA risk scenario is very similar to an event scenario. It also consists of a climate and/or socio-economic projection and a strategy. However, instead of being specified for one single hydro-meteorological event, a risk scenario consists of a set of (compound) events, all of which could lead to flooding in the project area. Each event in the set is also accompanied by a frequency of occurrence. FloodAdapt simulates the flooding for each event in the event set, and subsequently derives return period flood maps (such as the 10-year, 25-year, or 100-year flood maps) and return period damage maps. It then combines this information to further derive expected annual damages, which is the metric associated with economic risk.\nClick here to read the technical documentation for a risk scenario calculation"
  },
  {
    "objectID": "5_technical_docs/index.html#equity",
    "href": "5_technical_docs/index.html#equity",
    "title": "FloodAdapt Technical documentation",
    "section": "Equity",
    "text": "Equity\nEquity methods account for income disparity among residents in the community. The equity-weighting method used in Kind et al. is applied in FloodAdapt to calculated equity-weighted expected annual damages. The method makes use of the utility curve, which relates a loss in income to a loss in ‚Äòutility‚Äô or well-being. This changes depending on the income level. The equity weights are essentially the relative utility loss compared to the average in the community. The method relies on income and population data derived at census block group level, and therefore the equity-weighted expected annual damages are only available at this same scale.\nClick here to read more details about how the equity weights are calculated and applied in FloodAdapt"
  },
  {
    "objectID": "5_technical_docs/index.html#benefits",
    "href": "5_technical_docs/index.html#benefits",
    "title": "FloodAdapt Technical documentation",
    "section": "Benefits",
    "text": "Benefits\nFlood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits. The user guide section on benefits provides comprehensive guidance on preparing and evaluating benefits in FloodAdapt.\nClick here to read technical documentation describing the benefit calculation in FloodAdapt."
  },
  {
    "objectID": "5_update_model/damage_functions.html",
    "href": "5_update_model/damage_functions.html",
    "title": "Updating damage functions",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_update_model/index.html",
    "href": "5_update_model/index.html",
    "title": "Updating FloodAdapt",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "5_update_model/settings.html",
    "href": "5_update_model/settings.html",
    "title": "Updating settings for running probabilistic scenarios",
    "section": "",
    "text": "Coming soon.\n\nUpdating return periods\n\n\nUpdating the flood frequency threshold\n\n\n\n\n Back to top"
  },
  {
    "objectID": "6_demo/index.html",
    "href": "6_demo/index.html",
    "title": "Demonstrating the use of FloodAdapt",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "6_demo/measures_impact.html",
    "href": "6_demo/measures_impact.html",
    "title": "Measures and their impact",
    "section": "",
    "text": "Coming soon. ## Exploring measures"
  },
  {
    "objectID": "6_demo/measures_impact.html#evaluating-measures",
    "href": "6_demo/measures_impact.html#evaluating-measures",
    "title": "Measures and their impact",
    "section": "Evaluating measures",
    "text": "Evaluating measures\n\nReduced impacts\n\n\nRisk-reduction benefits\n\n\nEffectiveness under future conditions"
  },
  {
    "objectID": "api_ref/Benefit.html",
    "href": "api_ref/Benefit.html",
    "title": "Benefit",
    "section": "",
    "text": "objects.Benefit()\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\n\nname : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None."
  },
  {
    "objectID": "api_ref/Benefit.html#attributes",
    "href": "api_ref/Benefit.html#attributes",
    "title": "Benefit",
    "section": "",
    "text": "name : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None."
  },
  {
    "objectID": "api_ref/CurrentSituationModel.html",
    "href": "api_ref/CurrentSituationModel.html",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "objects.CurrentSituationModel()\nThe accepted input for a current situation in FloodAdapt.\n\n\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation."
  },
  {
    "objectID": "api_ref/CurrentSituationModel.html#attributes",
    "href": "api_ref/CurrentSituationModel.html#attributes",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "projection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation."
  },
  {
    "objectID": "api_ref/Event.html",
    "href": "api_ref/Event.html",
    "title": "Event",
    "section": "",
    "text": "objects.Event()\nThe accepted input for an event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nload_file\nLoad object from file.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event."
  },
  {
    "objectID": "api_ref/Event.html#attributes",
    "href": "api_ref/Event.html#attributes",
    "title": "Event",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "api_ref/Event.html#methods",
    "href": "api_ref/Event.html#methods",
    "title": "Event",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nload_file\nLoad object from file.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event."
  },
  {
    "objectID": "api_ref/FloodAdapt.html",
    "href": "api_ref/FloodAdapt.html",
    "title": "FloodAdapt",
    "section": "",
    "text": "FloodAdapt(self, database_path: Path)\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_benefit_scenarios\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\ncopy_event\nCopy an event in the database.\n\n\ncopy_measure\nCopy a measure in the database.\n\n\ncopy_projection\nCopy a projection in the database.\n\n\ncopy_strategy\nCopy a strategy in the database.\n\n\ncreate_benefit\nCreate a new benefit object.\n\n\ncreate_benefit_scenarios\nCreate the benefit scenarios.\n\n\ncreate_event\nCreate a event object from a dictionary of attributes.\n\n\ncreate_event_set\nCreate a event set object from a dictionary of attributes.\n\n\ncreate_measure\nCreate a measure from a dictionary of attributes and a type string.\n\n\ncreate_projection\nCreate a new projection object.\n\n\ncreate_scenario\nCreate a new scenario object.\n\n\ncreate_strategy\nCreate a new strategy object.\n\n\ndelete_benefit\nDelete a benefit object from the database.\n\n\ndelete_event\nDelete an event from the database.\n\n\ndelete_measure\nDelete an measure from the database.\n\n\ndelete_projection\nDelete a projection from the database.\n\n\ndelete_scenario\nDelete a scenario from the database.\n\n\ndelete_strategy\nDelete a strategy from the database.\n\n\nget_aggregated_benefits\nGet the aggregation benefits for a benefit assessment.\n\n\nget_aggregated_impacts\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\nget_aggregation_areas\nGet a list of the aggregation areas that are provided in the site configuration.\n\n\nget_benefit\nGet a benefit from the database by name.\n\n\nget_benefits\nGet all benefits from the database.\n\n\nget_building_footprint_impacts\nReturn a geodataframe of the impacts at the footprint level.\n\n\nget_building_geometries\nGet the buildings exposure that are used in Fiat.\n\n\nget_building_types\nGet the building types/categories that are used in the exposure.\n\n\nget_completed_scenarios\nGet all completed scenarios from the database.\n\n\nget_cyclone_track_by_index\nGet a cyclone track from the database by index.\n\n\nget_depth_conversion\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\nget_event\nGet an event from the database by name.\n\n\nget_events\nGet all events from the database.\n\n\nget_green_infra_table\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\nget_index_path\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\nget_infographic\nReturn the HTML string of the infographic for the given scenario.\n\n\nget_infometrics\nReturn the metrics for the given scenario.\n\n\nget_max_water_level_map\nReturn the maximum water level for the given scenario.\n\n\nget_measure\nGet a measure from the database by name.\n\n\nget_measures\nGet all measures from the database.\n\n\nget_model_boundary\nGet the model boundary that is used in SFINCS.\n\n\nget_model_grid\nGet the model grid that is used in SFINCS.\n\n\nget_obs_point_timeseries\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\nget_obs_points\nGet the observation points specified in the site.toml.\n\n\nget_projection\nGet a projection from the database by name.\n\n\nget_projections\nGet all projections from the database.\n\n\nget_road_impacts\nReturn a geodataframe of the impacts at roads.\n\n\nget_scenario\nGet a scenario from the database by name.\n\n\nget_scenarios\nGet all scenarios from the database.\n\n\nget_slr_scn_names\nGet all sea level rise scenario names from the database.\n\n\nget_static_map\nGet a static map from the database.\n\n\nget_strategies\nGet all strategies from the database.\n\n\nget_strategy\nGet a strategy from the database by name.\n\n\nget_svi_map\nGet the SVI map that are used in Fiat.\n\n\nget_topobathy_path\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\ninterp_slr\nInterpolate sea level rise for a given scenario and year.\n\n\nload_static_data\nRead the static data into the cache.\n\n\nplot_event_forcing\nPlot forcing data for an event.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\nrun_benefit\nRun the benefit assessment.\n\n\nrun_scenario\nRun a scenario hazard and impacts.\n\n\nsave_benefit\nSave a benefit object to the database.\n\n\nsave_event\nSave an event object to the database.\n\n\nsave_measure\nSave a measure object to the database.\n\n\nsave_projection\nSave a projection object to the database.\n\n\nsave_scenario\nSave the scenario to the database.\n\n\nsave_strategy\nSave a strategy object to the database.\n\n\n\n\n\nFloodAdapt.check_benefit_scenarios(benefit: Benefit)\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\n\nbenefit : Benefit\n\nThe benefit object to check.\n\n\n\n\n\n\nscenarios : pd.DataFrame\n\nA dataframe with the scenarios needed for this benefit assessment run.\n\n\n\n\n\n\nFloodAdapt.copy_event(old_name: str, new_name: str, new_description: str)\nCopy an event in the database.\n\n\n\nold_name : str\n\nThe name of the event to copy.\n\nnew_name : str\n\nThe name of the new event.\n\nnew_description : str\n\nThe description of the new event\n\n\n\n\n\n\nFloodAdapt.copy_measure(old_name: str, new_name: str, new_description: str)\nCopy a measure in the database.\n\n\n\nold_name : str\n\nThe name of the measure to copy.\n\nnew_name : str\n\nThe name of the new measure.\n\nnew_description : str\n\nThe description of the new measure\n\n\n\n\n\n\nFloodAdapt.copy_projection(old_name: str, new_name: str, new_description: str)\nCopy a projection in the database.\n\n\n\nold_name : str\n\nThe name of the projection to copy.\n\nnew_name : str\n\nThe name of the new projection.\n\nnew_description : str\n\nThe description of the new projection\n\n\n\n\n\n\nFloodAdapt.copy_strategy(old_name: str, new_name: str, new_description: str)\nCopy a strategy in the database.\n\n\n\nold_name : str\n\nThe name of the strategy to copy.\n\nnew_name : str\n\nThe name of the new strategy.\n\nnew_description : str\n\nThe description of the new strategy\n\n\n\n\n\n\nFloodAdapt.create_benefit(attrs: dict[str, Any])\nCreate a new benefit object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the benefit object to create. Should adhere to the Benefit schema.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Benefit schema.\n\n\n\n\n\n\nFloodAdapt.create_benefit_scenarios(benefit: Benefit)\nCreate the benefit scenarios.\n\n\n\nbenefit : Benefit\n\nThe benefit object to create scenarios for.\n\n\n\n\n\n\nFloodAdapt.create_event(attrs: dict[str, Any] | Event)\nCreate a event object from a dictionary of attributes.\n\n\n\nattrs : Event[str, Any]\n\nDictionary of attributes\n\n\n\n\n\n\nevent : Event\n\nDepending on attrs.template an event object. Can be of type: Synthetic, Historical, Hurricane.\n\n\n\n\n\n\nFloodAdapt.create_event_set(\n    attrs: dict[str, Any] | EventSet,\n    sub_events: list[Event],\n)\nCreate a event set object from a dictionary of attributes.\n\n\n\nattrs : EventSet[str, Any]\n\nDictionary of attributes\n\nsub_events : list[Event]\n\nList of events in the event set\n\n\n\n\n\n\nevent_set : EventSet\n\nEventSet object\n\n\n\n\n\n\nFloodAdapt.create_measure(attrs: dict[str, Any], type: str = None)\nCreate a measure from a dictionary of attributes and a type string.\n\n\n\nattrs : dict[str, Any]\n\nDictionary of attributes for the measure.\n\ntype : str = None\n\nType of measure to create.\n\n\n\n\n\n\nmeasure : Measure\n\nMeasure object.\n\n\n\n\n\n\nFloodAdapt.create_projection(attrs: dict[str, Any])\nCreate a new projection object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the projection object to create. Should adhere to the Projection schema.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Projection schema.\n\n\n\n\n\n\nFloodAdapt.create_scenario(attrs: dict[str, Any])\nCreate a new scenario object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the scenario object to create. Should adhere to the Scenario schema.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Scenario schema.\n\n\n\n\n\n\nFloodAdapt.create_strategy(attrs: dict[str, Any])\nCreate a new strategy object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the strategy object to create. Should adhere to the Strategy schema.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object\n\n\n\n\n\n\n: ValueError\n\nIf the strategy with the given name does not exist. If attrs does not adhere to the Strategy schema.\n\n\n\n\n\n\nFloodAdapt.delete_benefit(name: str)\nDelete a benefit object from the database.\n\n\n\nname : str\n\nThe name of the benefit object to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the benefit object does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_event(name: str)\nDelete an event from the database.\n\n\n\nname : str\n\nThe name of the event to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the event does not exist. If the event is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_measure(name: str)\nDelete an measure from the database.\n\n\n\nname : str\n\nThe name of the measure to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the measure does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_projection(name: str)\nDelete a projection from the database.\n\n\n\nname : str\n\nThe name of the projection to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the projection does not exist. If the projection is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_scenario(name: str)\nDelete a scenario from the database.\n\n\n\nname : str\n\nThe name of the scenario to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the scenario does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_strategy(name: str)\nDelete a strategy from the database.\n\n\n\nname : str\n\nThe name of the strategy to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the strategy does not exist.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_benefits(name: str)\nGet the aggregation benefits for a benefit assessment.\n\n\n\nname : str\n\nThe name of the benefit assessment.\n\n\n\n\n\n\naggregated_benefits : gpd.GeoDataFrame\n\nThe aggregation benefits for the benefit assessment.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_impacts(name: str)\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\naggr_impacts : dict[str, gpd.GeoDataFrame]\n\nThe aggregated impacts for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_aggregation_areas()\nGet a list of the aggregation areas that are provided in the site configuration.\nThese are expected to much the ones in the FIAT model.\n\n\n\naggregation_areas : dict[str, GeoDataFrame]\n\nlist of geodataframes with the polygons defining the aggregation areas\n\n\n\n\n\n\nFloodAdapt.get_benefit(name: str)\nGet a benefit from the database by name.\n\n\n\nname : str\n\nThe name of the benefit to retrieve.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object with the given name. See Benefit for details.\n\n\n\n\n\n\n: ValueError\n\nIf the benefit with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_benefits()\nGet all benefits from the database.\n\n\n\nbenefits : dict[str, Any]\n\nA dictionary containing all benefits. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_building_footprint_impacts(name: str)\nReturn a geodataframe of the impacts at the footprint level.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nfootprints : gpd.GeoDataFrame\n\nThe impact footprints for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_building_geometries()\nGet the buildings exposure that are used in Fiat.\n\n\n\nbuildings : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the buildings from FIAT exposure\n\n\n\n\n\n\nFloodAdapt.get_building_types()\nGet the building types/categories that are used in the exposure.\nThese are used to filter the buildings in the FIAT model, and can include types like: ‚ÄòResidential‚Äô, ‚ÄòCommercial‚Äô, ‚ÄòIndustrial‚Äô, etc.\n\n\n\nbuilding_types : list[str]\n\nlist of building types\n\n\n\n\n\n\nFloodAdapt.get_completed_scenarios()\nGet all completed scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each output.\n\n\n\n\n\n\nFloodAdapt.get_cyclone_track_by_index(index: int)\nGet a cyclone track from the database by index.\n\n\n\nindex : int\n\nThe index of the cyclone track to retrieve.\n\n\n\n\n\n\ncyclone : TropicalCyclone\n\nThe cyclone track object with the given index.\n\n\n\n\n\n\n: ValueError\n\nIf the cyclone track database is not defined in the site configuration. If the cyclone track with the given index does not exist.\n\n\n\n\n\n\nFloodAdapt.get_depth_conversion()\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\n\nfdc : float\n\nThe flood depth conversion.\n\n\n\n\n\n\nFloodAdapt.get_event(name: str)\nGet an event from the database by name.\n\n\n\nname : str\n\nThe name of the event to retrieve.\n\n\n\n\n\n\nevent : Union[Event, EventSet]\n\nThe event with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the event with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_events()\nGet all events from the database.\n\n\n\nevents : dict[str, Any]\n\nA dictionary containing all events. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_green_infra_table(measure_type: str)\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\n\nmeasure_type : str\n\nThe type of green infrastructure measure.\n\n\n\n\n\n\ntable : pd.DataFrame\n\nA table with different types of green infrastructure measures and their infiltration depths.\n\n\n\n\n\n\nFloodAdapt.get_index_path()\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\n\nindex_path : str\n\nThe path to the index file.\n\n\n\n\n\n\nFloodAdapt.get_infographic(name: str)\nReturn the HTML string of the infographic for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml : str\n\nThe HTML string of the infographic.\n\n\n\n\n\n\nFloodAdapt.get_infometrics(name: str)\nReturn the metrics for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nmetrics : pd.DataFrame\n\nThe metrics for the scenario.\n\n\n\n\n\n\n: FileNotFoundError\n\nIf the metrics file does not exist.\n\n\n\n\n\n\nFloodAdapt.get_max_water_level_map(name: str, rp: int = None)\nReturn the maximum water level for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None\n\n\n\n\n\n\nwater_level_map : np.ndarray\n\n2D gridded map with the maximum waterlevels for each cell.\n\n\n\n\n\n\nFloodAdapt.get_measure(name: str)\nGet a measure from the database by name.\n\n\n\nname : str\n\nThe name of the measure to retrieve.\n\n\n\n\n\n\nmeasure : Measure\n\nThe measure object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the measure with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_measures()\nGet all measures from the database.\n\n\n\nmeasures : dict[str, Any]\n\nA dictionary containing all measures. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each measure.\n\n\n\n\n\n\nFloodAdapt.get_model_boundary()\nGet the model boundary that is used in SFINCS.\n\n\n\nmodel_boundary : GeoDataFrame\n\nGeoDataFrame with the model boundary\n\n\n\n\n\n\nFloodAdapt.get_model_grid()\nGet the model grid that is used in SFINCS.\n\n\n\ngrid : QuadtreeGrid\n\nQuadtreeGrid with the model grid\n\n\n\n\n\n\nFloodAdapt.get_obs_point_timeseries(name: str)\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml_path : str\n\nThe HTML strings of the water level timeseries\n\n\n\n\n\n\nFloodAdapt.get_obs_points()\nGet the observation points specified in the site.toml.\nThese are also added to the flood hazard model. They are used as marker locations to plot water level time series in the output tab.\n\n\n\nobservation_points : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with observation points from the site.toml.\n\n\n\n\n\n\nFloodAdapt.get_projection(name: str)\nGet a projection from the database by name.\n\n\n\nname : str\n\nThe name of the projection to retrieve.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the projection with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_projections()\nGet all projections from the database.\n\n\n\nprojections : dict[str, Any]\n\nA dictionary containing all projections. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each projection.\n\n\n\n\n\n\nFloodAdapt.get_road_impacts(name: str)\nReturn a geodataframe of the impacts at roads.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nroads : gpd.GeoDataFrame\n\nThe impacted roads for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_scenario(name: str)\nGet a scenario from the database by name.\n\n\n\nname : str\n\nThe name of the scenario to retrieve.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the scenario with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_scenarios()\nGet all scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô. Each value is a list of the corresponding attribute for each scenario.\n\n\n\n\n\n\nFloodAdapt.get_slr_scn_names()\nGet all sea level rise scenario names from the database.\n\n\n\nnames : List[str]\n\nList of scenario names\n\n\n\n\n\n\nFloodAdapt.get_static_map(path: Union[str, Path])\nGet a static map from the database.\n\n\n\npath : Union[str, Path]\n\npath to the static map\n\n\n\n\n\n\nstatic_map : Union[gpd.GeoDataFrame, None]\n\ngpd.GeoDataFrame with the static map if available, None if not found\n\n\n\n\n\n\nFloodAdapt.get_strategies()\nGet all strategies from the database.\n\n\n\nstrategies : dict[str, Any]\n\nA dictionary containing all strategies. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each strategy.\n\n\n\n\n\n\nFloodAdapt.get_strategy(name: str)\nGet a strategy from the database by name.\n\n\n\nname : str\n\nThe name of the strategy to retrieve.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the strategy with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_svi_map()\nGet the SVI map that are used in Fiat.\n\n\n\nsvi_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the SVI map, None if not available\n\n\n\n\n\n\nFloodAdapt.get_topobathy_path()\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\n\ntopo_path : str\n\nThe path to the topobathy file.\n\n\n\n\n\n\nFloodAdapt.interp_slr(slr_scenario: str, year: float)\nInterpolate sea level rise for a given scenario and year.\n\n\n\nslr_scenario : str\n\nThe name of the sea level rise scenario.\n\nyear : float\n\nThe year to interpolate sea level rise for.\n\n\n\n\n\n\ninterpolated : float\n\nThe interpolated sea level rise for the given scenario and year.\n\n\n\n\n\n\nFloodAdapt.load_static_data()\nRead the static data into the cache.\nThis is used to speed up the loading of the static data.\n\n\n\nFloodAdapt.plot_event_forcing(event: Event, forcing_type: ForcingType)\nPlot forcing data for an event.\n\n\n\nevent : Event\n\nThe event object\n\nforcing_type : ForcingType\n\nThe type of forcing data to plot\n\n\n\n\n\n\nFloodAdapt.plot_slr_scenarios()\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.\n\n\n\n\n\n\nFloodAdapt.run_benefit(name: Union[str, list[str]])\nRun the benefit assessment.\n\n\n\nname : Union[str, list[str]]\n\nThe name of the benefit object to run.\n\n\n\n\n\n\nFloodAdapt.run_scenario(scenario_name: Union[str, list[str]])\nRun a scenario hazard and impacts.\n\n\n\nscenario_name : Union[str, list[str]]\n\nname(s) of the scenarios to run.\n\n\n\n\n\n\n: RuntimeError\n\nIf an error occurs while running one of the scenarios\n\n\n\n\n\n\nFloodAdapt.save_benefit(benefit: Benefit, overwrite: bool = False)\nSave a benefit object to the database.\n\n\n\nbenefit : Benefit\n\nThe benefit object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing benefit with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the benefit object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_event(event: Event, overwrite: bool = False)\nSave an event object to the database.\n\n\n\nevent : Event\n\nThe event object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing event with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the event object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_measure(measure: Measure, overwrite: bool = False)\nSave a measure object to the database.\n\n\n\nmeasure : Measure\n\nThe measure object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing measure with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the measure object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_projection(projection: Projection, overwrite: bool = False)\nSave a projection object to the database.\n\n\n\nprojection : Projection\n\nThe projection object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing projection with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the projection object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_scenario(scenario: Scenario, overwrite: bool = False)\nSave the scenario to the database.\n\n\n\nscenario : Scenario\n\nThe scenario to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing scenario with the same name (default is False).\n\n\n\n\n\n\nrun_success : bool\n\nWhether the scenario was saved successfully.\n\nerror_msg : str\n\nThe error message if the scenario was not saved successfully.\n\n\n\n\n\n\nFloodAdapt.save_strategy(strategy: Strategy, overwrite: bool = False)\nSave a strategy object to the database.\n\n\n\nstrategy : Strategy\n\nThe strategy object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing strategy with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the strategy object is not valid. If the strategy object already exists.",
    "crumbs": [
      "API Reference",
      "FloodAdapt",
      "FloodAdapt"
    ]
  },
  {
    "objectID": "api_ref/FloodAdapt.html#methods",
    "href": "api_ref/FloodAdapt.html#methods",
    "title": "FloodAdapt",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_benefit_scenarios\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\ncopy_event\nCopy an event in the database.\n\n\ncopy_measure\nCopy a measure in the database.\n\n\ncopy_projection\nCopy a projection in the database.\n\n\ncopy_strategy\nCopy a strategy in the database.\n\n\ncreate_benefit\nCreate a new benefit object.\n\n\ncreate_benefit_scenarios\nCreate the benefit scenarios.\n\n\ncreate_event\nCreate a event object from a dictionary of attributes.\n\n\ncreate_event_set\nCreate a event set object from a dictionary of attributes.\n\n\ncreate_measure\nCreate a measure from a dictionary of attributes and a type string.\n\n\ncreate_projection\nCreate a new projection object.\n\n\ncreate_scenario\nCreate a new scenario object.\n\n\ncreate_strategy\nCreate a new strategy object.\n\n\ndelete_benefit\nDelete a benefit object from the database.\n\n\ndelete_event\nDelete an event from the database.\n\n\ndelete_measure\nDelete an measure from the database.\n\n\ndelete_projection\nDelete a projection from the database.\n\n\ndelete_scenario\nDelete a scenario from the database.\n\n\ndelete_strategy\nDelete a strategy from the database.\n\n\nget_aggregated_benefits\nGet the aggregation benefits for a benefit assessment.\n\n\nget_aggregated_impacts\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\nget_aggregation_areas\nGet a list of the aggregation areas that are provided in the site configuration.\n\n\nget_benefit\nGet a benefit from the database by name.\n\n\nget_benefits\nGet all benefits from the database.\n\n\nget_building_footprint_impacts\nReturn a geodataframe of the impacts at the footprint level.\n\n\nget_building_geometries\nGet the buildings exposure that are used in Fiat.\n\n\nget_building_types\nGet the building types/categories that are used in the exposure.\n\n\nget_completed_scenarios\nGet all completed scenarios from the database.\n\n\nget_cyclone_track_by_index\nGet a cyclone track from the database by index.\n\n\nget_depth_conversion\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\nget_event\nGet an event from the database by name.\n\n\nget_events\nGet all events from the database.\n\n\nget_green_infra_table\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\nget_index_path\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\nget_infographic\nReturn the HTML string of the infographic for the given scenario.\n\n\nget_infometrics\nReturn the metrics for the given scenario.\n\n\nget_max_water_level_map\nReturn the maximum water level for the given scenario.\n\n\nget_measure\nGet a measure from the database by name.\n\n\nget_measures\nGet all measures from the database.\n\n\nget_model_boundary\nGet the model boundary that is used in SFINCS.\n\n\nget_model_grid\nGet the model grid that is used in SFINCS.\n\n\nget_obs_point_timeseries\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\nget_obs_points\nGet the observation points specified in the site.toml.\n\n\nget_projection\nGet a projection from the database by name.\n\n\nget_projections\nGet all projections from the database.\n\n\nget_road_impacts\nReturn a geodataframe of the impacts at roads.\n\n\nget_scenario\nGet a scenario from the database by name.\n\n\nget_scenarios\nGet all scenarios from the database.\n\n\nget_slr_scn_names\nGet all sea level rise scenario names from the database.\n\n\nget_static_map\nGet a static map from the database.\n\n\nget_strategies\nGet all strategies from the database.\n\n\nget_strategy\nGet a strategy from the database by name.\n\n\nget_svi_map\nGet the SVI map that are used in Fiat.\n\n\nget_topobathy_path\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\ninterp_slr\nInterpolate sea level rise for a given scenario and year.\n\n\nload_static_data\nRead the static data into the cache.\n\n\nplot_event_forcing\nPlot forcing data for an event.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\nrun_benefit\nRun the benefit assessment.\n\n\nrun_scenario\nRun a scenario hazard and impacts.\n\n\nsave_benefit\nSave a benefit object to the database.\n\n\nsave_event\nSave an event object to the database.\n\n\nsave_measure\nSave a measure object to the database.\n\n\nsave_projection\nSave a projection object to the database.\n\n\nsave_scenario\nSave the scenario to the database.\n\n\nsave_strategy\nSave a strategy object to the database.\n\n\n\n\n\nFloodAdapt.check_benefit_scenarios(benefit: Benefit)\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\n\nbenefit : Benefit\n\nThe benefit object to check.\n\n\n\n\n\n\nscenarios : pd.DataFrame\n\nA dataframe with the scenarios needed for this benefit assessment run.\n\n\n\n\n\n\nFloodAdapt.copy_event(old_name: str, new_name: str, new_description: str)\nCopy an event in the database.\n\n\n\nold_name : str\n\nThe name of the event to copy.\n\nnew_name : str\n\nThe name of the new event.\n\nnew_description : str\n\nThe description of the new event\n\n\n\n\n\n\nFloodAdapt.copy_measure(old_name: str, new_name: str, new_description: str)\nCopy a measure in the database.\n\n\n\nold_name : str\n\nThe name of the measure to copy.\n\nnew_name : str\n\nThe name of the new measure.\n\nnew_description : str\n\nThe description of the new measure\n\n\n\n\n\n\nFloodAdapt.copy_projection(old_name: str, new_name: str, new_description: str)\nCopy a projection in the database.\n\n\n\nold_name : str\n\nThe name of the projection to copy.\n\nnew_name : str\n\nThe name of the new projection.\n\nnew_description : str\n\nThe description of the new projection\n\n\n\n\n\n\nFloodAdapt.copy_strategy(old_name: str, new_name: str, new_description: str)\nCopy a strategy in the database.\n\n\n\nold_name : str\n\nThe name of the strategy to copy.\n\nnew_name : str\n\nThe name of the new strategy.\n\nnew_description : str\n\nThe description of the new strategy\n\n\n\n\n\n\nFloodAdapt.create_benefit(attrs: dict[str, Any])\nCreate a new benefit object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the benefit object to create. Should adhere to the Benefit schema.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Benefit schema.\n\n\n\n\n\n\nFloodAdapt.create_benefit_scenarios(benefit: Benefit)\nCreate the benefit scenarios.\n\n\n\nbenefit : Benefit\n\nThe benefit object to create scenarios for.\n\n\n\n\n\n\nFloodAdapt.create_event(attrs: dict[str, Any] | Event)\nCreate a event object from a dictionary of attributes.\n\n\n\nattrs : Event[str, Any]\n\nDictionary of attributes\n\n\n\n\n\n\nevent : Event\n\nDepending on attrs.template an event object. Can be of type: Synthetic, Historical, Hurricane.\n\n\n\n\n\n\nFloodAdapt.create_event_set(\n    attrs: dict[str, Any] | EventSet,\n    sub_events: list[Event],\n)\nCreate a event set object from a dictionary of attributes.\n\n\n\nattrs : EventSet[str, Any]\n\nDictionary of attributes\n\nsub_events : list[Event]\n\nList of events in the event set\n\n\n\n\n\n\nevent_set : EventSet\n\nEventSet object\n\n\n\n\n\n\nFloodAdapt.create_measure(attrs: dict[str, Any], type: str = None)\nCreate a measure from a dictionary of attributes and a type string.\n\n\n\nattrs : dict[str, Any]\n\nDictionary of attributes for the measure.\n\ntype : str = None\n\nType of measure to create.\n\n\n\n\n\n\nmeasure : Measure\n\nMeasure object.\n\n\n\n\n\n\nFloodAdapt.create_projection(attrs: dict[str, Any])\nCreate a new projection object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the projection object to create. Should adhere to the Projection schema.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Projection schema.\n\n\n\n\n\n\nFloodAdapt.create_scenario(attrs: dict[str, Any])\nCreate a new scenario object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the scenario object to create. Should adhere to the Scenario schema.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Scenario schema.\n\n\n\n\n\n\nFloodAdapt.create_strategy(attrs: dict[str, Any])\nCreate a new strategy object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the strategy object to create. Should adhere to the Strategy schema.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object\n\n\n\n\n\n\n: ValueError\n\nIf the strategy with the given name does not exist. If attrs does not adhere to the Strategy schema.\n\n\n\n\n\n\nFloodAdapt.delete_benefit(name: str)\nDelete a benefit object from the database.\n\n\n\nname : str\n\nThe name of the benefit object to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the benefit object does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_event(name: str)\nDelete an event from the database.\n\n\n\nname : str\n\nThe name of the event to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the event does not exist. If the event is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_measure(name: str)\nDelete an measure from the database.\n\n\n\nname : str\n\nThe name of the measure to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the measure does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_projection(name: str)\nDelete a projection from the database.\n\n\n\nname : str\n\nThe name of the projection to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the projection does not exist. If the projection is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_scenario(name: str)\nDelete a scenario from the database.\n\n\n\nname : str\n\nThe name of the scenario to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the scenario does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_strategy(name: str)\nDelete a strategy from the database.\n\n\n\nname : str\n\nThe name of the strategy to delete.\n\n\n\n\n\n\n: ValueError\n\nIf the strategy does not exist.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_benefits(name: str)\nGet the aggregation benefits for a benefit assessment.\n\n\n\nname : str\n\nThe name of the benefit assessment.\n\n\n\n\n\n\naggregated_benefits : gpd.GeoDataFrame\n\nThe aggregation benefits for the benefit assessment.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_impacts(name: str)\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\naggr_impacts : dict[str, gpd.GeoDataFrame]\n\nThe aggregated impacts for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_aggregation_areas()\nGet a list of the aggregation areas that are provided in the site configuration.\nThese are expected to much the ones in the FIAT model.\n\n\n\naggregation_areas : dict[str, GeoDataFrame]\n\nlist of geodataframes with the polygons defining the aggregation areas\n\n\n\n\n\n\nFloodAdapt.get_benefit(name: str)\nGet a benefit from the database by name.\n\n\n\nname : str\n\nThe name of the benefit to retrieve.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object with the given name. See Benefit for details.\n\n\n\n\n\n\n: ValueError\n\nIf the benefit with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_benefits()\nGet all benefits from the database.\n\n\n\nbenefits : dict[str, Any]\n\nA dictionary containing all benefits. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_building_footprint_impacts(name: str)\nReturn a geodataframe of the impacts at the footprint level.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nfootprints : gpd.GeoDataFrame\n\nThe impact footprints for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_building_geometries()\nGet the buildings exposure that are used in Fiat.\n\n\n\nbuildings : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the buildings from FIAT exposure\n\n\n\n\n\n\nFloodAdapt.get_building_types()\nGet the building types/categories that are used in the exposure.\nThese are used to filter the buildings in the FIAT model, and can include types like: ‚ÄòResidential‚Äô, ‚ÄòCommercial‚Äô, ‚ÄòIndustrial‚Äô, etc.\n\n\n\nbuilding_types : list[str]\n\nlist of building types\n\n\n\n\n\n\nFloodAdapt.get_completed_scenarios()\nGet all completed scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each output.\n\n\n\n\n\n\nFloodAdapt.get_cyclone_track_by_index(index: int)\nGet a cyclone track from the database by index.\n\n\n\nindex : int\n\nThe index of the cyclone track to retrieve.\n\n\n\n\n\n\ncyclone : TropicalCyclone\n\nThe cyclone track object with the given index.\n\n\n\n\n\n\n: ValueError\n\nIf the cyclone track database is not defined in the site configuration. If the cyclone track with the given index does not exist.\n\n\n\n\n\n\nFloodAdapt.get_depth_conversion()\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\n\nfdc : float\n\nThe flood depth conversion.\n\n\n\n\n\n\nFloodAdapt.get_event(name: str)\nGet an event from the database by name.\n\n\n\nname : str\n\nThe name of the event to retrieve.\n\n\n\n\n\n\nevent : Union[Event, EventSet]\n\nThe event with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the event with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_events()\nGet all events from the database.\n\n\n\nevents : dict[str, Any]\n\nA dictionary containing all events. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_green_infra_table(measure_type: str)\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\n\nmeasure_type : str\n\nThe type of green infrastructure measure.\n\n\n\n\n\n\ntable : pd.DataFrame\n\nA table with different types of green infrastructure measures and their infiltration depths.\n\n\n\n\n\n\nFloodAdapt.get_index_path()\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\n\nindex_path : str\n\nThe path to the index file.\n\n\n\n\n\n\nFloodAdapt.get_infographic(name: str)\nReturn the HTML string of the infographic for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml : str\n\nThe HTML string of the infographic.\n\n\n\n\n\n\nFloodAdapt.get_infometrics(name: str)\nReturn the metrics for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nmetrics : pd.DataFrame\n\nThe metrics for the scenario.\n\n\n\n\n\n\n: FileNotFoundError\n\nIf the metrics file does not exist.\n\n\n\n\n\n\nFloodAdapt.get_max_water_level_map(name: str, rp: int = None)\nReturn the maximum water level for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None\n\n\n\n\n\n\nwater_level_map : np.ndarray\n\n2D gridded map with the maximum waterlevels for each cell.\n\n\n\n\n\n\nFloodAdapt.get_measure(name: str)\nGet a measure from the database by name.\n\n\n\nname : str\n\nThe name of the measure to retrieve.\n\n\n\n\n\n\nmeasure : Measure\n\nThe measure object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the measure with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_measures()\nGet all measures from the database.\n\n\n\nmeasures : dict[str, Any]\n\nA dictionary containing all measures. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each measure.\n\n\n\n\n\n\nFloodAdapt.get_model_boundary()\nGet the model boundary that is used in SFINCS.\n\n\n\nmodel_boundary : GeoDataFrame\n\nGeoDataFrame with the model boundary\n\n\n\n\n\n\nFloodAdapt.get_model_grid()\nGet the model grid that is used in SFINCS.\n\n\n\ngrid : QuadtreeGrid\n\nQuadtreeGrid with the model grid\n\n\n\n\n\n\nFloodAdapt.get_obs_point_timeseries(name: str)\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml_path : str\n\nThe HTML strings of the water level timeseries\n\n\n\n\n\n\nFloodAdapt.get_obs_points()\nGet the observation points specified in the site.toml.\nThese are also added to the flood hazard model. They are used as marker locations to plot water level time series in the output tab.\n\n\n\nobservation_points : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with observation points from the site.toml.\n\n\n\n\n\n\nFloodAdapt.get_projection(name: str)\nGet a projection from the database by name.\n\n\n\nname : str\n\nThe name of the projection to retrieve.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the projection with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_projections()\nGet all projections from the database.\n\n\n\nprojections : dict[str, Any]\n\nA dictionary containing all projections. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each projection.\n\n\n\n\n\n\nFloodAdapt.get_road_impacts(name: str)\nReturn a geodataframe of the impacts at roads.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nroads : gpd.GeoDataFrame\n\nThe impacted roads for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_scenario(name: str)\nGet a scenario from the database by name.\n\n\n\nname : str\n\nThe name of the scenario to retrieve.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the scenario with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_scenarios()\nGet all scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô. Each value is a list of the corresponding attribute for each scenario.\n\n\n\n\n\n\nFloodAdapt.get_slr_scn_names()\nGet all sea level rise scenario names from the database.\n\n\n\nnames : List[str]\n\nList of scenario names\n\n\n\n\n\n\nFloodAdapt.get_static_map(path: Union[str, Path])\nGet a static map from the database.\n\n\n\npath : Union[str, Path]\n\npath to the static map\n\n\n\n\n\n\nstatic_map : Union[gpd.GeoDataFrame, None]\n\ngpd.GeoDataFrame with the static map if available, None if not found\n\n\n\n\n\n\nFloodAdapt.get_strategies()\nGet all strategies from the database.\n\n\n\nstrategies : dict[str, Any]\n\nA dictionary containing all strategies. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each strategy.\n\n\n\n\n\n\nFloodAdapt.get_strategy(name: str)\nGet a strategy from the database by name.\n\n\n\nname : str\n\nThe name of the strategy to retrieve.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object with the given name.\n\n\n\n\n\n\n: ValueError\n\nIf the strategy with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_svi_map()\nGet the SVI map that are used in Fiat.\n\n\n\nsvi_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the SVI map, None if not available\n\n\n\n\n\n\nFloodAdapt.get_topobathy_path()\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\n\ntopo_path : str\n\nThe path to the topobathy file.\n\n\n\n\n\n\nFloodAdapt.interp_slr(slr_scenario: str, year: float)\nInterpolate sea level rise for a given scenario and year.\n\n\n\nslr_scenario : str\n\nThe name of the sea level rise scenario.\n\nyear : float\n\nThe year to interpolate sea level rise for.\n\n\n\n\n\n\ninterpolated : float\n\nThe interpolated sea level rise for the given scenario and year.\n\n\n\n\n\n\nFloodAdapt.load_static_data()\nRead the static data into the cache.\nThis is used to speed up the loading of the static data.\n\n\n\nFloodAdapt.plot_event_forcing(event: Event, forcing_type: ForcingType)\nPlot forcing data for an event.\n\n\n\nevent : Event\n\nThe event object\n\nforcing_type : ForcingType\n\nThe type of forcing data to plot\n\n\n\n\n\n\nFloodAdapt.plot_slr_scenarios()\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.\n\n\n\n\n\n\nFloodAdapt.run_benefit(name: Union[str, list[str]])\nRun the benefit assessment.\n\n\n\nname : Union[str, list[str]]\n\nThe name of the benefit object to run.\n\n\n\n\n\n\nFloodAdapt.run_scenario(scenario_name: Union[str, list[str]])\nRun a scenario hazard and impacts.\n\n\n\nscenario_name : Union[str, list[str]]\n\nname(s) of the scenarios to run.\n\n\n\n\n\n\n: RuntimeError\n\nIf an error occurs while running one of the scenarios\n\n\n\n\n\n\nFloodAdapt.save_benefit(benefit: Benefit, overwrite: bool = False)\nSave a benefit object to the database.\n\n\n\nbenefit : Benefit\n\nThe benefit object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing benefit with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the benefit object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_event(event: Event, overwrite: bool = False)\nSave an event object to the database.\n\n\n\nevent : Event\n\nThe event object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing event with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the event object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_measure(measure: Measure, overwrite: bool = False)\nSave a measure object to the database.\n\n\n\nmeasure : Measure\n\nThe measure object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing measure with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the measure object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_projection(projection: Projection, overwrite: bool = False)\nSave a projection object to the database.\n\n\n\nprojection : Projection\n\nThe projection object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing projection with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the projection object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_scenario(scenario: Scenario, overwrite: bool = False)\nSave the scenario to the database.\n\n\n\nscenario : Scenario\n\nThe scenario to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing scenario with the same name (default is False).\n\n\n\n\n\n\nrun_success : bool\n\nWhether the scenario was saved successfully.\n\nerror_msg : str\n\nThe error message if the scenario was not saved successfully.\n\n\n\n\n\n\nFloodAdapt.save_strategy(strategy: Strategy, overwrite: bool = False)\nSave a strategy object to the database.\n\n\n\nstrategy : Strategy\n\nThe strategy object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing strategy with the same name (default is False).\n\n\n\n\n\n\n: ValueError\n\nIf the strategy object is not valid. If the strategy object already exists.",
    "crumbs": [
      "API Reference",
      "FloodAdapt",
      "FloodAdapt"
    ]
  },
  {
    "objectID": "api_ref/FloodWall.html",
    "href": "api_ref/FloodWall.html",
    "title": "FloodWall",
    "section": "",
    "text": "objects.FloodWall()\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?"
  },
  {
    "objectID": "api_ref/FloodWall.html#attributes",
    "href": "api_ref/FloodWall.html#attributes",
    "title": "FloodWall",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?"
  },
  {
    "objectID": "api_ref/GreenInfrastructure.html",
    "href": "api_ref/GreenInfrastructure.html",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "objects.GreenInfrastructure()\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]"
  },
  {
    "objectID": "api_ref/GreenInfrastructure.html#attributes",
    "href": "api_ref/GreenInfrastructure.html#attributes",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure."
  },
  {
    "objectID": "api_ref/GreenInfrastructure.html#methods",
    "href": "api_ref/GreenInfrastructure.html#methods",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]"
  },
  {
    "objectID": "api_ref/HurricaneEvent.html",
    "href": "api_ref/HurricaneEvent.html",
    "title": "HurricaneEvent",
    "section": "",
    "text": "objects.HurricaneEvent()\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track."
  },
  {
    "objectID": "api_ref/HurricaneEvent.html#attributes",
    "href": "api_ref/HurricaneEvent.html#attributes",
    "title": "HurricaneEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track."
  },
  {
    "objectID": "api_ref/Measure.html",
    "href": "api_ref/Measure.html",
    "title": "Measure",
    "section": "",
    "text": "objects.Measure()\nThe expected variables and data types of attributes common to all measures.\nA measure is a collection of attributes that can be applied to a model.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values."
  },
  {
    "objectID": "api_ref/Measure.html#attributes",
    "href": "api_ref/Measure.html#attributes",
    "title": "Measure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values."
  },
  {
    "objectID": "api_ref/Mode.html",
    "href": "api_ref/Mode.html",
    "title": "Mode",
    "section": "",
    "text": "objects.Mode()\nClass describing the accepted input for the variable mode in Event.\n\n\n\nsingle_event : The single event mode.\n\n\n\nrisk : The risk mode."
  },
  {
    "objectID": "api_ref/Mode.html#attributes",
    "href": "api_ref/Mode.html#attributes",
    "title": "Mode",
    "section": "",
    "text": "single_event : The single event mode.\n\n\n\nrisk : The risk mode."
  },
  {
    "objectID": "api_ref/PhysicalProjection.html",
    "href": "api_ref/PhysicalProjection.html",
    "title": "PhysicalProjection",
    "section": "",
    "text": "objects.PhysicalProjection()\nThe accepted input for a physical projection in FloodAdapt.\n\n\n\nsea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0."
  },
  {
    "objectID": "api_ref/PhysicalProjection.html#attributes",
    "href": "api_ref/PhysicalProjection.html#attributes",
    "title": "PhysicalProjection",
    "section": "",
    "text": "sea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0."
  },
  {
    "objectID": "api_ref/Pump.html",
    "href": "api_ref/Pump.html",
    "title": "Pump",
    "section": "",
    "text": "objects.Pump()\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?"
  },
  {
    "objectID": "api_ref/Pump.html#attributes",
    "href": "api_ref/Pump.html#attributes",
    "title": "Pump",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?"
  },
  {
    "objectID": "api_ref/SelectionType.html",
    "href": "api_ref/SelectionType.html",
    "title": "SelectionType",
    "section": "",
    "text": "objects.SelectionType()\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\nIt is used to determine where to apply the measure to a model.\n\n\n\naggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database."
  },
  {
    "objectID": "api_ref/SelectionType.html#attributes",
    "href": "api_ref/SelectionType.html#attributes",
    "title": "SelectionType",
    "section": "",
    "text": "aggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database."
  },
  {
    "objectID": "api_ref/Site.html",
    "href": "api_ref/Site.html",
    "title": "Site",
    "section": "",
    "text": "Site()\nThe expected variables and data types of attributes of the Site class.\n\n\n\nname : str\n\nName of the site.\n\ndescription : str\n\nDescription of the site. Defaults to ‚Äú‚Äú.\n\nlat : float\n\nLatitude of the site.\n\nlon : float\n\nLongitude of the site.\n\nstandard_objects : StandardObjectModel, default=StandardObjectModel()\n\nStandard objects of the site.\n\ngui : GuiModel\n\nGUI model of the site.\n\nsfincs : SfincsModel\n\nSFincs model of the site.\n\nfiat : FiatModel\n\nFiat model of the site.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nCreate Site from toml file.\n\n\nsave\nWrite toml file from model object.\n\n\n\n\n\nSite.load_file(filepath: Union[str, os.PathLike])\nCreate Site from toml file.\n\n\n\nSite.save(\n    filepath: Union[str, os.PathLike],\n    sfincs: str = 'sfincs.toml',\n    fiat: str = 'fiat.toml',\n    gui: str = 'gui.toml',\n)\nWrite toml file from model object.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "api_ref/Site.html#attributes",
    "href": "api_ref/Site.html#attributes",
    "title": "Site",
    "section": "",
    "text": "name : str\n\nName of the site.\n\ndescription : str\n\nDescription of the site. Defaults to ‚Äú‚Äú.\n\nlat : float\n\nLatitude of the site.\n\nlon : float\n\nLongitude of the site.\n\nstandard_objects : StandardObjectModel, default=StandardObjectModel()\n\nStandard objects of the site.\n\ngui : GuiModel\n\nGUI model of the site.\n\nsfincs : SfincsModel\n\nSFincs model of the site.\n\nfiat : FiatModel\n\nFiat model of the site.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "api_ref/Site.html#methods",
    "href": "api_ref/Site.html#methods",
    "title": "Site",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nCreate Site from toml file.\n\n\nsave\nWrite toml file from model object.\n\n\n\n\n\nSite.load_file(filepath: Union[str, os.PathLike])\nCreate Site from toml file.\n\n\n\nSite.save(\n    filepath: Union[str, os.PathLike],\n    sfincs: str = 'sfincs.toml',\n    fiat: str = 'fiat.toml',\n    gui: str = 'gui.toml',\n)\nWrite toml file from model object.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "api_ref/Strategy.html",
    "href": "api_ref/Strategy.html",
    "title": "Strategy",
    "section": "",
    "text": "objects.Strategy()\nClass representing a strategy in FloodAdapt.\nA strategy is a collection of measures that can be applied to a model.\n\n\n\nmeasures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database."
  },
  {
    "objectID": "api_ref/Strategy.html#attributes",
    "href": "api_ref/Strategy.html#attributes",
    "title": "Strategy",
    "section": "",
    "text": "measures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database."
  },
  {
    "objectID": "api_ref/Strategy.html#methods",
    "href": "api_ref/Strategy.html#methods",
    "title": "Strategy",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database."
  },
  {
    "objectID": "api_ref/SyntheticEvent.html",
    "href": "api_ref/SyntheticEvent.html",
    "title": "SyntheticEvent",
    "section": "",
    "text": "objects.SyntheticEvent()\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "api_ref/SyntheticEvent.html#attributes",
    "href": "api_ref/SyntheticEvent.html#attributes",
    "title": "SyntheticEvent",
    "section": "",
    "text": "time : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "api_ref/TimeFrame.html",
    "href": "api_ref/TimeFrame.html",
    "title": "TimeFrame",
    "section": "",
    "text": "objects.TimeFrame()\nClass representing a time frame for a simulation.\n\n\n\nstart_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration."
  },
  {
    "objectID": "api_ref/TimeFrame.html#attributes",
    "href": "api_ref/TimeFrame.html#attributes",
    "title": "TimeFrame",
    "section": "",
    "text": "start_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration."
  },
  {
    "objectID": "api_ref/UnitTypesDirection.html",
    "href": "api_ref/UnitTypesDirection.html",
    "title": "UnitTypesDirection",
    "section": "",
    "text": "unit_system.UnitTypesDirection()\nUnits of direction.\n\n\n\ndegrees : degrees",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDirection"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesDirection.html#attributes",
    "href": "api_ref/UnitTypesDirection.html#attributes",
    "title": "UnitTypesDirection",
    "section": "",
    "text": "degrees : degrees",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDirection"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesIntensity.html",
    "href": "api_ref/UnitTypesIntensity.html",
    "title": "UnitTypesIntensity",
    "section": "",
    "text": "unit_system.UnitTypesIntensity()\nUnits of intensity.\n\n\n\ninch_hr : inch per hour\n\n\n\nmm_hr : millimeter per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesIntensity"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesIntensity.html#attributes",
    "href": "api_ref/UnitTypesIntensity.html#attributes",
    "title": "UnitTypesIntensity",
    "section": "",
    "text": "inch_hr : inch per hour\n\n\n\nmm_hr : millimeter per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesIntensity"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesTime.html",
    "href": "api_ref/UnitTypesTime.html",
    "title": "UnitTypesTime",
    "section": "",
    "text": "unit_system.UnitTypesTime()\nUnits of time.\n\n\n\nseconds : seconds\n\n\n\nminutes : minutes\n\n\n\nhours : hours\n\n\n\ndays : days",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesTime"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesTime.html#attributes",
    "href": "api_ref/UnitTypesTime.html#attributes",
    "title": "UnitTypesTime",
    "section": "",
    "text": "seconds : seconds\n\n\n\nminutes : minutes\n\n\n\nhours : hours\n\n\n\ndays : days",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesTime"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesVolume.html",
    "href": "api_ref/UnitTypesVolume.html",
    "title": "UnitTypesVolume",
    "section": "",
    "text": "unit_system.UnitTypesVolume()\nUnits of volume.\n\n\n\nm3 : cubic meters\n\n\n\ncf : cubic feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVolume"
    ]
  },
  {
    "objectID": "api_ref/UnitTypesVolume.html#attributes",
    "href": "api_ref/UnitTypesVolume.html#attributes",
    "title": "UnitTypesVolume",
    "section": "",
    "text": "m3 : cubic meters\n\n\n\ncf : cubic feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVolume"
    ]
  },
  {
    "objectID": "api_ref/UnitfulDirection.html",
    "href": "api_ref/UnitfulDirection.html",
    "title": "UnitfulDirection",
    "section": "",
    "text": "unit_system.UnitfulDirection()\nCombination of direction and unit.\n\n\n\nvalue : float\n\nThe direction value, must be greater than or equal to 0 and less than or equal to 360.\n\nunits : UnitTypesDirection\n\nThe unit of direction.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDirection"
    ]
  },
  {
    "objectID": "api_ref/UnitfulDirection.html#attributes",
    "href": "api_ref/UnitfulDirection.html#attributes",
    "title": "UnitfulDirection",
    "section": "",
    "text": "value : float\n\nThe direction value, must be greater than or equal to 0 and less than or equal to 360.\n\nunits : UnitTypesDirection\n\nThe unit of direction.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDirection"
    ]
  },
  {
    "objectID": "api_ref/UnitfulHeight.html",
    "href": "api_ref/UnitfulHeight.html",
    "title": "UnitfulHeight",
    "section": "",
    "text": "unit_system.UnitfulHeight()\nCombination of height and unit.\n\n\n\nvalue : float\n\nThe height value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of height.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulHeight"
    ]
  },
  {
    "objectID": "api_ref/UnitfulHeight.html#attributes",
    "href": "api_ref/UnitfulHeight.html#attributes",
    "title": "UnitfulHeight",
    "section": "",
    "text": "value : float\n\nThe height value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of height.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulHeight"
    ]
  },
  {
    "objectID": "api_ref/UnitfulLength.html",
    "href": "api_ref/UnitfulLength.html",
    "title": "UnitfulLength",
    "section": "",
    "text": "unit_system.UnitfulLength()\nCombination of length and unit.\n\n\n\nvalue : float\n\nThe length value.\n\nunits : UnitTypesLength\n\nThe unit of length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLength"
    ]
  },
  {
    "objectID": "api_ref/UnitfulLength.html#attributes",
    "href": "api_ref/UnitfulLength.html#attributes",
    "title": "UnitfulLength",
    "section": "",
    "text": "value : float\n\nThe length value.\n\nunits : UnitTypesLength\n\nThe unit of length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLength"
    ]
  },
  {
    "objectID": "api_ref/UnitfulTime.html",
    "href": "api_ref/UnitfulTime.html",
    "title": "UnitfulTime",
    "section": "",
    "text": "unit_system.UnitfulTime()\nCombination of time and unit.\n\n\n\nvalue : float\n\nThe time value.\n\nunits : UnitTypesTime\n\nThe unit of time.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_timedelta\nConvert given timedelta to UnitfulTime object.\n\n\nto_timedelta\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n\n\nunit_system.UnitfulTime.from_timedelta(td: timedelta)\nConvert given timedelta to UnitfulTime object.\n\n\n\nunit_system.UnitfulTime.to_timedelta()\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n : datetime.timedelta\n\ndatetime.timedelta object with representation: (days, seconds, microseconds)",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "api_ref/UnitfulTime.html#attributes",
    "href": "api_ref/UnitfulTime.html#attributes",
    "title": "UnitfulTime",
    "section": "",
    "text": "value : float\n\nThe time value.\n\nunits : UnitTypesTime\n\nThe unit of time.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "api_ref/UnitfulTime.html#methods",
    "href": "api_ref/UnitfulTime.html#methods",
    "title": "UnitfulTime",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_timedelta\nConvert given timedelta to UnitfulTime object.\n\n\nto_timedelta\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n\n\nunit_system.UnitfulTime.from_timedelta(td: timedelta)\nConvert given timedelta to UnitfulTime object.\n\n\n\nunit_system.UnitfulTime.to_timedelta()\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n : datetime.timedelta\n\ndatetime.timedelta object with representation: (days, seconds, microseconds)",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "api_ref/UnitfulVolume.html",
    "href": "api_ref/UnitfulVolume.html",
    "title": "UnitfulVolume",
    "section": "",
    "text": "unit_system.UnitfulVolume()\nCombination of volume and unit.\n\n\n\nvalue : float\n\nThe volume value, must be greater than or equal to 0.\n\nunits : UnitTypesVolume\n\nThe unit of volume.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVolume"
    ]
  },
  {
    "objectID": "api_ref/UnitfulVolume.html#attributes",
    "href": "api_ref/UnitfulVolume.html#attributes",
    "title": "UnitfulVolume",
    "section": "",
    "text": "value : float\n\nThe volume value, must be greater than or equal to 0.\n\nunits : UnitTypesVolume\n\nThe unit of volume.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVolume"
    ]
  },
  {
    "objectID": "api_ref/VerticalReference.html",
    "href": "api_ref/VerticalReference.html",
    "title": "VerticalReference",
    "section": "",
    "text": "unit_system.VerticalReference()\nVertical reference for height.\n\n\n\nfloodmap : Use the floodmap as reference.\n\n\n\ndatum : Use the datum as reference.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "VerticalReference"
    ]
  },
  {
    "objectID": "api_ref/VerticalReference.html#attributes",
    "href": "api_ref/VerticalReference.html#attributes",
    "title": "VerticalReference",
    "section": "",
    "text": "floodmap : Use the floodmap as reference.\n\n\n\ndatum : Use the datum as reference.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "VerticalReference"
    ]
  },
  {
    "objectID": "api_ref/objects/Benefit.html",
    "href": "api_ref/objects/Benefit.html",
    "title": "Benefit",
    "section": "",
    "text": "objects.Benefit()\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\n\nname : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "Benefit"
    ]
  },
  {
    "objectID": "api_ref/objects/Benefit.html#attributes",
    "href": "api_ref/objects/Benefit.html#attributes",
    "title": "Benefit",
    "section": "",
    "text": "name : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "Benefit"
    ]
  },
  {
    "objectID": "api_ref/objects/CurrentSituationModel.html",
    "href": "api_ref/objects/CurrentSituationModel.html",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "objects.CurrentSituationModel()\nThe accepted input for a current situation in FloodAdapt.\n\n\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "CurrentSituationModel"
    ]
  },
  {
    "objectID": "api_ref/objects/CurrentSituationModel.html#attributes",
    "href": "api_ref/objects/CurrentSituationModel.html#attributes",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "projection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "CurrentSituationModel"
    ]
  },
  {
    "objectID": "api_ref/objects/Event.html",
    "href": "api_ref/objects/Event.html",
    "title": "Event",
    "section": "",
    "text": "objects.Event()\nThe accepted input for an event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nload_file\nLoad object from file.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "api_ref/objects/Event.html#attributes",
    "href": "api_ref/objects/Event.html#attributes",
    "title": "Event",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "api_ref/objects/Event.html#methods",
    "href": "api_ref/objects/Event.html#methods",
    "title": "Event",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nload_file\nLoad object from file.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.load_file(file_path: Path | str | os.PathLike)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "api_ref/objects/FloodProof.html",
    "href": "api_ref/objects/FloodProof.html",
    "title": "FloodProof",
    "section": "",
    "text": "objects.FloodProof()\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodProof"
    ]
  },
  {
    "objectID": "api_ref/objects/FloodProof.html#attributes",
    "href": "api_ref/objects/FloodProof.html#attributes",
    "title": "FloodProof",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodProof"
    ]
  },
  {
    "objectID": "api_ref/objects/ForcingType.html",
    "href": "api_ref/objects/ForcingType.html",
    "title": "ForcingType",
    "section": "",
    "text": "objects.ForcingType()\nEnum class for the different types of forcing parameters.\n\n\n\nRAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "ForcingType"
    ]
  },
  {
    "objectID": "api_ref/objects/ForcingType.html#attributes",
    "href": "api_ref/objects/ForcingType.html#attributes",
    "title": "ForcingType",
    "section": "",
    "text": "RAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "ForcingType"
    ]
  },
  {
    "objectID": "api_ref/objects/HistoricalEvent.html",
    "href": "api_ref/objects/HistoricalEvent.html",
    "title": "HistoricalEvent",
    "section": "",
    "text": "objects.HistoricalEvent()\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HistoricalEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/HistoricalEvent.html#attributes",
    "href": "api_ref/objects/HistoricalEvent.html#attributes",
    "title": "HistoricalEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HistoricalEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/IForcing.html",
    "href": "api_ref/objects/IForcing.html",
    "title": "IForcing",
    "section": "",
    "text": "objects.IForcing()\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\n\n\n\nName\nDescription\n\n\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "IForcing"
    ]
  },
  {
    "objectID": "api_ref/objects/IForcing.html#methods",
    "href": "api_ref/objects/IForcing.html#methods",
    "title": "IForcing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "IForcing"
    ]
  },
  {
    "objectID": "api_ref/objects/MeasureType.html",
    "href": "api_ref/objects/MeasureType.html",
    "title": "MeasureType",
    "section": "",
    "text": "objects.MeasureType()\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\nEach type of measure is associated with a category (hazard or impact) and can be used to determine the type of measure.\n\n\n\nfloodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "MeasureType"
    ]
  },
  {
    "objectID": "api_ref/objects/MeasureType.html#attributes",
    "href": "api_ref/objects/MeasureType.html#attributes",
    "title": "MeasureType",
    "section": "",
    "text": "floodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "MeasureType"
    ]
  },
  {
    "objectID": "api_ref/objects/PhysicalProjection.html",
    "href": "api_ref/objects/PhysicalProjection.html",
    "title": "PhysicalProjection",
    "section": "",
    "text": "objects.PhysicalProjection()\nThe accepted input for a physical projection in FloodAdapt.\n\n\n\nsea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "PhysicalProjection"
    ]
  },
  {
    "objectID": "api_ref/objects/PhysicalProjection.html#attributes",
    "href": "api_ref/objects/PhysicalProjection.html#attributes",
    "title": "PhysicalProjection",
    "section": "",
    "text": "sea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "PhysicalProjection"
    ]
  },
  {
    "objectID": "api_ref/objects/Pump.html",
    "href": "api_ref/objects/Pump.html",
    "title": "Pump",
    "section": "",
    "text": "objects.Pump()\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Pump"
    ]
  },
  {
    "objectID": "api_ref/objects/Pump.html#attributes",
    "href": "api_ref/objects/Pump.html#attributes",
    "title": "Pump",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.\n\nabsolute_elevation : bool\n\nTODO remove?",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Pump"
    ]
  },
  {
    "objectID": "api_ref/objects/SelectionType.html",
    "href": "api_ref/objects/SelectionType.html",
    "title": "SelectionType",
    "section": "",
    "text": "objects.SelectionType()\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\nIt is used to determine where to apply the measure to a model.\n\n\n\naggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "SelectionType"
    ]
  },
  {
    "objectID": "api_ref/objects/SelectionType.html#attributes",
    "href": "api_ref/objects/SelectionType.html#attributes",
    "title": "SelectionType",
    "section": "",
    "text": "aggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "SelectionType"
    ]
  },
  {
    "objectID": "api_ref/objects/Strategy.html",
    "href": "api_ref/objects/Strategy.html",
    "title": "Strategy",
    "section": "",
    "text": "objects.Strategy()\nClass representing a strategy in FloodAdapt.\nA strategy is a collection of measures that can be applied to a model.\n\n\n\nmeasures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "api_ref/objects/Strategy.html#attributes",
    "href": "api_ref/objects/Strategy.html#attributes",
    "title": "Strategy",
    "section": "",
    "text": "measures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "api_ref/objects/Strategy.html#methods",
    "href": "api_ref/objects/Strategy.html#methods",
    "title": "Strategy",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "api_ref/objects/SyntheticEvent.html",
    "href": "api_ref/objects/SyntheticEvent.html",
    "title": "SyntheticEvent",
    "section": "",
    "text": "objects.SyntheticEvent()\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SyntheticEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/SyntheticEvent.html#attributes",
    "href": "api_ref/objects/SyntheticEvent.html#attributes",
    "title": "SyntheticEvent",
    "section": "",
    "text": "time : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SyntheticEvent"
    ]
  },
  {
    "objectID": "api_ref/objects/TimeFrame.html",
    "href": "api_ref/objects/TimeFrame.html",
    "title": "TimeFrame",
    "section": "",
    "text": "objects.TimeFrame()\nClass representing a time frame for a simulation.\n\n\n\nstart_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "TimeFrame"
    ]
  },
  {
    "objectID": "api_ref/objects/TimeFrame.html#attributes",
    "href": "api_ref/objects/TimeFrame.html#attributes",
    "title": "TimeFrame",
    "section": "",
    "text": "start_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "TimeFrame"
    ]
  },
  {
    "objectID": "examples/database_builder/index.html",
    "href": "examples/database_builder/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Database Builder"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "This section contains executable examples that demonstrate how to use the FloodAdapt API in practice. These notebooks are meant to complement the User Guide and API Reference by showing real-world use cases, recommended workflows, and tips for getting started with your own data.\nEach example focuses on a specific aspect of the FloodAdapt workflow, such as setting up a site, defining events, projections and measures, creating adaptation strategies, or evaluating risk and benefits. The notebooks can be run independently, but they are organized in a logical sequence for those following the full workflow from start to finish."
  },
  {
    "objectID": "examples/index.html#introduction",
    "href": "examples/index.html#introduction",
    "title": "Examples",
    "section": "",
    "text": "This section contains executable examples that demonstrate how to use the FloodAdapt API in practice. These notebooks are meant to complement the User Guide and API Reference by showing real-world use cases, recommended workflows, and tips for getting started with your own data.\nEach example focuses on a specific aspect of the FloodAdapt workflow, such as setting up a site, defining events, projections and measures, creating adaptation strategies, or evaluating risk and benefits. The notebooks can be run independently, but they are organized in a logical sequence for those following the full workflow from start to finish."
  },
  {
    "objectID": "examples/index.html#how-to-run",
    "href": "examples/index.html#how-to-run",
    "title": "Examples",
    "section": "How to Run",
    "text": "How to Run\nAll notebooks in this section are runnable with standard Python tools such as jupyter or quarto preview. They assume that FloodAdapt and its core dependencies as well as the optional docs dependencies are correctly installed. Refer to the Setup Guide for help with installation and configuration. To run these locally, make sure to select the correct python interpreter.\nEach notebook includes narrative explanations and inline code cells. You can copy/modify the code to adapt it to your own use cases."
  },
  {
    "objectID": "examples/index.html#examples",
    "href": "examples/index.html#examples",
    "title": "Examples",
    "section": "Examples",
    "text": "Examples\n\n1. Database Builder example description\n2. Simple Scenario example description\n3. Events How to manage hazard model configuration with Events.\n4. Projection example description\n5. Measures example description\n6. Strategies example description\n7. Database manipulation example description\n8. Complex scenario(s) example description\n9. Event set / risk example description\n10. Benefits example description"
  },
  {
    "objectID": "examples/projections/index.html",
    "href": "examples/projections/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Projections"
    ]
  },
  {
    "objectID": "examples/strategies/index.html",
    "href": "examples/strategies/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Strategies"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to the FloodAdapt documentation!\nIn this introduction, you will find an overview of FloodAdapt, information on its intended uses, and reader guidance explaining the information you will find in this documentation."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "Overview",
    "text": "Overview\nFloodAdapt is a flood adaptation decision-support tool, which aims to advance and accelerate flooding-related adaptation planning. It integrates rapid, physics-based compound flood modeling and detailed impact modeling into a user-friendly system, ensuring accessibility for end-users, regardless of their technical backgrounds. This enables users to define and evaluate meaningful ‚Äúwhat-if‚Äù scenarios, which can be combinations of weather events, climate or socio-economic future conditions, and adaptation strategies. FloodAdapt rapidly generates high-quality flood and impact maps, equity-focused aggregations, and informative metrics, providing valuable support for planning and facilitating genuine stakeholder engagement. Beyond its usefulness for end-users, FloodAdapt acts as a vital bridge between scientific advancements and practical needs, enhancing the adoption and impact of adaptation research and development.\n\n\nFloodAdapt was developed as a rapid planning tool with a straightforward graphical user interface for scenario generation, simulation, and visualization of spatial flooding and flooding impacts. Decision-making needs at the community level were central to the design of FloodAdapt. Users can answer planning questions like: ‚ÄúHow will potential adaptation options reduce flood impacts?‚Äù, ‚ÄúHow will those options perform for different types of events, like hurricanes, king tides, or heavy rainfall?‚Äù, ‚ÄúWhich neighborhoods will benefit most?‚Äù, ‚ÄúHow will those options hold up in the future?‚Äù\nUsers specify what-if scenarios composed of historic or synthetic weather events, climate or socio-economic future projections, and adaptation measures. They are able to evaluate flooding and impacts due to compound weather events, like hurricanes, king tides, and rainfall events. Users can evaluate flooding, impacts, and risk considering user-specified projections of sea level rise, precipitation increase, storm frequency increase, population growth, and economic growth. They can also test out adaptation options, like sea walls, levees, pumps, urban green infrastructure, home elevations, buyouts and floodproofing.\nThe backend of FloodAdapt leverages the open-source, state-of-the-art process-based compound flood model SFINCS that can accurately predict compound flooding due to surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. The damage model included in FloodAdapt is the Deltares-developed open-source flood impact assessment tool Delft-FIAT. It calculates the flood damages to individual buildings and roads, and ‚Äì when social vulnerability data is available ‚Äì aggregates these damages over vulnerability classes.\nWhen a user specifies a what-if scenario, the backend of FloodAdapt automatically makes changes to the SFINCS and Delft-FIAT models to represent the user choices, the way an expert modeller would. It then simulates the scenario and returns flood and impact maps, scenario comparison visualizations, summary metrics, and an infographic to highlighting flooding or impacts of particular concern to a community. In this way, FloodAdapt allows end-users to unleash the power of advanced models without requiring the technical background, or the laborious pre- and post-processing of models that is usually required for this type of analysis.\n\n\n\n\n\n\nFigure¬†1: Schematic showing the design concepts behind the FloodAdapt software"
  },
  {
    "objectID": "index.html#intended-uses-of-floodadapt",
    "href": "index.html#intended-uses-of-floodadapt",
    "title": "Introduction",
    "section": "Intended Uses of FloodAdapt",
    "text": "Intended Uses of FloodAdapt\nFloodAdapt was developed to support adaptation and resilience planning, to provide community understanding of the flooding and impacts resulting from different scenarios of interest, to understand the urgency of actions in different areas, to aid in prioritizing investments, and to assess the effectiveness and longevity of different adaptation options.\nFloodAdapt is a powerful and physics-based system that can provide realistic flood and impact responses for user-defined scenarios. This is important because accuracy builds community trust in the tool. The underlying models and data in FloodAdapt can be continuously improved by the local or regional agencies who are operating it. The accuracy of the model results will depend on the accuracy of the input data. FloodAdapt can also help illuminate which data are missing or need improvement and should be collected when resources allow.\nFloodAdapt is not intended for use in the detailed engineering design of adaptation measures, particularly hydraulic ones. Once FloodAdapt has helped the community identify strategies and priority areas for improvements, the specific design requirements for these strategies should be done using more comprehensive modeling tools available. These may need to include detailed drainage infrastructure systems, groundwater, or other components not currently built into FloodAdapt."
  },
  {
    "objectID": "index.html#reader-guidance",
    "href": "index.html#reader-guidance",
    "title": "Introduction",
    "section": "Reader Guidance",
    "text": "Reader Guidance\nFloodAdapt is intended for end-users who have some technical background, but do not need to be subject-matter experts in flood and impact modeling. Setting up FloodAdapt in a new location requires additional capabilities.\n\nUser Guide The user guide provides information on how to get started with FloodAdapt, and describes how to use all the FloodAdapt functionalities.\nSetup Guide - The setup guides users in setting up FloodAdapt in their area of interest.\nTechnical docs - The technical docs provide detailed information on the calculation methods within FloodAdapt."
  },
  {
    "objectID": "examples/events/database_manipulation.html",
    "href": "examples/events/database_manipulation.html",
    "title": "üíæ Event modifications in the database",
    "section": "",
    "text": "This notebook demonstrates how to manipulate event objects in a FloodAdapt database, including loading, creating, editing, copying, and deleting events.\nIt is assumed that at the start of this notebook, you have a database and the events saved from the other event notebooks.\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt.objects import HistoricalEvent\nfrom flood_adapt.objects.forcing.time_frame import TimeFrame\n\n# Setup FloodAdapt\nSTATIC_DATA_DIR = Path(\"../../_data/examples/static-data\").resolve()\nsettings = Settings(\n    DATABASE_ROOT=Path(\"../../_data/examples\").resolve(),\n    DATABASE_NAME=\"charleston_test\",\n)\nfa = FloodAdapt(database_path=settings.database_path)",
    "crumbs": [
      "Events",
      "Database Manipulation"
    ]
  },
  {
    "objectID": "examples/events/database_manipulation.html#analyze-the-effect-of-different-rainfall-forcings",
    "href": "examples/events/database_manipulation.html#analyze-the-effect-of-different-rainfall-forcings",
    "title": "üíæ Event modifications in the database",
    "section": "Analyze the effect of different rainfall forcings",
    "text": "Analyze the effect of different rainfall forcings\nLets say we want to analyze the effect of rainfall, how would you approach that:\n\nRetrieve an event from the database\nCreate the rainfall forcings you want to analyze\nUpdate the event‚Äôs name and rainfall forcings\nSave the updated event to the database\nCreate scenarios using these events and run them (see this example) TODO\n\nOf course, this approach also works for analyzing the difference between any other forcings.\n\n# 1. Create an event or load it from the database\n# event = fa.get_event(...)\nevent_name=\"database_manipulation_event\"\nevent = HistoricalEvent(\n    name=event_name,\n    description=\"Some event description\",\n    time=TimeFrame(\n        start_time=datetime(2020, 1, 1),\n        end_time=datetime(2020, 1, 2),\n    ),\n    forcings={\n        f.ForcingType.WATERLEVEL: [f.WaterlevelGauged()]\n    }\n)\nfa.save_event(event=event)\n\n# 2. Create rainfall forcings\nrainfall_constant = f.RainfallConstant(\n    intensity=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr)\n)\n\nrainfall_synthetic = f.RainfallSynthetic(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(event.time.duration / 2), \n        peak_value=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr),\n    )\n)\n\nrainfall_csv = f.RainfallCSV(path=STATIC_DATA_DIR / \"rainfall.csv\")\n\nrainfall_forcings = [\n    (rainfall_constant, \"constant\"),\n    (rainfall_synthetic, \"synthetic\"),\n    (rainfall_csv, \"csv\")\n]\n\nfor forcing, fsource in rainfall_forcings:\n    # 3. Update the event\n    event.forcings[f.ForcingType.RAINFALL] = [forcing]\n    event.name = f\"{event_name}_rainfall_{fsource}\"\n    \n    # 4. Save the event\n    fa.save_event(event=event)\n\nfa.get_events()[\"name\"]\n\n# 5. Now the events can be used as the components for scenario creation. Similar to how the rainfall forcings are used to create various events\n# For more information on how to create scenarios, see the scenario creation example\n\n['database_manipulation_event',\n 'database_manipulation_event_rainfall_constant',\n 'database_manipulation_event_rainfall_csv',\n 'database_manipulation_event_rainfall_synthetic',\n 'event_set',\n 'test_set']",
    "crumbs": [
      "Events",
      "Database Manipulation"
    ]
  },
  {
    "objectID": "examples/events/database_manipulation.html#delete-save-copy-edit",
    "href": "examples/events/database_manipulation.html#delete-save-copy-edit",
    "title": "üíæ Event modifications in the database",
    "section": "Delete, Save, Copy, Edit",
    "text": "Delete, Save, Copy, Edit\nFloodAdapt supports deleting, editing, and copying objects by name, as shown below.\nIt is possible to achieve the exact same goal in multiple ways:\n\nevent = fa.get_event(event_name) -&gt; update event -&gt; fa.delete_event(event_name) -&gt; fa.save_event(event)\nevent = fa.get_event(event_name) -&gt; update event -&gt; fa.edit_event(event)\n\n\nprint(\"Initial:\", fa.get_events()[\"name\"])\n\n# Copy all events\nfor name in fa.get_events()[\"name\"]:\n    new_name = f\"{name}_copy\"\n    fa.copy_event(old_name=name, new_name=new_name, new_description=f\"Copy of {name}\")\nprint(\"Names after `Copy`:\", fa.get_events()[\"name\"])\n\n# Delete all copied events\nfor name in fa.get_events()[\"name\"]:\n    if \"copy\" in name:\n        fa.delete_event(name)\nprint(\"Names after `Delete`:\", fa.get_events()[\"name\"])\n\n# Edit an existing event\nunedited_event = fa.get_event(event_name)\nprint(\"Description before `Edit`:\", unedited_event.description)\n\nunedited_event.description = f\"Updated description\"\nfa.save_event(event=unedited_event, overwrite=True)\n\nedited_event = fa.get_event(event_name)\nprint(\"Description after `Edit`:\", edited_event.description)\n\nInitial: ['database_manipulation_event', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_csv', 'database_manipulation_event_rainfall_synthetic', 'event_set', 'test_set']\nNames after `Copy`: ['database_manipulation_event', 'database_manipulation_event_copy', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_constant_copy', 'database_manipulation_event_rainfall_csv', 'database_manipulation_event_rainfall_csv_copy', 'database_manipulation_event_rainfall_synthetic', 'database_manipulation_event_rainfall_synthetic_copy', 'event_set', 'event_set_copy', 'test_set', 'test_set_copy']\nNames after `Delete`: ['database_manipulation_event', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_csv', 'database_manipulation_event_rainfall_synthetic', 'event_set', 'test_set']\nDescription before `Edit`: Some event description\nDescription after `Edit`: Updated description",
    "crumbs": [
      "Events",
      "Database Manipulation"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html",
    "href": "examples/events/hurricane_event.html",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a hurricane event using FloodAdapt. Hurricane events are valuable for controlled testing, sensitivity analysis, and understanding the behavior of flood models under simplified or hypothetical scenarios.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full HurricaneEvent with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-1.-setup-and-imports",
    "href": "examples/events/hurricane_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing hurricane forcings and managing event data within the flood_adapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import HurricaneEvent, TimeFrame\nfrom flood_adapt.objects.events.hurricane import TranslationModel\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nSTATIC_DATA_DIR = Path(\"../../_data/examples/static-data\").resolve()\nsettings = Settings(\n    DATABASE_ROOT=Path(\"../../_data/examples\").resolve(),\n    DATABASE_NAME=\"charleston_test\"\n)\nfa = FloodAdapt(database_path=settings.database_path)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-2.-define-the-simulation-time-frame",
    "href": "examples/events/hurricane_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the hurricane event, from January 1 to January 2, 2025. Make sure the time frame covers the tinme specified in your hurricane track file.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2025, month=1, day=1)\nend_time = datetime(year=2025, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-3.-define-water-level-forcing",
    "href": "examples/events/hurricane_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nWater levels for Hurricane Events are computed by taking the Hurricane Track, and generating a pressure and wind field along its track.\nThese fields are then used as forcing inputs to the offshore simulation, which generates the storm surge to be used for the overland simulation. So for waterlevels, we only need to specify to use the offshore model as the input, denoted with WaterlevelModel\n\nwater_levels = f.WaterlevelModel()",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-3.-obtain-a-hurricane-track",
    "href": "examples/events/hurricane_event.html#step-3.-obtain-a-hurricane-track",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåßÔ∏è Step 3. Obtain a hurricane track",
    "text": "üåßÔ∏è Step 3. Obtain a hurricane track\nYou can include an IBTrACS hurricane database with recent and historic tracks in the FloodAdapt database. You can use any track from the database and optionally shift the track north, southh, east or west.\n\nNOTE: Hurricane events are only available in FloodAdapt when you have an offshore flood hazard model in your database that simulates the surge from the hurricane track.\n\n\n# Get the cyclone database\ncyclone_db = fa.database.static.get_cyclone_track_database()\nian_index = cyclone_db.list_names().index(\"IAN\")\n\n# Not all cyclone tracks have names, in addition to duplicate names existing, so the index is required\ntrack = fa.get_cyclone_track_by_index(index=ian_index) \ntrack_file = STATIC_DATA_DIR / \"IAN.cyc\"\ntrack.write_track(filename=track_file, fmt=\"ddb_cyc\")\n\n# Optionally translate the cyclone track from what is defined in the file\ntranslation = TranslationModel(\n    eastwest_translation=us.UnitfulLength(value=3000, units=us.UnitTypesLength.meters),\n    northsouth_translation=us.UnitfulLength(value=5000, units=us.UnitTypesLength.meters),\n)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-4.-define-track-forcings",
    "href": "examples/events/hurricane_event.html#step-4.-define-track-forcings",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåßÔ∏è Step 4. Define Track forcings",
    "text": "üåßÔ∏è Step 4. Define Track forcings\nGiven a Hurricane track, the wind field is always computer from the track. You can choose to model the rainfall based on a parametric model around the hurricane track or choose any iother rainfall option.\n\n# We want to include the rainfall and wind from the hurricane track\nrainfall = f.RainfallTrack(path=track_file)\nwind = f.WindTrack(path=track_file)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-5.-define-river-discharge-forcing",
    "href": "examples/events/hurricane_event.html#step-5.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üèûÔ∏è Step 5. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 5. Define River Discharge Forcing\nDischarge is defined for two pre-configured rivers in this example. These rivers must be registered in the hazard model configuration beforehand, see [Database builder].\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event\n# You can only set the discharge of each given river.\nriver = fa.database.site.sfincs.river[0]\n\ndischarge = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\n# Inspect\ndf = discharge.to_dataframe(time_frame=time_frame)\ndf.plot(title=\"Constant Discharge River\", xlabel=\"Time\", ylabel=\"Discharge (cms)\", legend=True, figsize=(5, 2))",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-6.-combine-forcings-and-create-hurricane-event",
    "href": "examples/events/hurricane_event.html#step-6.-combine-forcings-and-create-hurricane-event",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üß© Step 6. Combine Forcings and Create hurricane Event",
    "text": "üß© Step 6. Combine Forcings and Create hurricane Event\nAll defined forcings are collected into a single dictionary, which is used to construct a hurricaneEvent.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a hurricaneEvent with the forcings and time frame\nevent = HurricaneEvent(\n    name=\"example_hurricane_event\",\n    time=time_frame,\n    forcings = {\n        f.ForcingType.WATERLEVEL: [water_levels],\n        f.ForcingType.RAINFALL: [rainfall],\n        f.ForcingType.WIND: [wind],\n        f.ForcingType.DISCHARGE: [discharge],\n    },\n    track_name=track.name,\n    hurricane_translation=translation,\n)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "examples/events/hurricane_event.html#step-7.-save-the-event-to-a-floodadapt-database",
    "href": "examples/events/hurricane_event.html#step-7.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üíæ Step 7. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 7. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=event)",
    "crumbs": [
      "Events",
      "Hurricane Event"
    ]
  }
]