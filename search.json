[
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html",
    "title": "üìò Example: Simple Scenario",
    "section": "",
    "text": "In this notebook we demonstrate the workflow on how you can build a simple FloodAdapt scenario in Charleston, USA, using the API.\nIn this notebook we will cover the following steps:",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#import-libraries",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#import-libraries",
    "title": "üìò Example: Simple Scenario",
    "section": "Import libraries",
    "text": "Import libraries\n\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\nimport contextily as cx\nimport os\n\nfrom datetime import datetime\nfrom pathlib import Path\nfrom IPython.display import HTML\n\nfrom flood_adapt.objects.forcing import (\n    ForcingType,\n    WindConstant,\n    RainfallConstant,\n    WaterlevelSynthetic,\n    DischargeConstant,\n    TimeseriesFactory,\n    ShapeType,\n    SurgeModel,\n    TideModel,\n)\nfrom flood_adapt.objects import (\n    Elevate,\n    FloodWall, \n    TimeFrame, \n    Projection, \n    PhysicalProjection, \n    SocioEconomicChange, \n    Scenario, \n    Strategy,\n    SyntheticEvent,\n    SelectionType\n)\nfrom flood_adapt.config.sfincs import RiverModel\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt import unit_system as us",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-1.-reading-in-the-floodadapt-database",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-1.-reading-in-the-floodadapt-database",
    "title": "üìò Example: Simple Scenario",
    "section": "üöÄ Step 1. Reading-in the FloodAdapt database",
    "text": "üöÄ Step 1. Reading-in the FloodAdapt database\nLet‚Äôs start with initiating the database and FloodAdapt class. 1. Initiate the database class Settings by defining the DATABASE_ROOT and DATABASE_NAME. 2. Initiate the FloodAdapt class by parsing the Settings().database_path.\n\n# Define paths\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\" / \"3_Measures\"\nSFINCS_BIN_PATH = DATA_DIR / \"system\" / \"win-64\" / \"sfincs\" / \"sfincs.exe\"\nFIAT_BIN_PATH = DATA_DIR / \"system\" / \"win-64\" / \"fiat\" / \"fiat.exe\"\n\n# Configure the settings\nos.environ[\"USE_BINARIES\"] = \"True\"\nos.environ[\"FIAT_BIN_PATH\"] = (DATA_DIR / \"system\" / \"win-64\" / \"fiat\" / \"fiat.exe\").as_posix()\nos.environ[\"SFINCS_BIN_PATH\"] = (DATA_DIR / \"system\" / \"win-64\" / \"sfincs\" / \"sfincs.exe\").as_posix()\n\n# Create the FloodAdapt instance\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:27:52 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:27:52 AM - FloodAdapt.Database - INFO - Loading database into memory\n2026-02-27 11:28:02 AM - FloodAdapt.Database - INFO - Deleted simulation folder: D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\offshore",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-2.-events---create-a-synthetic-event",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-2.-events---create-a-synthetic-event",
    "title": "üìò Example: Simple Scenario",
    "section": "üåä Step 2. Events - Create a synthetic Event",
    "text": "üåä Step 2. Events - Create a synthetic Event\nEvents in FloodAdapt are categorized into different forcings: 1. Wind 2. Rainfall 3. Discharge 4. Water Level\nIf you want to learn more about the individual forcings in FloodAdapt, please go and read the section on Events in the FloodAdapt documentation.\nWhen creating an event, we need to create an Event object. Depending on which type of event we create, we select a different class. In this example we create a synthetic event, therefore we use the SyntheticEvent class.\nTo create the SyntheticEvent object we use the time attribute to define the event duration. This should be parsed as a TimeFrame object. In the forcings attribute we aggregated the different forcing objects in a dictionary.\nIn this event example we will create an event with the following forcings:\nüå¨Ô∏è WindConstant: Define a value for a constant wind speed (mps) and direction (degrees)\nüåßÔ∏è RainfallConstant: Define a value for a constant rainfall (mm/hr)\nüí¶ DischargeConstant: Define the x and y coordinates of the discharge point of the Cooper River and a value for a constant mean discharge (cfs) in the River- and Discharge model (same value)\nüåä WaterlevelSynthetic SurgeModel: Define a peak time (h), peak value in (m) and duration (d)\n‚ÜîÔ∏éÔ∏è WaterlevelSynthetic TideModel: Define the harmonic amplitude (m), harmonic period (h) and harmonic phase (h)\nFor a complete guide on all the possible event options and inputs check out the notebook specifically on events.\n\n# Create a synthetic event object\nevent = SyntheticEvent(\n    name=\"synthetic_nearshore\",\n    description = \"This is a synthetic nearshore event\",\n    time=TimeFrame(\n        start_time=datetime(2020, 1, 1),\n        end_time=datetime(2020, 1, 2),\n    ),\n    forcings={\n        ForcingType.WIND: [\n            WindConstant(\n                speed=us.UnitfulVelocity(value=5, units=us.UnitTypesVelocity.mps),\n                direction=us.UnitfulDirection(\n                    value=60, units=us.UnitTypesDirection.degrees\n                ),\n            )\n        ],\n        ForcingType.RAINFALL: [\n            RainfallConstant(\n                intensity=us.UnitfulIntensity(\n                    value=20, units=us.UnitTypesIntensity.mm_hr\n                )\n            )\n        ],\n        ForcingType.DISCHARGE: [\n            DischargeConstant(\n                river=RiverModel(\n                    name=\"cooper\",\n                    description=\"Cooper River\",\n                    x_coordinate=595546.3,\n                    y_coordinate=3675590.6,\n                    mean_discharge=us.UnitfulDischarge(\n                        value=5000, units=us.UnitTypesDischarge.cfs\n                    ),\n                ),\n                discharge=us.UnitfulDischarge(\n                    value=5000, units=us.UnitTypesDischarge.cfs\n                ),\n            )\n        ],\n        ForcingType.WATERLEVEL: [\n            WaterlevelSynthetic(\n                surge=SurgeModel(\n                    timeseries=TimeseriesFactory.from_args(\n                        shape_type=ShapeType.triangle,\n                        duration=us.UnitfulTime(\n                            value=1, units=us.UnitTypesTime.days\n                        ),\n                        peak_time=us.UnitfulTime(\n                            value=8, units=us.UnitTypesTime.hours\n                        ),\n                        peak_value=us.UnitfulLength(\n                            value=1, units=us.UnitTypesLength.meters\n                        ),\n                    )\n                ),\n                tide=TideModel(\n                    harmonic_amplitude=us.UnitfulLength(\n                        value=1, units=us.UnitTypesLength.meters\n                    ),\n                    harmonic_period=us.UnitfulTime(\n                        value=12.4, units=us.UnitTypesTime.hours\n                    ),\n                    harmonic_phase=us.UnitfulTime(\n                        value=0, units=us.UnitTypesTime.hours\n                    ),\n                ),\n            )\n        ],\n    },\n)\n\n\nüíæ Step 2.1. Saving the event to the database\n\n# Save the event to the database\nfa.save_event(event)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-3.-projections---create-a-projection",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-3.-projections---create-a-projection",
    "title": "üìò Example: Simple Scenario",
    "section": "üìà Step 3. Projections - Create a projection",
    "text": "üìà Step 3. Projections - Create a projection\nProjections in FloodAdapt allow us to adjust our model to future conditions such as sea level rise or/and population growth. If you want to learn more about projections in FlooAdapt, please go to the section Projections in the FloodAdapt documentation.\nThe projections can be divided into two categories: 1. üåä Physical Projections: Sea level rise, intensified precipitation, increased storm frequency 2. üí∞ Socio economic change: Population growth (existing built area, new development area), economic growth\nWhen creating a projection we need to create a Projection object. The PhysicalProjection attribute is parsed as a PhysicalProjection object which captures the physical projection such as sea lvel rise. The SocioEconomicChange attribute is parsed as a SocioEconomicChange object which captures the socioeconomic projection such as population growth. It‚Äôs not mandatory to parse both projections. If we only want to use one of the two types of projections we can leave the other one blank ().\nThe attributes of the PhysicalProjection or SocioEconomicChange object define the projection. In this case we parse the attribute sea_level_rise to the PhysicalProjection object and define the value in UnitfulLength and the unit in UnitTypesLength.\nTo get a deeper understanding for all the possible projections and their inputs go to the notebook specifically about projections.\n\n# Create a projection object\nprojection = Projection(\n    name=\"SLR_2ft\",\n    description = \"This is a 2ft SLR projection\",\n    physical_projection=PhysicalProjection(\n        sea_level_rise=us.UnitfulLength(value=2, units=us.UnitTypesLength.feet),\n    ),\n    socio_economic_change=SocioEconomicChange(),\n)\n\n\nüíæ Step 3.1. Saving the projection to the database\n\n# Save the projection\nfa.save_projection(projection)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-4.-measures---create-a-measure",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-4.-measures---create-a-measure",
    "title": "üìò Example: Simple Scenario",
    "section": "üß± Step 4. Measures - Create a measure",
    "text": "üß± Step 4. Measures - Create a measure\nMeasures in FloodAdapt enable the user to mititgate the event impacts and investigate their efficiency on the fly.\nMeasures can be: 1. üí¶ Hydraulic measures on the hazard level 2. üå± Green infrastructure measures on the hazard level 3. üè† Impact measures on the building level.\nYou can read more about measures in the section Measures in the FloodAdapt documentation.\nüí¶ In this example we will create a hydraulic measure, a sea wall of 12ft. To create a measure we need to create a Measure object. In the attributes we define the measure type object, in this example a FloodWall object. Additionally to the other attributes, we need to parse the elevation value as UnitfulLength and the unit as UnitTypesLength of the sea wall.\n\n# Create a measure object\nfloodwall = FloodWall(\n    name=\"seawall_10ft\",\n    description=\"10ft Seawall\",\n    selection_type=SelectionType.polyline,\n    polygon_file=str(Path(STATIC_DATA_DIR / \"seawall.geojson\")),\n    elevation=us.UnitfulLengthRefValue(value=12, units=us.UnitTypesLength.feet, type=us.VerticalReference.datum)\n)\n\nüè† Let‚Äôs add another measure on the impact level. We can elevate buildings in a specific area to mititgate the impact on these assets.\nWhen elevating buildings as measure we need to create a Elevate object. we can also specify which building types we wan the measure to be applied to by defining the property type attribute. e can parse the building type (residential, commercial‚Ä¶) that is used in our Delft-FIAT Model. In this example we want to elevate all buildings so we parse ALL.\nTo define the elevation we need to parse a UnitfulLengthRefValue object which consists of a value of type float, a unit which can be one of the UnitTypesLength and a vertical reference from which point the elevation should be calculated. This sholud be parsed as VerticalReference object.\n\n# Create a measure object\nelevate = Elevate(\n    name=\"Elevated_homes_3ft\",\n    description=\"Elevate residential buildings\",\n    selection_type=SelectionType.polygon,\n    polygon_file=str(Path(STATIC_DATA_DIR / \"raise_property_polygon.geojson\")),\n    property_type=\"ALL\",\n    elevation=us.UnitfulLengthRefValue(value=3, units=us.UnitTypesLength.feet, type=us.VerticalReference.floodmap)\n)\n\n\nüíæ Step 4.1. Saving the measure to the database\n\n# Save the measure\nfa.save_measure(floodwall)\nfa.save_measure(elevate)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-5.-strategies---create-a-strategy",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-5.-strategies---create-a-strategy",
    "title": "üìò Example: Simple Scenario",
    "section": "üß© Step 5. Strategies - Create a strategy",
    "text": "üß© Step 5. Strategies - Create a strategy\nStrategies are combinations measures. They allow us to run an test multiple measures in a single model run.\nTo create a strategy we need to create a Strategy object. In the measures attribute we parse a list of all the names of the measures that we want to apply in that strategy.\n\n# Create a strategy object\nstrategy = Strategy(\n    name=\"seawall_and_elev_build\",\n    description=\"Strategy with a seawall and elevation of buildings\",\n    measures=[floodwall.name, elevate.name],\n)\n\n\nüíæ Step 5.1. Saving the strategy to the database\n\n# Save the strategy\nfa.save_strategy(strategy)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#step-6.-create-a-scenario",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#step-6.-create-a-scenario",
    "title": "üìò Example: Simple Scenario",
    "section": "üó∫Ô∏è Step 6. Create a scenario",
    "text": "üó∫Ô∏è Step 6. Create a scenario\nWe reached the final step where we can put all the building blocks together to create a complete scenario!\nA scenario is composed of:\n1. Event\n2. Projection\n3. Strategy (Measures)\nIf you want to read more about the composition of scenarios, go read the Scenario-section of the FloodAdapt documentation.\nWhen creating a scenario we need to create a Scenario object in which we parse the name of the event, projection and strategy as attributes.\n\n# Create a scenario object\nscenario = Scenario(\n    name=\"slr_nearshore_seawall_elev_build\",\n    description=\"Nearshore event with SLR projection and seawall + elevated buildings strategy\",\n    event=event.name,\n    projection=projection.name,\n    strategy=strategy.name,\n)\n\n\nüíæ Step 6.1. Saving the scenario to the database\n\n# Save the scenario\nfa.save_scenario(scenario)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#final-step-run-a-scenario",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#final-step-run-a-scenario",
    "title": "üìò Example: Simple Scenario",
    "section": "üèÉ‚Äç‚ôÄÔ∏è Final step: Run a scenario",
    "text": "üèÉ‚Äç‚ôÄÔ∏è Final step: Run a scenario\nWe are ready to run the scenario! Simply parse the scenario.name into the function run_scenario.\n\n# Run the scenario\nfa.run_scenario(scenario.name)\n\n2026-02-27 11:28:10 AM - FloodAdapt.ScenarioRunner - INFO - FloodAdapt version `2.0.3`\n2026-02-27 11:28:10 AM - FloodAdapt.ScenarioRunner - INFO - Started evaluation of `slr_nearshore_seawall_elev_build`\n2026-02-27 11:28:31 AM - FloodAdapt.SfincsAdapter - INFO - Preprocessing Scenario `slr_nearshore_seawall_elev_build`: Event `synthetic_nearshore`, Strategy `seawall_and_elev_build`, Projection `SLR_2ft`\n2026-02-27 11:28:31 AM - FloodAdapt.SfincsAdapter - INFO - Setting timing for the SFINCS model: `2020-01-01 00:00:00 - 2020-01-02 00:00:00`\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding Wind: Constant\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding Rainfall: Constant\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding Discharge: Constant\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Setting discharge forcing for river: cooper\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding Waterlevel: Synthetic\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding event's rainfall multiplier: 1.0\n2026-02-27 11:28:34 AM - FloodAdapt.SfincsAdapter - INFO - Adding Floodwall `seawall_10ft`\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - INFO - Using floodwall height relative to datum.\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - WARNING - Using uniform height of 12.00 feet above datum.\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - INFO - Adding Projection `SLR_2ft`\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - INFO - Adding projected sea level rise `2.00 feet`\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - INFO - Adding projected rainfall multiplier `1.0`\n2026-02-27 11:28:36 AM - FloodAdapt.SfincsAdapter - INFO - Adding observation points to the overland flood model\n2026-02-27 11:28:40 AM - FloodAdapt.SfincsAdapter - INFO - Running SFINCS for single event Scenario `slr_nearshore_seawall_elev_build`\n2026-02-27 11:28:40 AM - FloodAdapt.SfincsAdapter - INFO - Running SFINCS in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_nearshore_seawall_elev_build\\Flooding\\simulations\\overland\n2026-02-27 11:30:31 AM - FloodAdapt.SfincsAdapter - INFO - Postprocessing SFINCS for Scenario `slr_nearshore_seawall_elev_build`\n2026-02-27 11:30:31 AM - FloodAdapt.SfincsAdapter - INFO - Writing water level map to netcdf\n2026-02-27 11:30:42 AM - FloodAdapt.SfincsAdapter - INFO - Writing flood maps to geotiff.\n2026-02-27 11:31:13 AM - FloodAdapt.SfincsAdapter - INFO - Plotting water levels at observation points\n2026-02-27 11:31:23 AM - FloodAdapt.SfincsAdapter - INFO - Deleted simulation folder: D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_nearshore_seawall_elev_build\\Flooding\\simulations\\overland\n2026-02-27 11:31:23 AM - FloodAdapt.FiatAdapter - INFO - Pre-processing Delft-FIAT model\n2026-02-27 11:31:23 AM - FloodAdapt.FiatAdapter - INFO - Applying socioeconomic changes from projection 'SLR_2ft'\n2026-02-27 11:31:23 AM - FloodAdapt.FiatAdapter - INFO - Applying impact measure 'Elevated_homes_3ft'\n2026-02-27 11:31:23 AM - FloodAdapt.FiatAdapter - INFO - Elevating 'ALL' type properties in 'D:/a/FloodAdapt/FloodAdapt/docs/_data/examples/charleston_test/input/measures/Elevated_homes_3ft/raise_property_polygon.geojson' by 3.00 feet relative to 'VerticalReference.floodmap'.\n2026-02-27 11:31:24 AM - FloodAdapt.FiatAdapter - INFO - Setting hazard to the FloodmapType.water_level map [WindowsPath('D:/a/FloodAdapt/FloodAdapt/docs/_data/examples/charleston_test/output/scenarios/slr_nearshore_seawall_elev_build/Flooding/max_water_level_map.tif')]\n2026-02-27 11:31:24 AM - FloodAdapt.FiatAdapter - INFO - Running FIAT in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_nearshore_seawall_elev_build\\Impacts\\fiat_model\n2026-02-27 11:31:30 AM - FloodAdapt.FiatAdapter - INFO - Post-processing Delft-FIAT results\n2026-02-27 11:31:30 AM - FloodAdapt.FiatAdapter - INFO - Calculating infometrics\n2026-02-27 11:31:32 AM - FloodAdapt.FiatAdapter - INFO - Creating infographics\n2026-02-27 11:31:32 AM - FloodAdapt.FiatAdapter - INFO - Saving impacts for aggregation areas type: 'Census Blockgroup'\n2026-02-27 11:31:32 AM - FloodAdapt.FiatAdapter - INFO - Saving impacts for aggregation areas type: 'Subdivision'\n2026-02-27 11:31:32 AM - FloodAdapt.FiatAdapter - INFO - Calculating impacts at a building footprint scale\n2026-02-27 11:31:34 AM - FloodAdapt.FiatAdapter - INFO - Calculating road impacts\n2026-02-27 11:31:34 AM - FloodAdapt.FiatAdapter - INFO - Delft-FIAT post-processing complete!\n2026-02-27 11:31:34 AM - FloodAdapt.FiatAdapter - INFO - Deleting D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_nearshore_seawall_elev_build\\Impacts\\fiat_model\n2026-02-27 11:31:34 AM - FloodAdapt.ScenarioRunner - INFO - Finished evaluation of `slr_nearshore_seawall_elev_build`",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#finished",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#finished",
    "title": "üìò Example: Simple Scenario",
    "section": "Finished!",
    "text": "Finished!\nCongratulations you created and ran your first FloodAdapt scenario!",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/simple_scenario.html#output-lets-inspect-the-output",
    "href": "3_api_docs/examples/scenarios/simple_scenario.html#output-lets-inspect-the-output",
    "title": "üìò Example: Simple Scenario",
    "section": "Output: üïµÔ∏è‚Äç‚ôÄÔ∏è Let‚Äôs inspect the output",
    "text": "Output: üïµÔ∏è‚Äç‚ôÄÔ∏è Let‚Äôs inspect the output\n\n1. Output files\nIn your scenario output folder you should see the following files: - Flooding: Folder - Impacts: Folder - finished.txt: text file - Infometrics_‚Äúscenario_name‚Äù.csv: csv file of the overall infometrics - Infometrics_‚Äúscenario_name‚Äù‚Äúaggregation_layer‚Äù.csv: csv file of the aggregated areas. You have one file per aggregation level. In this example we have two files. - logfile‚Äùscenario_name‚Äù.log: The log of the scenario run - **‚Äúscenario_name‚Äù_metrics.html**: A metric file of your scenario output\nThe figure below presents a visual overview of all the output files that should be in your database after running the scenario\n\n\n\n\n\n2. Floodmap - Inspect the floodmap\nWe can open and inspect the floodmap\n\n# Plot Floodmap geotiff\ngeotiff_map = fa.get_flood_map_geotiff(scenario.name)\nraster = rxr.open_rasterio(geotiff_map, masked=True)\n\nfig, ax = plt.subplots(figsize=(10, 10))\nraster.plot(\n    ax=ax,\n    cmap=\"Blues\",\n    cbar_kwargs={\"label\": \"Flood Depth (feet)\"}\n)\nax.set_title(f\"Flood Map - Scenario: {scenario.name}\")\ncx.add_basemap(ax, crs=raster.rio.crs)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3. Economic Impacts - Inspect the economic impacts on the building level and aggregated\nWe can plot the economic impacts on the building level and on the aggregated level.\n\ngdf_building_impacts = fa.get_building_footprint_impacts(scenario.name)\n\n# Dynamic map for building impacts\ngdf_building_impacts.explore(\n    column=\"Total Damage\",\n    cmap=\"Reds\",\n    legend=True,\n    vmin=0,\n    vmax=60000,\n    legend_kwds={\"caption\": \"Total Damages ($) Buildings\"}\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n## Aggregated Impacts\ngdf_impacts_aggr = fa.get_aggregated_impacts(scenario.name)\ngdf_aggr_lvl1 = gdf_impacts_aggr[\"Subdivision\"]\n\n# Reproject buildings crs to Web Mercator\ngdf_aggr_lvl1 = gdf_aggr_lvl1.to_crs(epsg=3857)\n\n# Dynamic map for aggregated impacts\ngdf_aggr_lvl1.explore(\n    column=\"TotalDamageEvent\",\n    cmap=\"Reds\",\n    legend=True,\n    vmin=0,\n    vmax=10000000,\n    edgecolor=\"k\",\n    legend_kwds={\"caption\": \"Total Damages ($) per aggregation area\"}\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n4. Infometrics & Infographics\nWhich infometrics and infographics to generate can be defined in the infometrics and infographics and configuration file in your database /Database/charleston_full/static/templates/infometrics/‚Äú‚Äú, /Database/charleston_full/static/templates/infographics/‚Äù‚Äú.toml, respectively.\n\n# Display HTML infographics\nfile = fa.get_infographic(scenario.name)\n\nHTML(filename=file)",
    "crumbs": [
      "Examples",
      "Simple Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html",
    "href": "3_api_docs/examples/projections/projections.html",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "",
    "text": "In FloodAdapt, a Projection object is used to describe future climate and socio-economic conditions. These are defined by the two main components of a Projection object: - physical_projection: a PhysicalProjection object that describes the physical changes in the environment, such as sea level rise. - socio_economic_change: a SocioEconomicChange object that describes the socio-economic changes, such as population and economic growth.\nIf you want to learn more about Projections, you can check the Projections section of the FloodAdapt GUI documentation.\nIn this notebook, we will look into all the available FloodAdapt methods to create, save, edit and delete Projections.",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#import-libraries",
    "href": "3_api_docs/examples/projections/projections.html#import-libraries",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "Import libraries",
    "text": "Import libraries\nFirst the required python libraries for this notebook are imported.\n\nfrom flood_adapt import FloodAdapt\nfrom flood_adapt.objects.projections.projections import PhysicalProjection, SocioEconomicChange, Projection\nfrom flood_adapt.objects.forcing.unit_system import UnitTypesLength, UnitfulLength, UnitfulLengthRefValue, VerticalReference\nfrom flood_adapt.config.config import Settings\nfrom pathlib import Path\nimport pandas as pd\nimport geopandas as gpd\nfrom IPython.display import HTML",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-1-reading-in-the-floodadapt-database",
    "href": "3_api_docs/examples/projections/projections.html#step-1-reading-in-the-floodadapt-database",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "üöÄ Step 1: Reading-in the FloodAdapt database",
    "text": "üöÄ Step 1: Reading-in the FloodAdapt database\nThen, we need to create a FloodAdapt object, with the example database of Charleston. This object has all the required methods for adding, copying, editing or deleting projections from the database.\n\n# Setup FloodAdapt\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\" / \"4_Projections\" # For later use\n\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:21:36 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:21:36 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-2-getting-available-projections-from-the-database",
    "href": "3_api_docs/examples/projections/projections.html#step-2-getting-available-projections-from-the-database",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "üîé Step 2: Getting available projections from the database",
    "text": "üîé Step 2: Getting available projections from the database\nUsing the get_projections() method of the FloodAdapt class, we can get a dictionary of all the projections in the database. The keys of the returned dictionary are the names, descriptions, paths and last modification dates of the projections. We can use this method to check which projections are currently available in the database.\n\npd.DataFrame(fa.get_projections()) # here we turn the dictionary to a Pandas DataFrame for better visualization\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\n\n\n\n\n0\ncurrent\n\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 10:59:24.033007\n\n\n\n\n\n\n\nAs can be seen above, right now, there is only one projection available in the database named ‚Äúcurrent‚Äù. This is a default projection created when the database is created, to describe the current conditions without any future changes.\nWe can get the Projection object of a projection by using the get_projection() method of the FloodAdapt class. This method takes only the name of the projection as an argument.\n\nfa.get_projection(\"current\")\n\nProjection(name='current', description='', physical_projection=PhysicalProjection(sea_level_rise=UnitfulLength(value=0.00, units=meters), subsidence=UnitfulLength(value=0.00, units=meters), rainfall_multiplier=1.0, storm_frequency_increase=0.0), socio_economic_change=SocioEconomicChange(population_growth_existing=0.0, economic_growth=0.0, population_growth_new=0.0, new_development_elevation=None, new_development_shapefile=None))\n\n\nAs can be seen the ‚Äúcurrent‚Äù projection has default values for the attributes of the physical_projection and socio_economic_change, which essentially means that this projection describes the current conditions without any change.",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-3-creating-a-new-projection-object",
    "href": "3_api_docs/examples/projections/projections.html#step-3-creating-a-new-projection-object",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "üìà Step 3: Creating a new Projection object",
    "text": "üìà Step 3: Creating a new Projection object\nA Projection object can be created by using the individual FloodAdapt object classes. This can ensure correct type hinting and avoid errors.\n\nüåäüåßÔ∏è Physical Projection\nFirst, let‚Äôs a create a PhysicalProjection that describes future conditions with 0.5 meters of sea level rise. To do this we can use the sea_level_rise attribute which has a value with a unit, which in FloodAdapt can be defined using a UnitfulLength object with the value and unit fields. The value field is a float and the unit field can be one of the UnitTypesLength.\n\nphys_proj = PhysicalProjection(sea_level_rise=UnitfulLength(value=0.5, units=UnitTypesLength.meters))\nphys_proj\n\nPhysicalProjection(sea_level_rise=UnitfulLength(value=0.50, units=meters), subsidence=UnitfulLength(value=0.00, units=meters), rainfall_multiplier=1.0, storm_frequency_increase=0.0)\n\n\n\n\nüë•üí∞ Socio-Economic Change\nThen we create a SocioEconomicChange object that describes future conditions with a population growth of 10% and an economic growth of 5% for the existing areas. To do this we can use the population_growth and economic_growth attributes which are both floats given in percentages.\n\nse_change = SocioEconomicChange(population_growth_existing=10,\n                          economic_growth=5)\nse_change\n\nSocioEconomicChange(population_growth_existing=10.0, economic_growth=5.0, population_growth_new=0.0, new_development_elevation=None, new_development_shapefile=None)\n\n\nNow, we can create a Projection object, giving it a unique name (which cannot contain any spaces or special characters), and the previously created PhysicalProjection and SocioEconomicChange objects. The description field is optional, and can be used to provide a more extensive description of the projection.\n\nfuture_1 = Projection(\n    name=\"future_1\", \n    description=r\"0.5 m sea level rise, 10% population growth, 5% economic growth\", \n    physical_projection=phys_proj, \n    socio_economic_change=se_change\n)\nfuture_1\n\nProjection(name='future_1', description='0.5 m sea level rise, 10% population growth, 5% economic growth', physical_projection=PhysicalProjection(sea_level_rise=UnitfulLength(value=0.50, units=meters), subsidence=UnitfulLength(value=0.00, units=meters), rainfall_multiplier=1.0, storm_frequency_increase=0.0), socio_economic_change=SocioEconomicChange(population_growth_existing=10.0, economic_growth=5.0, population_growth_new=0.0, new_development_elevation=None, new_development_shapefile=None))\n\n\nAlternatively, a new projection can be created by using the create_projection() method of the FloodAdapt class. This method takes a single argument which is a dictionary containing the required projection parameters. Let‚Äôs create the exact same projection as before, but now using this method.\n\n# Create dictionary\nfuture_1_dict = {\n    \"name\": \"slr_50cm\",\n    \"description\": \"0.5 m sea level rise\",\n    \"physical_projection\": {\"sea_level_rise\": {\"value\": 0.5, \"units\": \"meters\"}},\n    \"socio_economic_change\": {\"population_growth_existing\": 10, \"economic_growth\": 5}\n}\n# Create Projection object from dictionary\nfuture_1_from_dict = fa.create_projection(future_1_dict)\n\nWe can now verify that the two projection objects are identical:\n\n# Check if the two objects are equal\nfuture_1_from_dict == future_1\n\nTrue",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-4-saving-a-new-projection-to-the-database",
    "href": "3_api_docs/examples/projections/projections.html#step-4-saving-a-new-projection-to-the-database",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "üíæ Step 4: Saving a new Projection to the database",
    "text": "üíæ Step 4: Saving a new Projection to the database\nIn the previous step we have created a Projection object, but we have not yet saved it in our database. The save_projection() method of the FloodAdapt class can be used to achieve that. This method takes a single argument which is a Projection object. If a projection with the same name already exists in the database, an error will be raised. Let‚Äôs save the projection we just created to the database.\n\nfa.save_projection(future_1)\n\nUsing the get_projections() method of the FloodAdapt class, we can check that the projection has been saved to the database.\n\npd.DataFrame(fa.get_projections())\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\n\n\n\n\n0\ncurrent\n\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 10:59:24.033007\n\n\n1\nfuture_1\n0.5 m sea level rise, 10% population growth, 5...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:37.549953",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-5-copying-and-editing-a-projection-in-the-database",
    "href": "3_api_docs/examples/projections/projections.html#step-5-copying-and-editing-a-projection-in-the-database",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "‚úèÔ∏è Step 5: Copying and Editing a Projection in the database",
    "text": "‚úèÔ∏è Step 5: Copying and Editing a Projection in the database\nIf we want to edit small parts of a projection, it is easier to copy an existing projection and edit the copy. This way we do not have to create a new projection from scratch.\nA projection can be copied in the database by using the copy_projection() method of the FloodAdapt class. This method takes three arguments: the name of the projection to be copied and the name and description of the new projection. Let‚Äôs copy the projection we just created, which we would like to adjust, to represent 1 meter of sea level rise.\n\nfa.copy_projection(\n    old_name=\"future_1\", \n    new_name=\"future_2\", \n    new_description=r\"1 m sea level rise, 10% population growth, 5% economic growth\"\n)\n\nWe can see that now a new projection with name ‚Äúfuture_2‚Äù has been created in the database. However, the actual attributes of the projection are still the same as the original projection.\n\nfuture_2 = fa.get_projection(\"future_2\")\nfuture_2.physical_projection.sea_level_rise\n\nUnitfulLength(value=0.50, units=meters)\n\n\nWe can directly edit the relevant attributes of the projection object. In this case, we want to change the sea level rise to 1 meter.\n\nfuture_2.physical_projection.sea_level_rise.value = 1.0\n\nWhile we have now edited the projection object, we have not yet saved the changes to the database. We can do this by using the save_projection() method with the argument overwrite=True, since we want to edit an existing projection.\n\nfa.save_projection(future_2, overwrite=True)\n\nNow we can verify that the projection has been updated in the database. The sea level rise is now 1 meter.\n\nfuture_2 = fa.get_projection(\"future_2\")\nfuture_2.physical_projection.sea_level_rise\n\nUnitfulLength(value=1.00, units=meters)",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-6-deleting-a-projection-from-the-database",
    "href": "3_api_docs/examples/projections/projections.html#step-6-deleting-a-projection-from-the-database",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "‚ùå Step 6: Deleting a Projection from the database",
    "text": "‚ùå Step 6: Deleting a Projection from the database\nWe now have 3 projections in the database.\n\npd.DataFrame(fa.get_projections())\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\n\n\n\n\n0\ncurrent\n\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 10:59:24.033007\n\n\n1\nfuture_1\n0.5 m sea level rise, 10% population growth, 5...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:37.549953\n\n\n2\nfuture_2\n1 m sea level rise, 10% population growth, 5% ...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:37.610428\n\n\n\n\n\n\n\nIf we want to delete a projection from the database, we can use the delete_projection() method of the FloodAdapt class. This method takes a single argument which is the name of the projection to be deleted. Let‚Äôs delete the projection we just created.\n\nfa.delete_projection(\"future_2\")\n\nWe can check that the projection has been indeed deleted from the database by using the get_projections() method of the FloodAdapt class. The projection with name ‚Äúfuture_2‚Äù is no longer in the database.\n\npd.DataFrame(fa.get_projections())\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\n\n\n\n\n0\ncurrent\n\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 10:59:24.033007\n\n\n1\nfuture_1\n0.5 m sea level rise, 10% population growth, 5...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:37.549953",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/projections/projections.html#step-7-use-of-sea-level-rise-scenarios",
    "href": "3_api_docs/examples/projections/projections.html#step-7-use-of-sea-level-rise-scenarios",
    "title": "üìò Example: Projections in FloodAdapt",
    "section": "üåê Step 7: Use of Sea Level Rise Scenarios",
    "text": "üåê Step 7: Use of Sea Level Rise Scenarios\nA FloodAdapt database can include sea level rise scenarios, describing a timeline of future sea level rise relative to a reference year. If these scenarios are available in the database the get_slr_scn_names() method will return a list of the available scenarios names.\n\nNote: ‚ÑπÔ∏è Adding sea level rise scenarios to your database. If you want to learn more about how to add sea level rise scenarios to your FloodAdapt database during system setup, you can check the Sea level rise (SLR) scenarios section of the FloodAdapt Setup Guide.\n\n\nfa.get_slr_scn_names()\n\n['NOAA Low',\n 'NOAA Intermediate-Low',\n 'NOAA Intermediate',\n 'NOAA Intermediate-High',\n 'NOAA High',\n 'NOAA Extreme']\n\n\nThe plot_slr_scenarios will create a temporary plot in html format, and will return the path of the html file. This allows to visualize the different scenarios in time.\n\n# Get the path of the html\nhtml_path = fa.plot_slr_scenarios()\n# Show the \nHTML(filename=html_path)  # Adjust width and height as needed\n\nThen the interp_slr() method can be used to interpolate the sea level rise for a given year. This method takes two arguments: the name of the scenario and the year for which we want to interpolate the sea level rise. The method returns a float value representing the interpolated sea level rise in the default length units of the database.\n\nfa.interp_slr(slr_scenario=\"NOAA High\", year=2050)\n\n1.9",
    "crumbs": [
      "Examples",
      "Projections"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html",
    "href": "3_api_docs/examples/events/synthetic_event.html",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a synthetic event using FloodAdapt. Synthetic events are valuable for controlled testing, sensitivity analysis, and understanding the behavior of flood models under simplified or hypothetical scenarios.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full synthetic event with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-1.-setup-and-imports",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing synthetic forcings and managing event data within the FloodAdapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import SyntheticEvent, TimeFrame\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\"\n\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:20:57 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:20:58 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-2.-define-the-simulation-time-frame",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the SyntheticEvent, from January 1 to January 2, 2025.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2025, month=1, day=1)\nend_time = datetime(year=2025, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-3.-define-water-level-forcing",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nSynthetic water levels are constructed from a combination of tidal and surge components. All FloodAdapt events require exactly 1 water level forcing, all other forcings are optional.\n\n# Synthetic water levels can be computed from a combination of surge and tide.\nsurge = f.SurgeModel(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulLength(value=2, units=us.UnitTypesLength.meters),\n    )\n)\n\ntide = f.TideModel(\n    harmonic_amplitude=us.UnitfulLength(value=1, units=us.UnitTypesLength.meters),\n    # Choose the middle of the time frame for peak time\n    harmonic_phase=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n    harmonic_period=us.UnitfulTime(value=12.4, units=us.UnitTypesTime.hours),\n)\n\nwater_levels_synthetic = f.WaterlevelSynthetic(\n    surge=surge,\n    tide=tide,\n)\n\n# Inspect\ngaussian = surge.timeseries.to_dataframe(time_frame=time_frame)\ngaussian.columns = [\"Surge\"]\nharmonic = tide.to_dataframe(time_frame=time_frame)\nharmonic.columns = [\"Tide\"]\ntotal = water_levels_synthetic.to_dataframe(time_frame=time_frame)\ntotal.columns = [\"Water levels\"]\ndf_combined = gaussian.join(harmonic).join(total)\ndf_combined.plot(\n    title=\"Synthetic Water Levels (Surge + Tide)\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=True,\n    figsize=(5, 2)\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üß© Step 4. Create a minimal event and modify it",
    "text": "üß© Step 4. Create a minimal event and modify it\nGiven a water level forcing, and a TimeFrame, you can create the simplest possible event in FloodAdapt as shown below.\nIn many cases, it is interesting to to investigate a combination of different forcings. In steps 5 - 9, we will show the creation of various forcings and how to add them to an event.\n\nsimple_event = SyntheticEvent(\n    name=\"simple_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels_synthetic],\n    }\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-5.-define-rainfall-forcing",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-5.-define-rainfall-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üåßÔ∏è Step 5. Define Rainfall Forcing",
    "text": "üåßÔ∏è Step 5. Define Rainfall Forcing\nThe rainfall options for a synthetic event are:\n\nConstant: Constant rainfall intensity for the entire simultion period and spatially uniform across the model domain.\nSynthetic: Custom rainfall intensity timeseries built from key parameters applied spatially uniform across the entire model domain. The key parameters can be used to describe either a gaussian-, block- or triangle-shaped rainfall curve.\nCSV: Custom rainfall intensity from a csv file applied spatially uniform across the entire model domain.\n\n\nrainfall_constant = f.RainfallConstant(\n    intensity=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr)\n)\n\nrainfall_synthetic = f.RainfallSynthetic(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr),\n    )\n)\n\nrainfall_csv = f.RainfallCSV(path=STATIC_DATA_DIR / \"rainfall.csv\")\n\n# Inspect\ndf_constant = rainfall_constant.to_dataframe(time_frame=time_frame)\ndf_constant.columns = [\"Constant\"]\ndf_synthetic = rainfall_synthetic.to_dataframe(time_frame=time_frame)\ndf_synthetic.columns = [\"Synthetic\"]\ndf_csv = rainfall_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"CSV\"]\n\ndf_combined = df_constant.join(df_synthetic).join(df_csv)\ndf_combined.plot(\n    title=\"Synthetic Rainfall (Constant, Gaussian, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Rainfall Intensity (mm/hr)\",\n    legend=True,\n    figsize=(5, 2)\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-5.-define-wind-forcing",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-5.-define-wind-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üå¨Ô∏è Step 5. Define Wind Forcing",
    "text": "üå¨Ô∏è Step 5. Define Wind Forcing\nThe wind options for a synthetic event are:\n\nCSV: Custom wind speed and direction from a csv file applied spatially uniform across the entire model domain.\nConstant: Constant wind speed and direction is applied spatially uniform across the entire model domain.\n\n\nNote: Wind set up in embayments, lagoons etc is only included for the water bodies included in the overland model. Large scale wind effects creating surges and wind set up are typically included in the water level forcing. When the water level forcing is set to ‚ÄúModel‚Äù (see ‚ÄòHistorical Event‚Äô), this effect can be simulated by FloodAdapt in the offshore model.\n\n\nwind_constant = f.WindConstant(\n    speed=us.UnitfulVelocity(value=12, units=us.UnitTypesVelocity.mps), \n    direction=us.UnitfulDirection(value=2, units=us.UnitTypesDirection.degrees) \n    # 0 degrees is North, 90 degrees is East, 180 degrees is South, and 270 degrees is West\n)\n\nwind_csv = f.WindCSV(path=STATIC_DATA_DIR / \"wind.csv\")\n\n# Inspect\ndf = wind_constant.to_dataframe(time_frame=time_frame)\ndf.columns = [\"speed\", \"direction\"]\ndf_csv = wind_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"speed\", \"direction\"]\ndf_combined = df.join(df_csv, lsuffix=\"_constant\", rsuffix=\"_csv\")\ndf_combined.plot(\n    title=\"Synthetic Wind (Constant, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Wind Speed (m/s)\",\n    legend=True,\n    figsize=(5, 2),\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-6.-define-river-discharge-forcing",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-6.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üèûÔ∏è Step 6. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 6. Define River Discharge Forcing\nDischarge is required to be defined for all pre-configured rivers. These rivers are registered in the hazard model configuration beforehand and it is important that the order of rivers and their source locations are consistent with the setup of the hazard model. The timeseries data provided will determine the in-flow of water at the river‚Äôs location.\nDischarge options for a SyntheticEvent are:\n\nConstant: Constant discharge for the entire simulation period.\nCSV: Custom discharge specified in a csv file.\nSynthetic: Custom discharge timeseries built from key parameters. The key parameters can be used to describe either a gaussian-, block- or triangle-shaped rainfall curve.\n\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event, you can only set the discharge of each given river.\nprint(f\"Number of available rivers: {len(fa.database.site.sfincs.river)}\")\n\nriver = fa.database.site.sfincs.river[0]\n\ndischarge_constant = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\ndischarge_synthetic = f.DischargeSynthetic(\n    river=river,\n    timeseries=f.BlockTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(time_frame.duration / 2), \n        peak_value=us.UnitfulDischarge(value=80, units=us.UnitTypesDischarge.cms),\n    )\n)\n\ndischarge_csv = f.DischargeCSV(\n    river=river,\n    path=STATIC_DATA_DIR / \"discharge.csv\"\n)\n\n# Inspect\ndf_constant = discharge_constant.to_dataframe(time_frame=time_frame)\ndf_constant.columns = [\"Constant\"]\ndf_synthetic = discharge_synthetic.to_dataframe(time_frame=time_frame)\ndf_synthetic.columns = [\"Synthetic\"]\ndf_csv = discharge_csv.to_dataframe(time_frame=time_frame)\ndf_csv.columns = [\"CSV\"]\ndf_combined = df_constant.join(df_synthetic).join(df_csv)\ndf_combined.plot(\n    title=\"Synthetic Discharge (Constant, Gaussian, CSV)\",\n    xlabel=\"Time\",\n    ylabel=\"Discharge (cms)\",\n    legend=True,\n    figsize=(5, 2)\n)\n\nNumber of available rivers: 1",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-7.-combine-forcings-and-create-synthetic-event",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-7.-combine-forcings-and-create-synthetic-event",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üß© Step 7. Combine Forcings and Create Synthetic Event",
    "text": "üß© Step 7. Combine Forcings and Create Synthetic Event\nAll defined forcings are collected into a single dictionary, which is used to construct a SyntheticEvent. Now construct the forcings dictionary that contains the forcings you want to include.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a SyntheticEvent with the forcings and time frame\nfull_event = SyntheticEvent(\n    name=\"example_synthetic_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels_synthetic],\n        f.ForcingType.RAINFALL: [rainfall_constant],\n        f.ForcingType.WIND: [wind_csv],\n        f.ForcingType.DISCHARGE: [discharge_synthetic], \n        # The discharge list needs to be exactly as long as the number of rivers in the hazard model\n    },\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/synthetic_event.html#step-8.-save-the-event-to-a-floodadapt-database",
    "href": "3_api_docs/examples/events/synthetic_event.html#step-8.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Synthetic Event in FloodAdapt",
    "section": "üíæ Step 8. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 8. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=full_event)",
    "crumbs": [
      "Examples",
      "Events",
      "Synthetic Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html",
    "href": "3_api_docs/examples/events/historical_event.html",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a historical event using FloodAdapt. Historical events are valuable for validation, controlled testing, sensitivity analysis, and what-if scenarios based on historic events.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full historical event with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-1.-setup-and-imports",
    "href": "3_api_docs/examples/events/historical_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing forcings and managing event data within the flood_adapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import HistoricalEvent, TimeFrame\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\"\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:20:08 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:20:08 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-2.-define-the-simulation-time-frame",
    "href": "3_api_docs/examples/events/historical_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the historical event, from January 1 to January 2, 2025.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2020, month=1, day=1)\nend_time = datetime(year=2020, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-3.-define-water-level-forcing",
    "href": "3_api_docs/examples/events/historical_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nHistorical water levels can be included in 3 few ways:\n\nTide Gauge: Measured water levels downloaded from NOAA CO-OPS. The automated download is only available for stations in the US. Outside the US, water level records can be stored in the FloodAdapt database. This avoids having to import the csv for each event, see below.\n\nCSV: Custom water levels specified in a csv file (perhaps from a tide gauge not connected to the noaa_coops API)\nModel: Generate the storm surge to be used for the overland simulation by running an offshore model. For historic events, this model uses weather re-analysis data (wind and pressure) from the NOAA GFS model.\n\n\n# Recorded water levels from a CSV file\ncsv_file = STATIC_DATA_DIR / \"tide.csv\"\nwater_levels = f.WaterlevelCSV(path=csv_file)\nwl_df = water_levels.to_dataframe(time_frame=time_frame)\n\n# Alternative: Water levels downloaded from a tide gauge\ntide_gauge = fa.database.site.sfincs.tide_gauge\ndf_tide_gauge = tide_gauge.get_waterlevels_in_time_frame(\n    time=time_frame,\n)\nwater_levels_gauged = f.WaterlevelGauged()\n\n# Alternative: Water levels simulated by an offshore model\nwater_levels_from_offshore = f.WaterlevelModel()\n\n# Inspect\nwl_df.plot(\n    title=\"Water Level from CSV\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=False,\n    figsize=(5, 2)\n)\n\ndf_tide_gauge.plot(\n    title=\"Water Level from Tide Gauge\",\n    xlabel=\"Time\",\n    ylabel=\"Water Level (m)\",\n    legend=False,\n    figsize=(5, 2)\n)\n\n2026-02-27 11:20:08 AM - FloodAdapt.TideGauge - INFO - Retrieving waterlevels for tide gauge 8665530 for 2020-01-01 00:00:00 - 2020-01-02 00:00:00",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "href": "3_api_docs/examples/events/historical_event.html#step-4.-create-a-minimal-event-and-modify-it",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üß© Step 4. Create a minimal event and modify it",
    "text": "üß© Step 4. Create a minimal event and modify it\nGiven a water level forcing, and a TimeFrame, you can create the simplest possible event in FloodAdapt as shown below.\nIn many cases, it is interesting to to investigate a combination of different forcings. In steps 5 - 9, we will show the creation of various forcings and how to add them to an event.\n\nsimple_event = HistoricalEvent(\n    name=\"simple_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels], \n        # or [water_levels_gauged], [water_levels_from_offshore]\n    }\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-5.-define-meteo-forcing",
    "href": "3_api_docs/examples/events/historical_event.html#step-5.-define-meteo-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üåßÔ∏è Step 5. Define Meteo Forcing",
    "text": "üåßÔ∏è Step 5. Define Meteo Forcing\nHistoric events have several options to define wind and rainfall, see also Synthetic event. Additionally, FloodAdapt provides an easy connection to NOAA GFS model re-analysis data for rainfall and wind that is automatically downloaded based on the event‚Äôs ‚ÄòTimeFrame‚Äô.\n\nmeteo_dataset = f.MeteoHandler(\n    lat=fa.database.site.lat,\n    lon=fa.database.site.lon,\n    dir=fa.database.static_path / \"meteo\"  # Directory to store meteo data\n).read(time_frame)\nprint(meteo_dataset) # TODO make sure the meteo files are already downloaded in the database to circumvent flaky noaa coops API calls\n\nRequested meteo data already available\n&lt;xarray.Dataset&gt; Size: 485kB\nDimensions:      (time: 9, x: 41, y: 41)\nCoordinates:\n  * time         (time) datetime64[ns] 72B 2020-01-01 ... 2020-01-02\n  * x            (x) float32 164B -90.0 -89.5 -89.0 -88.5 ... -71.0 -70.5 -70.0\n  * y            (y) float32 164B 23.0 23.5 24.0 24.5 ... 41.5 42.0 42.5 43.0\n    spatial_ref  int32 4B 0\nData variables:\n    wind10_u     (time, y, x) float64 121kB -5.165 -5.625 -6.085 ... 11.64 11.98\n    wind10_v     (time, y, x) float64 121kB -5.967 -5.257 ... -0.8354 -1.565\n    press_msl    (time, y, x) float64 121kB 1.017e+05 1.017e+05 ... 1.004e+05\n    precip       (time, y, x) float64 121kB 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0\n\n\n\nVisualizing Meteo data\nIt can be difficult to visualize spatially varying timeseries data. So, below is a simple animation generator to do some basic data checks on the downloaded NOAA GFS data.\nChoose any of the available timeseries data variables and generate the animation.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\nto_plot = 'press_msl' # available variables: 'wind10_u' or 'wind10_v' or 'press_msl' or 'precip'\n\nvar = meteo_dataset[to_plot] \nfig, ax = plt.subplots()\nplot = var.isel(time=0).plot(ax=ax, cmap='viridis', add_colorbar=True)\n\ndef update(frame):\n    ax.clear()\n    var.isel(time=frame).plot(ax=ax, cmap='viridis', add_colorbar=False)\n    ax.set_title(f'Time: {str(var.time[frame].values)}')\n\nani = animation.FuncAnimation(fig, update, frames=len(var.time), interval=200)\nplt.close(fig)\n\nHTML(ani.to_jshtml()) # TODO look at hvplot or other options to display the animation\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-6.-define-meteo-forcings",
    "href": "3_api_docs/examples/events/historical_event.html#step-6.-define-meteo-forcings",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üå¨Ô∏è Step 6. Define Meteo Forcings",
    "text": "üå¨Ô∏è Step 6. Define Meteo Forcings\nTo use the downloaded NOAA‚Äôs GFS hindcast data in FloodAdapt, you need to create Meteo forcings and add them to your event.\nUnder the hood, the meteo forcings use the MeteoHandler to download the data, and then return slices of that dataset.\n\nrainfall = f.RainfallMeteo()\nwind = f.WindMeteo()",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-7.-define-river-discharge-forcing",
    "href": "3_api_docs/examples/events/historical_event.html#step-7.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üèûÔ∏è Step 7. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 7. Define River Discharge Forcing\nDischarge is required to be defined for the pre-configured river(s). These rivers must be registered in the hazard model configuration beforehand.\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event\n# You can only set the discharge of each given river.\nprint(f\"Number of available rivers: {len(fa.database.site.sfincs.river)}\")\n\nriver = fa.database.site.sfincs.river[0]\n\ndischarge_constant = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\n# Inspect\ndf = discharge_constant.to_dataframe(time_frame=time_frame)\ndf.plot(\n    title=\"Constant Discharge River\",\n    xlabel=\"Time\",\n    ylabel=\"Discharge (cms)\",\n    legend=True,\n    figsize=(5, 2)\n)\n\nNumber of available rivers: 1",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-8.-combine-forcings-and-create-event",
    "href": "3_api_docs/examples/events/historical_event.html#step-8.-combine-forcings-and-create-event",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üß© Step 8. Combine Forcings and Create Event",
    "text": "üß© Step 8. Combine Forcings and Create Event\nAll defined forcings are collected into a single dictionary, which is used to construct a HistoricalEvent.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a HistoricalEvent with the forcings and time frame\nevent = HistoricalEvent(\n    name=\"example_historical_event\",\n    time=time_frame,\n    forcings={\n        f.ForcingType.WATERLEVEL: [water_levels], \n        # or one of `water_levels_gauged` or `water_levels_from_offshore`,\n        f.ForcingType.RAINFALL: [rainfall],\n        f.ForcingType.WIND: [wind],\n        f.ForcingType.DISCHARGE: [discharge_constant],\n    },\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/historical_event.html#step-9.-save-the-event-to-a-floodadapt-database",
    "href": "3_api_docs/examples/events/historical_event.html#step-9.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Historical Event in FloodAdapt",
    "section": "üíæ Step 9. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 9. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=event)",
    "crumbs": [
      "Examples",
      "Events",
      "Historical Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/event_set/create_event_set.html",
    "href": "3_api_docs/examples/event_set/create_event_set.html",
    "title": "Event set creation for Risk Analysis",
    "section": "",
    "text": "This notebook explains how to create the input files for a risk analysis in the correct format and place them in the correct folder structure. For an explanation on how to derive the (compound) events and their (joint) probabilities, the reader is referred to the FloodAdapt Setup Guide Event Set.",
    "crumbs": [
      "Examples",
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "3_api_docs/examples/event_set/create_event_set.html#step-1.-setup-and-imports",
    "href": "3_api_docs/examples/event_set/create_event_set.html#step-1.-setup-and-imports",
    "title": "Event set creation for Risk Analysis",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\n\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom flood_adapt import Settings, FloodAdapt\nfrom flood_adapt import unit_system as us\nfrom flood_adapt.config.sfincs import RiverModel\nfrom flood_adapt.objects import (\n    EventSet,\n    SubEventModel,\n    SyntheticEvent,\n)\nfrom flood_adapt.objects.forcing import (\n    DischargeConstant,\n    ForcingType,\n    TimeFrame,\n    ShapeType,\n    TimeseriesFactory,\n    RainfallSynthetic,\n    SurgeModel,\n    TideModel,\n    WaterlevelSynthetic,\n    WindConstant,\n)\n\nDATA_DIR = Path(\"../../../_data\").resolve()\n\n# Configure FloodAdapt\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:19:36 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:19:36 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "3_api_docs/examples/event_set/create_event_set.html#step-2.-set-name-frequencies-and-parameters-to-build-subevents",
    "href": "3_api_docs/examples/event_set/create_event_set.html#step-2.-set-name-frequencies-and-parameters-to-build-subevents",
    "title": "Event set creation for Risk Analysis",
    "section": "üóìÔ∏è Step 2. Set name, frequencies and parameters to build subevents",
    "text": "üóìÔ∏è Step 2. Set name, frequencies and parameters to build subevents\nSet the name of the event set and the parameters for the input events and their frequencies. In this example, we are using three synthetic events with different storm surge heights and peak rainfall intensities. Alternatively, historic gauged and ungauged events or hurricanes are possible as well, see Events for examples on how to set up different subevents.\n\nname = \"event_set\"\n\n# Peak surge values in the subevents. \n# Surge is timed to always peak at 24.8 hours after the event start, coinciding with high tide at a tidal phase of 0 and lasting for 10 hours.\nsurge_values = [2.5, 1, 3] # in meters\n\n# Peak rainfall intensities in the three subevents. \n# Rainfall is applied as a 6 hour \"block\" shape preceding the peak of the storm surge.\nrainfall_values = [10, 15, 5] # in mm/hr\n\n# Occurrence frequencies of the three events\nfreq = [0.1, 2, 0.05]",
    "crumbs": [
      "Examples",
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "3_api_docs/examples/event_set/create_event_set.html#step-3.-create-subevents",
    "href": "3_api_docs/examples/event_set/create_event_set.html#step-3.-create-subevents",
    "title": "Event set creation for Risk Analysis",
    "section": "üß© Step 3. Create subevents",
    "text": "üß© Step 3. Create subevents\nCreate the subevents from the parameters defined in Step 1.\n\nevents = []\nnumber = 0\nfor surge, rainfall in zip(surge_values, rainfall_values):\n    number += 1\n    events.append(\n        SyntheticEvent(\n            name = f\"subevent_{number}\",\n            time=TimeFrame(start_time=datetime(2020, 1, 1, 0, 0, 0),end_time=datetime(2020, 1, 3, 0, 0, 0)),\n            forcings={\n                # constant wind speed 10 m/, direction 90 degrees (from the East)\n                ForcingType.WIND: [         \n                    WindConstant(\n                        speed=us.UnitfulVelocity(value=10, units=us.UnitTypesVelocity.mps), \n                        direction=us.UnitfulDirection(\n                            value=90, units=us.UnitTypesDirection.degrees                  \n                        ),\n                    )\n                ],\n                # block rainfall starting 18h after event start, duration 6h, intensity 10 mm/hr \n                ForcingType.RAINFALL: [         \n                    RainfallSynthetic(\n                        timeseries = TimeseriesFactory.from_args(             \n                            shape_type=ShapeType.block,\n                            duration=us.UnitfulTime(\n                                value=6, units=us.UnitTypesTime.hours\n                            ),\n                            peak_time=us.UnitfulTime(\n                                value=21, units=us.UnitTypesTime.hours\n                            ),\n                            peak_value=us.UnitfulIntensity(\n                                value=rainfall, units=us.UnitTypesIntensity.mm_hr\n                            ),\n                        )\n                    )\n                ],\n                # constant discharge in Cooper River of 5000 cubic feet per second\n                ForcingType.DISCHARGE: [         \n                    DischargeConstant(\n                        river=RiverModel(\n                            name=\"cooper\",\n                            description=\"Cooper River\",\n                            x_coordinate=595546.3,\n                            y_coordinate=3675590.6,\n                            mean_discharge=us.UnitfulDischarge(\n                                value=5000, units=us.UnitTypesDischarge.cfs\n                            ),\n                        ),\n                        discharge=us.UnitfulDischarge(\n                            value=5000, units=us.UnitTypesDischarge.cfs \n                        ),\n                    )\n                ],\n                ForcingType.WATERLEVEL: [       \n                    WaterlevelSynthetic(\n                        # storm surge with gaussian shape, duration 10 hours, peak at 24h after event start_time, peak height 3m\n                        surge=SurgeModel(       \n                            timeseries=TimeseriesFactory.from_args(             \n                                shape_type=ShapeType.gaussian,\n                                duration=us.UnitfulTime(\n                                    value=10, units=us.UnitTypesTime.hours\n                                ),\n                                peak_time=us.UnitfulTime(\n                                    value=24, units=us.UnitTypesTime.hours\n                                ),\n                                peak_value=us.UnitfulLength(\n                                    value=surge, units=us.UnitTypesLength.meters\n                                ),\n                            )\n                        ),\n                        # tide with 1m amplitude and 12.4h duration\n                        tide=TideModel(     \n                            harmonic_amplitude=us.UnitfulLength(\n                                value=1, units=us.UnitTypesLength.meters\n                            ),\n                            harmonic_period=us.UnitfulTime(\n                                value=12.4, units=us.UnitTypesTime.hours\n                            ),\n                            harmonic_phase=us.UnitfulTime(\n                                value=0, units=us.UnitTypesTime.hours\n                            ),\n                        ),\n                    )\n                ],\n            },\n        )\n    )\n\nprint(events)\n\n[SyntheticEvent(name='subevent_1', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.00, units=m/s), direction=UnitfulDirection(value=90.00, units=deg N))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.00, units=hours), peak_time=UnitfulTime(value=21.00, units=hours), peak_value=UnitfulIntensity(value=10.00, units=mm/hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.00, units=cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.00, units=cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.00, units=hours), peak_time=UnitfulTime(value=24.00, units=hours), peak_value=UnitfulLength(value=2.50, units=meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.00, units=meters), harmonic_phase=UnitfulTime(value=0.00, units=hours), harmonic_period=UnitfulTime(value=12.40, units=hours)))]}, rainfall_multiplier=1.0), SyntheticEvent(name='subevent_2', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.00, units=m/s), direction=UnitfulDirection(value=90.00, units=deg N))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.00, units=hours), peak_time=UnitfulTime(value=21.00, units=hours), peak_value=UnitfulIntensity(value=15.00, units=mm/hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.00, units=cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.00, units=cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.00, units=hours), peak_time=UnitfulTime(value=24.00, units=hours), peak_value=UnitfulLength(value=1.00, units=meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.00, units=meters), harmonic_phase=UnitfulTime(value=0.00, units=hours), harmonic_period=UnitfulTime(value=12.40, units=hours)))]}, rainfall_multiplier=1.0), SyntheticEvent(name='subevent_3', description='', time=TimeFrame(start_time=datetime.datetime(2020, 1, 1, 0, 0), end_time=datetime.datetime(2020, 1, 3, 0, 0)), template=&lt;Template.Synthetic: 'Synthetic'&gt;, mode=&lt;Mode.single_event: 'single_event'&gt;, forcings={&lt;ForcingType.WIND: 'WIND'&gt;: [WindConstant(type=&lt;ForcingType.WIND: 'WIND'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, speed=UnitfulVelocity(value=10.00, units=m/s), direction=UnitfulDirection(value=90.00, units=deg N))], &lt;ForcingType.RAINFALL: 'RAINFALL'&gt;: [RainfallSynthetic(type=&lt;ForcingType.RAINFALL: 'RAINFALL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, timeseries=BlockTimeseries(shape_type=&lt;ShapeType.block: 'block'&gt;, duration=UnitfulTime(value=6.00, units=hours), peak_time=UnitfulTime(value=21.00, units=hours), peak_value=UnitfulIntensity(value=5.00, units=mm/hr), cumulative=None, fill_value=0.0))], &lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;: [DischargeConstant(type=&lt;ForcingType.DISCHARGE: 'DISCHARGE'&gt;, source=&lt;ForcingSource.CONSTANT: 'CONSTANT'&gt;, river=RiverModel(name='cooper', description='Cooper River', mean_discharge=UnitfulDischarge(value=5000.00, units=cfs), x_coordinate=595546.3, y_coordinate=3675590.6), discharge=UnitfulDischarge(value=5000.00, units=cfs))], &lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;: [WaterlevelSynthetic(type=&lt;ForcingType.WATERLEVEL: 'WATERLEVEL'&gt;, source=&lt;ForcingSource.SYNTHETIC: 'SYNTHETIC'&gt;, surge=SurgeModel(timeseries=GaussianTimeseries(shape_type=&lt;ShapeType.gaussian: 'gaussian'&gt;, duration=UnitfulTime(value=10.00, units=hours), peak_time=UnitfulTime(value=24.00, units=hours), peak_value=UnitfulLength(value=3.00, units=meters), cumulative=None, fill_value=0.0)), tide=TideModel(harmonic_amplitude=UnitfulLength(value=1.00, units=meters), harmonic_phase=UnitfulTime(value=0.00, units=hours), harmonic_period=UnitfulTime(value=12.40, units=hours)))]}, rainfall_multiplier=1.0)]",
    "crumbs": [
      "Examples",
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "3_api_docs/examples/event_set/create_event_set.html#step-4.-create-and-save-event-set",
    "href": "3_api_docs/examples/event_set/create_event_set.html#step-4.-create-and-save-event-set",
    "title": "Event set creation for Risk Analysis",
    "section": "üíæ Step 4. Create and save event set",
    "text": "üíæ Step 4. Create and save event set\nIn this step, we create an event set from the SubEvents created in Step 2, load the actual Event objects into it, and save it to the database. This event set can then be used like any other event in a Scenario. Click here to see examples on how to build a scenario.\n\nsub_events = []\nfor event, frequency in zip(events, freq):\n    sub_events.append(SubEventModel(name=event.name, frequency=frequency))\n\n\nevent_set = EventSet(\n    name=name,\n    sub_events=sub_events,\n)\nevent_set.load_sub_events(events)\n\nfa.save_event(event_set)\nprint(fa.get_events()[\"name\"])\n\n['test_set', 'event_set']",
    "crumbs": [
      "Examples",
      "Event set for risk assessments"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to the FloodAdapt documentation! This introduction will help you get oriented with FloodAdapt and learn how to use this guide effectively. It includes:"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Introduction",
    "section": "Overview",
    "text": "Overview\nFloodAdapt is an interactive decision-support tool which aims to accelerate and improve flood adaptation planning. It connects users to powerful modeling tools through an intuitive graphical interface, enabling the creation, simulation, and comparison of flooding and impact scenarios without requiring modeling expertise. Built with community-level planning needs in mind, FloodAdapt supports meaningful stakeholder engagement and helps translate scientific advances into actionable insights.\n\n\n\n\n\n\nFigure¬†1: Examples of the kinds of questions users can answer with FloodAdapt\n\n\n\nFloodAdapt allows users to specify and simulate what-if scenarios that combine weather events (historical or synthetic), climate or socio-economic future projections, and adaptation strategies. These scenarios can include hurricanes, coastal storms, high tides, rainfall events, and heavy river discharges, along with future projections such as sea level rise, increased storm frequency, and urban growth. Users can explore a wide range of adaptation options - from levees, pumps, and sea walls to green infrastructure, building elevations, buyouts, and floodproofing - and evaluate their effectiveness in reducing flood impacts.\nFloodAdapt is essentially a smart shell that prepares, runs, and post-processes simulations using two open-source tools: the process-based compound flood modeling software SFINCS and the flood impact assessment tool Delft-FIAT. SFINCS simulates flooding from rainfall, tide, storm surge, and river discharge, while Delft-FIAT estimates damages to buildings, roads, and other assets, and aggregates them spatially or by other specified attributes (such as social vulnerability or income level). FloodAdapt does not come pre-loaded with baseline SFINCS and Delft-FIAT models; these need to be set up for a new location as part of system setup. The accuracy of FloodAdapt outputs will depend on the quality of the baseline SFINCS and Delft-FIAT models for a given location.\nWhen a user specifies a what-if scenario, FloodAdapt automatically makes changes to the baseline SFINCS and Delft-FIAT models to represent the user choices, the way an expert modeler would. It then simulates the scenario and returns flood and impact maps, scenario comparison visualizations, summary metrics, and an infographic. In this way, FloodAdapt allows end-users to unleash the power of advanced models without requiring a modeling background, or the laborious pre- and post-processing of models that is usually required for this type of analysis.\n\n\n\n\n\n\nFigure¬†2: Schematic showing the design concepts behind the FloodAdapt software"
  },
  {
    "objectID": "index.html#intended-uses-of-floodadapt",
    "href": "index.html#intended-uses-of-floodadapt",
    "title": "Introduction",
    "section": "Intended Uses of FloodAdapt",
    "text": "Intended Uses of FloodAdapt\nFloodAdapt was developed to support adaptation and resilience planning, to provide community understanding of the flooding and impacts resulting from different scenarios of interest, to understand the urgency of actions in different areas, to aid in prioritizing investments, and to assess the effectiveness, benefits, and longevity of different adaptation options.\nFloodAdapt is not intended for use in the detailed engineering design of adaptation measures, particularly hydraulic ones. Once FloodAdapt has helped the community identify strategies and priority areas for improvements, the specific design requirements for these strategies should be done using more comprehensive modeling tools available. These may need to include detailed drainage infrastructure systems, groundwater, or other components not currently built into FloodAdapt."
  },
  {
    "objectID": "index.html#reader-guidance",
    "href": "index.html#reader-guidance",
    "title": "Introduction",
    "section": "Reader Guidance",
    "text": "Reader Guidance\nThe FloodAdapt documentation is separated into four sections:\n\nUser Guide The user guide provides information on how to get started with FloodAdapt, and describes how to use all the FloodAdapt functionalities. This guide is intended for FloodAdapt users.\nTechnical background - The technical docs provide detailed information on the calculation methods within FloodAdapt. This is intended for technically-minded users who want to better understand what is happening under the hood.\nAPI documentation - The API documentation is intended for users who would like to directly use the backend of FloodAdapt, bypassing the graphical user interface. This documentation explains the API functions and provides example notebooks demonstrating API usage.\nSetup Guide - The setup guide is intended for more technical users who will be setting up FloodAdapt in a new location."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n Back to top"
  },
  {
    "objectID": "4_system_setup/index.html",
    "href": "4_system_setup/index.html",
    "title": "System setup",
    "section": "",
    "text": "To get started with FloodAdapt in a new location, a site-specific FloodAdapt database needs to be created. To support users in the creation of this database, the FloodAdapt program includes a database builder. This documentation describes the information needed by the database builder, and how to provide that information based on whether you want to work in a Python environment, or prefer to work with an executable (no Python needed).\nThe FloodAdapt database-builder is intended to greatly simplify the process of setting up FloodAdapt in a new location. The FloodAdapt software is an ‚Äòempty shell‚Äô that must be connected to a site-specific database. The database-builder aids the user in setting up this database.\nThe most critical components of the FloodAdapt database are the SFINCS and Delft-FIAT models, both of which can now be generated with greater ease using the SFINCS model-builder and the Delft-FIAT model-builder. Once these have been created, users can run the FloodAdapt database-builder to generate a complete database for a functioning FloodAdapt application at their site.\nTo run the database-builder, a user double-clicks the FloodAdapt database-builder executable. This opens a screen where the user can enter a file path to the database-builder configuration file.\nThis documentation will describe the FloodAdapt database-builder configuration file. Depending on the amount of information included in the configuration file, different FloodAdapt functionalities will be activated. This is described in the section FloodAdapt capabilities based on configuration. It starts by outlining the minimum information required to generate a functional FloodAdapt system, and then specifies additional functionalities and the required information in the configuration file to activate them. The section Configuration file attributes specifies all of the attributes that can be included in the database-builder configuration and includes details about their format and use."
  },
  {
    "objectID": "4_system_setup/index.html#floodadapt-capabilities-based-on-configuration",
    "href": "4_system_setup/index.html#floodadapt-capabilities-based-on-configuration",
    "title": "System setup",
    "section": "FloodAdapt capabilities based on configuration",
    "text": "FloodAdapt capabilities based on configuration\nThere are different functionalities that are activated in FloodAdapt depending on the information contained in the configuration file. This section starts by describing the information needed for the baseline FloodAdapt configuration, which is the minimum needed to set up a functional FloodAdapt system. Note that an important requirement is that a Delft-FIAT model and an overland SFINCS model have been set up for the site. The subsequent sections then describe additional FloodAdapt functionality that is activated with additional configuration input.\n\nBaseline FloodAdapt configuration\nA baseline FloodAdapt configuration is a functional version of FloodAdapt that requires the minimum amount of configuration file input. This version allows users to run event scenarios for either a synthetic event or a historical gauged event. All measures and future projections are available for analysis. Note that because it only supports event scenarios, the risk and benefits options are not available for this baseline configuration.\nA baseline FloodAdapt configuration allows users to get started with FloodAdapt with relatively little required information. The following is all that is required for a baseline configuration:\n\nA name for your site\nThe path to your overland SFINCS model folder\nThe path to your Delft-FIAT model folder\nThe unit system you want to work in (imperial or metric)\nMax values for output maps displayed in the FloodAdapt user interface\n\n\n\n\n\n\n\nTipIncluding the baseline configuration attributes in the database configuration file\n\n\n\nThe name of your site, paths to your SFINCS and Delft-FIAT models, and the unit system are all specified in the header section of the configuration file which is described under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section. The max values for output maps are specified in the GUI attributes section.\n\n\n\n\nRisk and benefit analysis\nThe baseline FloodAdapt configuration allows users to simulate event scenarios, which can be very insightful. However, risk scenarios allow users to understand the current and future risk to a community (considering many types of events), with and without adaptation options, and to calculate the risk-reduction benefits of adaptation strategies. To activate the risk scenario and benefit analysis functionality, a probabilistic event set is required. When this set is included in the FloodAdapt database, FloodAdapt can calculate the flooding for all the events in the set and uses a probabilistic calculator to calculate return period flooding, impacts, and risk.\n\n\n\n\n\n\n\nTipIncluding a probabilistic event set in the database configuration file\n\n\n\nSpecifying a probabilistic event set is done in the Header section of the configuration file. See the attributes in the Header section under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section.\n\n\n\n\nSimulating hurricane events and ‚Äòungauged‚Äô historical events\nFor FloodAdapt users to simulate a scenario with a historical hurricane, or to simulate a historical event for which there are no measured nearshore water levels, an offshore SFINCS model needs to be included in the FloodAdapt database (this can be created with the SFINCS model-builder). Once an offshore model is included, users will see additional event types that can be selected when they click ‚ÄúAdd Event‚Äù in the FloodAdapt Events tab (see Figure¬†1). If a specific cyclone basin is specified in the database configuration file, only hurricanes in the specified basin will be included in the database and displayed in the hurricane selector window (which appears when the ‚ÄòHistorical - hurricane‚Äô option is chosen); see Figure¬†2. Note that if hurricanes are not relevant in an area, but an offshore model is included to simulate ungauged historical events, the hurricane event option can be ‚Äúturned off‚Äù in the database configuration file. \n\n\n\n\n\n\nFigure¬†1: Adding an offshore model activates the ability to select a hurricane event, as well as an ‚Äòungauged‚Äô historical event. Both of these event types make use of the offshore model. The left window shows the ‚ÄúAdd event‚Äù popup window for the baseline FloodAdapt configuration, and the right shows with the addition of an offshore model\n\n\n\n\n\n\n\n\n\nFigure¬†2: Hurricane selection window when a user has selected ‚ÄúNA‚Äù for North America as the ‚Äòcyclone basin‚Äô\n\n\n\n\n\n\n\n\n\nTipIncluding an offshore model and cyclone basin in the database configuration file\n\n\n\nSpecifying an offshore SFINCS model and a cyclone basin is done in the Header section of the configuration file. See the attributes in the Header section under ‚ÄòConfiguration file attributes‚Äô in the Header attributes section.\n\n\n\n\nDownloading historical water levels\nFloodAdapt allows users to simulate historical events. In the baseline FloodAdapt configuration, FloodAdapt users need to import their own water level time series for historical events. When a tide gauge (or alternatively a long time series CSV file) is added to the FloodAdapt database, this activates a ‚ÄòDownload Observed Water Levels‚Äô button in the specification window for a historical event. FloodAdapt users can then easily download water levels for a historical event by selecting a start and end date and clicking that button. Figure¬†3 shows the baseline FloodAdapt configuration on the left and with the inclusion of a tide gauge on the right. For sites in the U.S. tide gauges can be added automatically based on the site location via the NOAA COOPS website. The NOAA site also includes datum differences at gauge locations, so that users have the option to view water levels relative to a (potentially) more familiar datum (see Figure¬†3).\n\n\n\n\n\n\nFigure¬†3: Adding a tide gauge allows a user to activate the ‚ÄòDownload observed water levels‚Äô button. Additionally, it also allows users to specify different references they can view with the water level time series, and to set a different reference level (‚Äòzero‚Äô) than mean sea level (MSL). The left window shows the baseline FloodAdapt configuration, and the right shows with the addition of a tide gauge.\n\n\n\n\n\n\n\n\n\nTipIncluding a tide gauge in the database configuration file\n\n\n\nDetails how to include a tide gauge (or long water level time series) to activate the ‚ÄòDownload Observed Water Levels‚Äô button are described under ‚ÄòConfiguration file attributes‚Äô in the Tide Gauge section.\n\n\n\n\nSocial vulnerability insights\nFloodAdapt automatically generates an infographic and a metrics table which helps FloodAdapt users understand the impacts of a simulated scenario. Social vulnerability is based on a collection of socio-economic attributes that indicate a longer or harder recovery from a flood event. When a social vulnerability index (SVI) layer is included in the FloodAdapt database, FloodAdapt shows additional information in the infographic and metrics table related to how socially vulnerable people are affected in a simulated scenario. Users can also view the SVI layer in both the Measures and Output tabs, helping to identify where to explore measures and understand the impacts to socially vulnerable people. Figure¬†4 highlights the added information in the infographic and metrics table. It shows the baseline configuration on the left, and the configuration with an SVI layer added on the right. With the SVI layer included, users can see in the infographic the proportion of highly-vulnerable residential buildings that were damaged and destroyed. In the metrics table, they can see how many highly vulnerable residential properties were flooded.\n\n\n\n\n\n\nFigure¬†4: When an SVI layer and a threshold are included, the infographic will include an additional graphic showing the distribution of residential impacts on high and low socially vulnerable homes \n\n\n\n\n\n\n\n\n\nTipIncluding an SVI layer in the database configuration file\n\n\n\nThe attributes needed to include an SVI layer are described under ‚ÄòConfiguration file attributes‚Äô in the Social vulnerability index section.\n\n\n\n\nVisualizing water level output time series\nFloodAdapt allows users to view modeled water level time series at observation points in the FloodAdapt Output tab. The spatial flood map in the FloodAdapt Output tab is static and represents the maximum flood depth during an event. Having observation points helps users understand how the water levels evolved during an event. To activate this functionality, observation points can be added to the database-builder configuration file.\n\n\n\n\n\n\nFigure¬†5: Adding observation points activates the functionality to view water level time series output at these points in the FloodAdapt Output tab. The left window shows the baseline FloodAdapt configuration, and the right shows with the addition of observation points.\n\n\n\n\n\n\n\n\n\nTipIncluding observation points in the database configuration file\n\n\n\nThe attributes needed to include observation points are described under ‚ÄòConfiguration file attributes‚Äô in the Observation Points section.\n\n\n\n\nElevating buildings above base flood elevation (BFE)\nFloodAdapt allows users to explore home elevations as an adaptation measure. With the base configuration, FloodAdapt users can specify how high a home should be elevated relative to a datum. However, in the U.S. standards for home elevations or elevations of new buildings are often specified relative to base flood elevation (BFE). This is a regulatory 100-year flood level calculated by the federal government. When users reference a base flood elevation layer in the configuration file, FloodAdapt users can choose to elevate homes above a datum or to a height above BFE.\n\n\n\n\n\n\nTipIncluding a BFE layer in the database configuration file\n\n\n\nThe attributes needed to include a BFE layer are described under ‚ÄòConfiguration file attributes‚Äô in the Base Flood Elevation section.\n\n\n\n\n\n\n\n\nFigure¬†6: Adding a base flood elevation (BFE) layer activates the ability to elevate homes relative to BFE in addition to elevating relative to datum\n\n\n\n\n\nSea level rise scenario selection\nFloodAdapt allows users to explore the flooding and impacts for future sea level rise projections. In the base configuration case, users have access to this functionality, and can enter a sea level rise explicitly, for example ‚Äú0.5 feet‚Äù. However, FloodAdapt users may want to explore flooding and impacts at a specific point in the future, for example in 15 or 20 years, and they may not know the sea level rise to expect in that future year. To facilitate these users, a sea level rise scenario CSV file can be included in the database setup. There are many sources for sea level rise scenarios, such as the interagency sea level task force. There is no limit to the number of SLR scenarios a user can include. FloodAdapt uses this file to generate a visualization showing the different SLR scenario curves in the Projections selection window. It also allows a user to enter a future year and select a SLR scenario, and then automatically calculates the sea level rise for that year.\n\n\n\n\n\n\nTipIncluding SLR scenarios in the database configuration file\n\n\n\nThe attributes needed to specify SLR scenarios are described under ‚ÄòConfiguration file attributes‚Äô in the Sea Level Rise Scenarois section.\n\n\n\n\n\n\n\n\nFigure¬†7: Including a sea level rise scenario CSV file allows a user to select one of the SLR scenarios and a future year, and FloodAdapt automatically calculates the sea level rise\n\n\n\n\n\n\n\n\n\nNoteWhat about when sea level rise scenarios change?\n\n\n\nSea level rise scenarios are updating every few years. Updating the sea level rise scenarios in FloodAdapt is a simple as updating the CSV file with the years and projected sea level rise. FloodAdapt will then automatically use the new information when a FloodAdapt user selects a future year and a sea level rise scenario."
  },
  {
    "objectID": "3_api_docs/index.html",
    "href": "3_api_docs/index.html",
    "title": "FloodAdapt API user documentation",
    "section": "",
    "text": "Welcome to the FloodAdapt backend user documentation. This section is intended for readers with a programming and/or modeling background who want to operate FloodAdapt without the user interface, by interacting directly with the FloodAdapt backend via use of the FloodAdapt API.\nThe backend-user documentation includes two main sections:\n\nAPI reference documentation\nAPI usage examples via Python notebooks\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/examples/projections/index.html",
    "href": "3_api_docs/examples/projections/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/examples/events/index.html",
    "href": "3_api_docs/examples/events/index.html",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt provides a structured system for defining and managing hazard events that can be used for simulation, testing, and analysis. Events are central to the framework, consisting of the time frame of interest as well as all relevant hydrometeorological forcings such as:\n\nWater levels\nRainfall\nWind\nRiver discharge\n\nThese forcings can be derived from measurements or generated synthetically to support hypothetical or controlled scenarios. All event data is stored in a database, ensuring reproducibility and consistency across simulation workflows.\n\n\nAn event in FloodAdapt consists of 1. a TimeFrame, and 2. a (collection of) forcing(s) depending on the event type.\nA TimeFrame is a combination of the event start and end time.\nForcings in FloodAdapt are modular and extensible, allowing fine control over how each physical process is represented. For example, synthetic surge and tide can be combined into a single synthetic water level signal using a Gaussian curve for surge and a cosine function for tide. You can start building your own events by exploring the API reference or following the structure shown in the example. The modular design makes it easy to plug in your own forcing data, synthetic models, or customized logic. You can find a list of all available forcing classes here !TODO!\n\n\n\nFloodAdapt supports three types of events:3_api_docs.qmd\nTo see a full example of how to define an event, refer to the following notebooks:\nSynthetic Event: Synthetic timeseries built from key parameters.\nHistorical Event: Built from real-world observations or meteorological hindcast data.\nHurricane Event: Run an offshore hazard model using wind and pressure fields from cyclone tracks to generate the waterlevels for the overland hazard model. Only available when the database has an offshore model.\nEvent modification: Modify existing events or build new events from existing ones.",
    "crumbs": [
      "Examples",
      "Events"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/index.html#components-of-an-event",
    "href": "3_api_docs/examples/events/index.html#components-of-an-event",
    "title": "Events",
    "section": "",
    "text": "An event in FloodAdapt consists of 1. a TimeFrame, and 2. a (collection of) forcing(s) depending on the event type.\nA TimeFrame is a combination of the event start and end time.\nForcings in FloodAdapt are modular and extensible, allowing fine control over how each physical process is represented. For example, synthetic surge and tide can be combined into a single synthetic water level signal using a Gaussian curve for surge and a cosine function for tide. You can start building your own events by exploring the API reference or following the structure shown in the example. The modular design makes it easy to plug in your own forcing data, synthetic models, or customized logic. You can find a list of all available forcing classes here !TODO!",
    "crumbs": [
      "Examples",
      "Events"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/index.html#event-types",
    "href": "3_api_docs/examples/events/index.html#event-types",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt supports three types of events:3_api_docs.qmd\nTo see a full example of how to define an event, refer to the following notebooks:\nSynthetic Event: Synthetic timeseries built from key parameters.\nHistorical Event: Built from real-world observations or meteorological hindcast data.\nHurricane Event: Run an offshore hazard model using wind and pressure fields from cyclone tracks to generate the waterlevels for the overland hazard model. Only available when the database has an offshore model.\nEvent modification: Modify existing events or build new events from existing ones.",
    "crumbs": [
      "Examples",
      "Events"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/TimeFrame.html",
    "href": "3_api_docs/api_ref/objects/TimeFrame.html",
    "title": "TimeFrame",
    "section": "",
    "text": "objects.TimeFrame()\nClass representing a time frame for a simulation.\n\n\n\nstart_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "TimeFrame"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/TimeFrame.html#attributes",
    "href": "3_api_docs/api_ref/objects/TimeFrame.html#attributes",
    "title": "TimeFrame",
    "section": "",
    "text": "start_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "TimeFrame"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SyntheticEvent.html",
    "href": "3_api_docs/api_ref/objects/SyntheticEvent.html",
    "title": "SyntheticEvent",
    "section": "",
    "text": "objects.SyntheticEvent()\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SyntheticEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SyntheticEvent.html#attributes",
    "href": "3_api_docs/api_ref/objects/SyntheticEvent.html#attributes",
    "title": "SyntheticEvent",
    "section": "",
    "text": "time : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SyntheticEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Strategy.html",
    "href": "3_api_docs/api_ref/objects/Strategy.html",
    "title": "Strategy",
    "section": "",
    "text": "objects.Strategy()\nClass representing a strategy in FloodAdapt.\nA strategy is a collection of measures that can be applied to a model.\n\n\n\nmeasures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Strategy.html#attributes",
    "href": "3_api_docs/api_ref/objects/Strategy.html#attributes",
    "title": "Strategy",
    "section": "",
    "text": "measures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Strategy.html#methods",
    "href": "3_api_docs/api_ref/objects/Strategy.html#methods",
    "title": "Strategy",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Strategies",
      "Strategy"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SelectionType.html",
    "href": "3_api_docs/api_ref/objects/SelectionType.html",
    "title": "SelectionType",
    "section": "",
    "text": "objects.SelectionType()\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\nIt is used to determine where to apply the measure to a model.\n\n\n\naggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "SelectionType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SelectionType.html#attributes",
    "href": "3_api_docs/api_ref/objects/SelectionType.html#attributes",
    "title": "SelectionType",
    "section": "",
    "text": "aggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "SelectionType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Pump.html",
    "href": "3_api_docs/api_ref/objects/Pump.html",
    "title": "Pump",
    "section": "",
    "text": "objects.Pump()\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Pump"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Pump.html#attributes",
    "href": "3_api_docs/api_ref/objects/Pump.html#attributes",
    "title": "Pump",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Pump"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/PhysicalProjection.html",
    "href": "3_api_docs/api_ref/objects/PhysicalProjection.html",
    "title": "PhysicalProjection",
    "section": "",
    "text": "objects.PhysicalProjection()\nThe accepted input for a physical projection in FloodAdapt.\n\n\n\nsea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "PhysicalProjection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/PhysicalProjection.html#attributes",
    "href": "3_api_docs/api_ref/objects/PhysicalProjection.html#attributes",
    "title": "PhysicalProjection",
    "section": "",
    "text": "sea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "PhysicalProjection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/MeasureType.html",
    "href": "3_api_docs/api_ref/objects/MeasureType.html",
    "title": "MeasureType",
    "section": "",
    "text": "objects.MeasureType()\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\nEach type of measure is associated with a category (hazard or impact) and can be used to determine the type of measure.\n\n\n\nfloodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "MeasureType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/MeasureType.html#attributes",
    "href": "3_api_docs/api_ref/objects/MeasureType.html#attributes",
    "title": "MeasureType",
    "section": "",
    "text": "floodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "MeasureType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/IForcing.html",
    "href": "3_api_docs/api_ref/objects/IForcing.html",
    "title": "IForcing",
    "section": "",
    "text": "objects.IForcing()\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncontent_fingerprint\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.content_fingerprint()\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\nIf a file-backed path attribute exists and the file exists, hash its bytes (SHA-256).\nOtherwise, hash a canonical JSON dump of the model (excluding volatile fields like path).\n\n\n\n\n : str\n\nA fingerprint string that changes when the forcing‚Äôs effective data changes.\n\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "IForcing"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/IForcing.html#methods",
    "href": "3_api_docs/api_ref/objects/IForcing.html#methods",
    "title": "IForcing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncontent_fingerprint\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.content_fingerprint()\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\nIf a file-backed path attribute exists and the file exists, hash its bytes (SHA-256).\nOtherwise, hash a canonical JSON dump of the model (excluding volatile fields like path).\n\n\n\n\n : str\n\nA fingerprint string that changes when the forcing‚Äôs effective data changes.\n\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "IForcing"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/HistoricalEvent.html",
    "href": "3_api_docs/api_ref/objects/HistoricalEvent.html",
    "title": "HistoricalEvent",
    "section": "",
    "text": "objects.HistoricalEvent()\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HistoricalEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/HistoricalEvent.html#attributes",
    "href": "3_api_docs/api_ref/objects/HistoricalEvent.html#attributes",
    "title": "HistoricalEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HistoricalEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/ForcingType.html",
    "href": "3_api_docs/api_ref/objects/ForcingType.html",
    "title": "ForcingType",
    "section": "",
    "text": "objects.ForcingType()\nEnum class for the different types of forcing parameters.\n\n\n\nRAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "ForcingType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/ForcingType.html#attributes",
    "href": "3_api_docs/api_ref/objects/ForcingType.html#attributes",
    "title": "ForcingType",
    "section": "",
    "text": "RAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "ForcingType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/FloodProof.html",
    "href": "3_api_docs/api_ref/objects/FloodProof.html",
    "title": "FloodProof",
    "section": "",
    "text": "objects.FloodProof()\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodProof"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/FloodProof.html#attributes",
    "href": "3_api_docs/api_ref/objects/FloodProof.html#attributes",
    "title": "FloodProof",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodProof"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Event.html",
    "href": "3_api_docs/api_ref/objects/Event.html",
    "title": "Event",
    "section": "",
    "text": "objects.Event()\nThe accepted input for an event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_equivalent\nDeep-compare two events, including forcing data contents.\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.data_equivalent(other: Event)\nDeep-compare two events, including forcing data contents.\nCompares core attributes (time, template, mode, rainfall_multiplier) and then verifies that each forcing (by type) has the same data fingerprint. For path-based forcings, the fingerprint hashes the file bytes; for others, a canonical attribute-based hash is used.\n\n\n\nother : Event\n\nThe event to compare against.\n\n\n\n\n\n\n : bool\n\nTrue when events are equivalent in terms of their hazard inputs.\n\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Event.html#attributes",
    "href": "3_api_docs/api_ref/objects/Event.html#attributes",
    "title": "Event",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Event.html#methods",
    "href": "3_api_docs/api_ref/objects/Event.html#methods",
    "title": "Event",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_equivalent\nDeep-compare two events, including forcing data contents.\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.data_equivalent(other: Event)\nDeep-compare two events, including forcing data contents.\nCompares core attributes (time, template, mode, rainfall_multiplier) and then verifies that each forcing (by type) has the same data fingerprint. For path-based forcings, the fingerprint hashes the file bytes; for others, a canonical attribute-based hash is used.\n\n\n\nother : Event\n\nThe event to compare against.\n\n\n\n\n\n\n : bool\n\nTrue when events are equivalent in terms of their hazard inputs.\n\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Event"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/CurrentSituationModel.html",
    "href": "3_api_docs/api_ref/objects/CurrentSituationModel.html",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "objects.CurrentSituationModel()\nThe accepted input for a current situation in FloodAdapt.\n\n\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "CurrentSituationModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/CurrentSituationModel.html#attributes",
    "href": "3_api_docs/api_ref/objects/CurrentSituationModel.html#attributes",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "projection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "CurrentSituationModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Benefit.html",
    "href": "3_api_docs/api_ref/objects/Benefit.html",
    "title": "Benefit",
    "section": "",
    "text": "objects.Benefit()\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\n\nname : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "Benefit"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Benefit.html#attributes",
    "href": "3_api_docs/api_ref/objects/Benefit.html#attributes",
    "title": "Benefit",
    "section": "",
    "text": "name : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Benefits",
      "Benefit"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/SviModel.html",
    "href": "3_api_docs/api_ref/database_builder/SviModel.html",
    "title": "SviModel",
    "section": "",
    "text": "database_builder.SviModel()\nModel for Social Vulnerability Index (SVI) configuration.\n\n\n\nclasses : list[str], default=[\"Low\", \"High\"]\n\nList of vulnerability class names.\n\ncolors : list[str], default=[\"#D5DEE1\", \"#88A2AA\"]\n\nList of colors corresponding to each vulnerability class.\n\nthresholds : list[float], default=[0.7]\n\nList of threshold values for vulnerability classification.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nvalidate_colors_length\nValidate that colors list length matches classes list length.\n\n\nvalidate_thresholds_length\nValidate that thresholds list length is one less than classes list length.\n\n\n\n\n\ndatabase_builder.SviModel.validate_colors_length(colors, info)\nValidate that colors list length matches classes list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match classes length.\n\n\n\n\n\n\ndatabase_builder.SviModel.validate_thresholds_length(thresholds, info)\nValidate that thresholds list length is one less than classes list length.\n\n\n\nthresholds : list[float]\n\nList of threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated thresholds list.\n\n\n\n\n\n\n: ValueError\n\nIf thresholds length is not one less than classes length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "SviModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/SviModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/SviModel.html#attributes",
    "title": "SviModel",
    "section": "",
    "text": "classes : list[str], default=[\"Low\", \"High\"]\n\nList of vulnerability class names.\n\ncolors : list[str], default=[\"#D5DEE1\", \"#88A2AA\"]\n\nList of colors corresponding to each vulnerability class.\n\nthresholds : list[float], default=[0.7]\n\nList of threshold values for vulnerability classification.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "SviModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/SviModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/SviModel.html#methods",
    "title": "SviModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nvalidate_colors_length\nValidate that colors list length matches classes list length.\n\n\nvalidate_thresholds_length\nValidate that thresholds list length is one less than classes list length.\n\n\n\n\n\ndatabase_builder.SviModel.validate_colors_length(colors, info)\nValidate that colors list length matches classes list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match classes length.\n\n\n\n\n\n\ndatabase_builder.SviModel.validate_thresholds_length(thresholds, info)\nValidate that thresholds list length is one less than classes list length.\n\n\n\nthresholds : list[float]\n\nList of threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated thresholds list.\n\n\n\n\n\n\n: ValueError\n\nIf thresholds length is not one less than classes length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "SviModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html",
    "href": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "database_builder.RiskInfographicModel()\nModel for risk-based infographic configuration.\n\n\n\nhomes : HomesInfographicModel\n\nHomes infographic configuration.\n\nflood_exceedances : FloodExceedanceModel\n\nFlood exceedance configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for risk infographics.\n\n\n\n\n\ndatabase_builder.RiskInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for risk infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification.\n\n\n\n\n\n\n : RiskInfographicModel\n\nPre-configured risk infographic model.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RiskInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html#attributes",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "homes : HomesInfographicModel\n\nHomes infographic configuration.\n\nflood_exceedances : FloodExceedanceModel\n\nFlood exceedance configuration.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RiskInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/RiskInfographicModel.html#methods",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for risk infographics.\n\n\n\n\n\ndatabase_builder.RiskInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for risk infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification.\n\n\n\n\n\n\n : RiskInfographicModel\n\nPre-configured risk infographic model.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RiskInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html",
    "href": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "database_builder.ImpactCategoriesModel()\nModel for defining impact categories with associated colors, field, unit, and bins.\n\n\n\ncategories : list[str], default=[\"Minor\", \"Major\", \"Severe\"]\n\nList of impact category names.\n\ncolors : list[str], default=[\"#ffa500\", \"#ff0000\", \"#000000\"]\n\nList of colors corresponding to each category.\n\nfield : str\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nbins : list[float]\n\nList of threshold values for binning the field values.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nvalidate_bins_length\nValidate that bins list length is one less than categories list length.\n\n\nvalidate_colors_length\nValidate that colors list length matches categories list length.\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_bins_length(bins, info)\nValidate that bins list length is one less than categories list length.\n\n\n\nbins : list[float]\n\nList of bin threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated bins list.\n\n\n\n\n\n\n: ValueError\n\nIf bins length is not one less than categories length.\n\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_colors_length(colors, info)\nValidate that colors list length matches categories list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match categories length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "ImpactCategoriesModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html#attributes",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "categories : list[str], default=[\"Minor\", \"Major\", \"Severe\"]\n\nList of impact category names.\n\ncolors : list[str], default=[\"#ffa500\", \"#ff0000\", \"#000000\"]\n\nList of colors corresponding to each category.\n\nfield : str\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nbins : list[float]\n\nList of threshold values for binning the field values.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "ImpactCategoriesModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/ImpactCategoriesModel.html#methods",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nvalidate_bins_length\nValidate that bins list length is one less than categories list length.\n\n\nvalidate_colors_length\nValidate that colors list length matches categories list length.\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_bins_length(bins, info)\nValidate that bins list length is one less than categories list length.\n\n\n\nbins : list[float]\n\nList of bin threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated bins list.\n\n\n\n\n\n\n: ValueError\n\nIf bins length is not one less than categories length.\n\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_colors_length(colors, info)\nValidate that colors list length matches categories list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match categories length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "ImpactCategoriesModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/FloodExceedanceModel.html",
    "href": "3_api_docs/api_ref/database_builder/FloodExceedanceModel.html",
    "title": "FloodExceedanceModel",
    "section": "",
    "text": "database_builder.FloodExceedanceModel()\nModel for flood exceedance probability configuration.\n\n\n\ncolumn : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database column name for flood depth measurements.\n\nthreshold : float, default=0.1\n\nThe flood depth threshold value.\n\nunit : str, default=\"meters\"\n\nThe unit of measurement for the threshold.\n\nperiod : int, default=30\n\nThe time period in years for exceedance analysis.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "FloodExceedanceModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/FloodExceedanceModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/FloodExceedanceModel.html#attributes",
    "title": "FloodExceedanceModel",
    "section": "",
    "text": "column : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database column name for flood depth measurements.\n\nthreshold : float, default=0.1\n\nThe flood depth threshold value.\n\nunit : str, default=\"meters\"\n\nThe unit of measurement for the threshold.\n\nperiod : int, default=30\n\nThe time period in years for exceedance analysis.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "FloodExceedanceModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/EventInfographicModel.html",
    "href": "3_api_docs/api_ref/database_builder/EventInfographicModel.html",
    "title": "EventInfographicModel",
    "section": "",
    "text": "database_builder.EventInfographicModel()\nModel for event-based infographic configuration.\n\n\n\nbuildings : BuildingsInfographicModel | None, default=None\n\nBuildings infographic configuration.\n\nsvi : SviInfographicModel | None, default=None\n\nSVI infographic configuration.\n\nroads : RoadsInfographicModel | None, default=None\n\nRoads infographic configuration.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "EventInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/EventInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/EventInfographicModel.html#attributes",
    "title": "EventInfographicModel",
    "section": "",
    "text": "buildings : BuildingsInfographicModel | None, default=None\n\nBuildings infographic configuration.\n\nsvi : SviInfographicModel | None, default=None\n\nSVI infographic configuration.\n\nroads : RoadsInfographicModel | None, default=None\n\nRoads infographic configuration.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "EventInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/create_database.html",
    "href": "3_api_docs/api_ref/create_database.html",
    "title": "create_database",
    "section": "",
    "text": "database_builder.create_database(\n    config: Union[str, Path, ConfigModel],\n    overwrite,\n)\nCreate a new database from a configuration file or ConfigModel.\n\n\n\nconfig : str, Path, or ConfigModel\n\nThe path to the configuration file (as a string or Path) or a ConfigModel instance.\n\noverwrite : bool = False\n\nWhether to overwrite the existing database if it exists.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "create_database"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/create_database.html#parameters",
    "href": "3_api_docs/api_ref/create_database.html#parameters",
    "title": "create_database",
    "section": "",
    "text": "config : str, Path, or ConfigModel\n\nThe path to the configuration file (as a string or Path) or a ConfigModel instance.\n\noverwrite : bool = False\n\nWhether to overwrite the existing database if it exists.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "create_database"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/VisualizationLayers.html",
    "href": "3_api_docs/api_ref/config/VisualizationLayers.html",
    "title": "VisualizationLayers",
    "section": "",
    "text": "config.VisualizationLayers()\nThe configuration of the layers you might want to visualize in the gui.\n\n\n\nbuildings_min_zoom_level : int\n\nThe minimum zoom level before building footprints become visible in the map.\n\ntopography_cmin : float\n\nDefault minimum for DEM color scaling.\n\ntopography_cmax : float\n\nDefault maximum for DEM color scaling.\n\nlayers : list[VisualizationLayer]\n\nThe extra layers to visualize.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "VisualizationLayers"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/VisualizationLayers.html#attributes",
    "href": "3_api_docs/api_ref/config/VisualizationLayers.html#attributes",
    "title": "VisualizationLayers",
    "section": "",
    "text": "buildings_min_zoom_level : int\n\nThe minimum zoom level before building footprints become visible in the map.\n\ntopography_cmin : float\n\nDefault minimum for DEM color scaling.\n\ntopography_cmax : float\n\nDefault maximum for DEM color scaling.\n\nlayers : list[VisualizationLayer]\n\nThe extra layers to visualize.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "VisualizationLayers"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SyntheticTideModel.html",
    "href": "3_api_docs/api_ref/config/SyntheticTideModel.html",
    "title": "SyntheticTideModel",
    "section": "",
    "text": "config.SyntheticTideModel()\nConfiguration for the synthetic tide.\n\n\n\nharmonic_amplitude : us.UnitfulLength\n\nThe amplitude of the tide harmonic relative to the datum.\n\ndatum : str\n\nThe datum to which the harmonic amplitude is relative. Should be a datum defined in site.sfincs.waterlevels.datums",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "SyntheticTideModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SyntheticTideModel.html#attributes",
    "href": "3_api_docs/api_ref/config/SyntheticTideModel.html#attributes",
    "title": "SyntheticTideModel",
    "section": "",
    "text": "harmonic_amplitude : us.UnitfulLength\n\nThe amplitude of the tide harmonic relative to the datum.\n\ndatum : str\n\nThe datum to which the harmonic amplitude is relative. Should be a datum defined in site.sfincs.waterlevels.datums",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "SyntheticTideModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SlrScenariosModel.html",
    "href": "3_api_docs/api_ref/config/SlrScenariosModel.html",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "config.SlrScenariosModel()\nThe accepted input for the variable slr_scenarios.\n\n\n\nfile : str\n\nThe path to the sea level rise scenarios file.\n\nrelative_to_year : int\n\nThe year to which the sea level rise scenarios are relative.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\n\n\n\nconfig.SlrScenariosModel.interp_slr(\n    scenario: str,\n    year: float,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nscenario : str\n\nSLR scenario name to use from the column names in self.file\n\nyear : float\n\nyear to evaluate\n\nunits : us.UnitTypesLength = = us.UnitTypesLength.meters\n\nThe units to convert the SLR value to. Default is meters.\n\n\n\n\n\n\n : float\n\nThe interpolated sea level rise value in the specified units, relative to the reference year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nconfig.SlrScenariosModel.plot_slr_scenarios(\n    scenario_names: list[str],\n    output_loc: Path,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "SlrScenariosModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SlrScenariosModel.html#attributes",
    "href": "3_api_docs/api_ref/config/SlrScenariosModel.html#attributes",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "file : str\n\nThe path to the sea level rise scenarios file.\n\nrelative_to_year : int\n\nThe year to which the sea level rise scenarios are relative.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "SlrScenariosModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SlrScenariosModel.html#methods",
    "href": "3_api_docs/api_ref/config/SlrScenariosModel.html#methods",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\n\n\n\nconfig.SlrScenariosModel.interp_slr(\n    scenario: str,\n    year: float,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nscenario : str\n\nSLR scenario name to use from the column names in self.file\n\nyear : float\n\nyear to evaluate\n\nunits : us.UnitTypesLength = = us.UnitTypesLength.meters\n\nThe units to convert the SLR value to. Default is meters.\n\n\n\n\n\n\n : float\n\nThe interpolated sea level rise value in the specified units, relative to the reference year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nconfig.SlrScenariosModel.plot_slr_scenarios(\n    scenario_names: list[str],\n    output_loc: Path,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "SlrScenariosModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SfincsConfigModel.html",
    "href": "3_api_docs/api_ref/config/SfincsConfigModel.html",
    "title": "SfincsConfigModel",
    "section": "",
    "text": "config.SfincsConfigModel()\nThe expected variables and data types of attributes of the SfincsConfig class.\n\n\n\ncsname : str\n\nThe name of the CS model.\n\ncstype : Cstype\n\nCstype of the CS model. must be either ‚Äúprojected‚Äù or ‚Äúspherical‚Äù.\n\nversion : Optional[str], default = None\n\nThe version of the CS model. If None, the version is not specified.\n\noffshore_model : Optional[FloodModel], default = None\n\nThe offshore model. If None, the offshore model is not specified.\n\noverland_model : FloodModel\n\nThe overland model. This is the main model used for the simulation.\n\nfloodmap_units : us.UnitTypesLength\n\nThe units used for the output floodmap. Sfincs always produces in metric units, this is used to convert the floodmap to the correct units.\n\nsave_simulation : Optional[bool], default = False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Sfincs",
      "SfincsConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SfincsConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/config/SfincsConfigModel.html#attributes",
    "title": "SfincsConfigModel",
    "section": "",
    "text": "csname : str\n\nThe name of the CS model.\n\ncstype : Cstype\n\nCstype of the CS model. must be either ‚Äúprojected‚Äù or ‚Äúspherical‚Äù.\n\nversion : Optional[str], default = None\n\nThe version of the CS model. If None, the version is not specified.\n\noffshore_model : Optional[FloodModel], default = None\n\nThe offshore model. If None, the offshore model is not specified.\n\noverland_model : FloodModel\n\nThe overland model. This is the main model used for the simulation.\n\nfloodmap_units : us.UnitTypesLength\n\nThe units used for the output floodmap. Sfincs always produces in metric units, this is used to convert the floodmap to the correct units.\n\nsave_simulation : Optional[bool], default = False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Sfincs",
      "SfincsConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SCSModel.html",
    "href": "3_api_docs/api_ref/config/SCSModel.html",
    "title": "SCSModel",
    "section": "",
    "text": "config.SCSModel()\nClass describing the accepted input for the variable scs.\nIncludes the file with the non-dimensional SCS rainfall curves in the site folder and the SCS rainfall curve type.\n\n\n\nfile : str\n\nThe path to the SCS rainfall curves file.\n\ntype : Scstype\n\nThe type of the SCS rainfall curve.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "SCSModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SCSModel.html#attributes",
    "href": "3_api_docs/api_ref/config/SCSModel.html#attributes",
    "title": "SCSModel",
    "section": "",
    "text": "file : str\n\nThe path to the SCS rainfall curves file.\n\ntype : Scstype\n\nThe type of the SCS rainfall curve.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "SCSModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/RiskModel.html",
    "href": "3_api_docs/api_ref/config/RiskModel.html",
    "title": "RiskModel",
    "section": "",
    "text": "config.RiskModel()\nThe accepted input for the variable risk in Site.\n\n\n\nreturn_periods : list[int]\n\nThe return periods for the risk model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "RiskModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/RiskModel.html#attributes",
    "href": "3_api_docs/api_ref/config/RiskModel.html#attributes",
    "title": "RiskModel",
    "section": "",
    "text": "return_periods : list[int]\n\nThe return periods for the risk model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "RiskModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/OutputLayers.html",
    "href": "3_api_docs/api_ref/config/OutputLayers.html",
    "title": "OutputLayers",
    "section": "",
    "text": "config.OutputLayers()\nThe configuration of the mapbox layers in the gui.\n\n\n\nfloodmap : FloodMapLayer\n\nThe configuration of the floodmap layer.\n\naggregation_dmg : AggregationDmgLayer\n\nThe configuration of the aggregation damage layer.\n\nfootprints_dmg : FootprintsDmgLayer\n\nThe configuration of the footprints damage layer.\n\nbenefits : BenefitsLayer\n\nThe configuration of the benefits layer.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "OutputLayers"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/OutputLayers.html#attributes",
    "href": "3_api_docs/api_ref/config/OutputLayers.html#attributes",
    "title": "OutputLayers",
    "section": "",
    "text": "floodmap : FloodMapLayer\n\nThe configuration of the floodmap layer.\n\naggregation_dmg : AggregationDmgLayer\n\nThe configuration of the aggregation damage layer.\n\nfootprints_dmg : FootprintsDmgLayer\n\nThe configuration of the footprints damage layer.\n\nbenefits : BenefitsLayer\n\nThe configuration of the benefits layer.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "OutputLayers"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/NoFootprintsModel.html",
    "href": "3_api_docs/api_ref/config/NoFootprintsModel.html",
    "title": "NoFootprintsModel",
    "section": "",
    "text": "config.NoFootprintsModel()\nThe configuration on the how to show objects with no footprints.\n\n\n\nshape : Optional[str], default=\"triangle\"\n\nThe shape of the object with no footprints.\n\ndiameter_meters : Optional[float], default=10\n\nThe diameter of the object with no footprints in meters.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "NoFootprintsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/NoFootprintsModel.html#attributes",
    "href": "3_api_docs/api_ref/config/NoFootprintsModel.html#attributes",
    "title": "NoFootprintsModel",
    "section": "",
    "text": "shape : Optional[str], default=\"triangle\"\n\nThe shape of the object with no footprints.\n\ndiameter_meters : Optional[float], default=10\n\nThe diameter of the object with no footprints in meters.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "NoFootprintsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/GuiModel.html",
    "href": "3_api_docs/api_ref/config/GuiModel.html",
    "title": "GuiModel",
    "section": "",
    "text": "config.GuiModel()\nThe accepted input for the variable gui in Site.\n\n\n\nunits : GuiUnitModel\n\nThe unit system used in the GUI.\n\noutput_layers : OutputLayers\n\nThe configuration of the mapbox layers in the GUI.\n\nvisualization_layers : VisualizationLayers\n\nThe configuration of the visualization layers in the GUI.\n\nplotting : PlottingModel\n\nThe configuration for creating hazard forcing plots.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "GuiModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/GuiModel.html#attributes",
    "href": "3_api_docs/api_ref/config/GuiModel.html#attributes",
    "title": "GuiModel",
    "section": "",
    "text": "units : GuiUnitModel\n\nThe unit system used in the GUI.\n\noutput_layers : OutputLayers\n\nThe configuration of the mapbox layers in the GUI.\n\nvisualization_layers : VisualizationLayers\n\nThe configuration of the visualization layers in the GUI.\n\nplotting : PlottingModel\n\nThe configuration for creating hazard forcing plots.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "GuiModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FloodmapType.html",
    "href": "3_api_docs/api_ref/config/FloodmapType.html",
    "title": "FloodmapType",
    "section": "",
    "text": "FloodmapType\nconfig.FloodmapType()\nThe accepted input for the variable floodmap in Site.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "FloodmapType"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FloodMapLayer.html",
    "href": "3_api_docs/api_ref/config/FloodMapLayer.html",
    "title": "FloodMapLayer",
    "section": "",
    "text": "FloodMapLayer\nconfig.FloodMapLayer()\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "FloodMapLayer"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FiatModel.html",
    "href": "3_api_docs/api_ref/config/FiatModel.html",
    "title": "FiatModel",
    "section": "",
    "text": "config.FiatModel()\nThe expected variables and data types of attributes of the Fiat class.\n\n\n\nrisk : Optional[RiskModel]\n\nConfiguration of probabilistic risk runs. default=None\n\nconfig : FiatConfigModel\n\nConfiguration for the FIAT model.\n\nbenefits : Optional[BenefitsModel]\n\nConfiguration for running benefit calculations. default=None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Fiat",
      "FiatModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FiatModel.html#attributes",
    "href": "3_api_docs/api_ref/config/FiatModel.html#attributes",
    "title": "FiatModel",
    "section": "",
    "text": "risk : Optional[RiskModel]\n\nConfiguration of probabilistic risk runs. default=None\n\nconfig : FiatConfigModel\n\nConfiguration for the FIAT model.\n\nbenefits : Optional[BenefitsModel]\n\nConfiguration for running benefit calculations. default=None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Fiat",
      "FiatModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/EquityModel.html",
    "href": "3_api_docs/api_ref/config/EquityModel.html",
    "title": "EquityModel",
    "section": "",
    "text": "config.EquityModel()\nThe accepted input for the variable equity in Site.\n\n\n\ncensus_data : str\n\nTODO\n\npercapitaincome_label : Optional[str], default=\"PerCapitaIncome\"\n\nTODO\n\ntotalpopulation_label : Optional[str], default=\"TotalPopulation\"\n\nTODO",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "EquityModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/EquityModel.html#attributes",
    "href": "3_api_docs/api_ref/config/EquityModel.html#attributes",
    "title": "EquityModel",
    "section": "",
    "text": "census_data : str\n\nTODO\n\npercapitaincome_label : Optional[str], default=\"PerCapitaIncome\"\n\nTODO\n\ntotalpopulation_label : Optional[str], default=\"TotalPopulation\"\n\nTODO",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "EquityModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/DatumModel.html",
    "href": "3_api_docs/api_ref/config/DatumModel.html",
    "title": "DatumModel",
    "section": "",
    "text": "config.DatumModel()\nThe accepted input for the variable datums in WaterlevelReferenceModel.\n\n\n\nname : str\n\nThe name of the vertical reference model.\n\nheight : us.UnitfulLength\n\nThe height of the vertical reference model relative to the main reference.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "DatumModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/DatumModel.html#attributes",
    "href": "3_api_docs/api_ref/config/DatumModel.html#attributes",
    "title": "DatumModel",
    "section": "",
    "text": "name : str\n\nThe name of the vertical reference model.\n\nheight : us.UnitfulLength\n\nThe height of the vertical reference model relative to the main reference.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "DatumModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/Cstype.html",
    "href": "3_api_docs/api_ref/config/Cstype.html",
    "title": "Cstype",
    "section": "",
    "text": "Cstype\nconfig.Cstype()\nThe accepted input for the variable cstype in Site.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "Cstype"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/BenefitsLayer.html",
    "href": "3_api_docs/api_ref/config/BenefitsLayer.html",
    "title": "BenefitsLayer",
    "section": "",
    "text": "BenefitsLayer\nconfig.BenefitsLayer()\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "BenefitsLayer"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/AggregationDmgLayer.html",
    "href": "3_api_docs/api_ref/config/AggregationDmgLayer.html",
    "title": "AggregationDmgLayer",
    "section": "",
    "text": "AggregationDmgLayer\nconfig.AggregationDmgLayer()\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "AggregationDmgLayer"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/WaterlevelReferenceModel.html",
    "href": "3_api_docs/api_ref/WaterlevelReferenceModel.html",
    "title": "WaterlevelReferenceModel",
    "section": "",
    "text": "config.WaterlevelReferenceModel()\nThe accepted input for the variable water_level in Site.\nWaterlevels timeseries are calculated from user input, assumed to be relative to the reference vertical reference model.\nFor plotting in the GUI, the reference vertical reference model is used as the main zero-reference, all values are relative to this. All other vertical reference models are plotted as dashed lines.\n\n\n\nreference : str\n\nThe name of the vertical reference model that is used as the main zero-reference.\n\ndatums : list[DatumModel]\n\nThe vertical reference models that are used to calculate the waterlevels timeseries. The datums are used to calculate the waterlevels timeseries, which are relative to the reference vertical reference model."
  },
  {
    "objectID": "3_api_docs/api_ref/WaterlevelReferenceModel.html#attributes",
    "href": "3_api_docs/api_ref/WaterlevelReferenceModel.html#attributes",
    "title": "WaterlevelReferenceModel",
    "section": "",
    "text": "reference : str\n\nThe name of the vertical reference model that is used as the main zero-reference.\n\ndatums : list[DatumModel]\n\nThe vertical reference models that are used to calculate the waterlevels timeseries. The datums are used to calculate the waterlevels timeseries, which are relative to the reference vertical reference model."
  },
  {
    "objectID": "3_api_docs/api_ref/VisualizationLayer.html",
    "href": "3_api_docs/api_ref/VisualizationLayer.html",
    "title": "VisualizationLayer",
    "section": "",
    "text": "VisualizationLayer\nconfig.VisualizationLayer()\nThe configuration of a layer to visualize in the gui.\nname : str The name of the layer to visualize. long_name : str The long name of the layer to visualize. path : str The path to the layer data to visualize. field_name : str The field names of the layer to visualize. decimals : Optional[int] The number of decimals to use for the layer to visualize. default is None.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/ValueUnitPair.html",
    "href": "3_api_docs/api_ref/ValueUnitPair.html",
    "title": "ValueUnitPair",
    "section": "",
    "text": "unit_system.ValueUnitPair()\nRepresents a value with associated units.\n\n\n\nvalue : float\n\nThe numerical value.\n\nunits : Unit\n\nThe units of the value.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert\nReturn the value converted to the new units.\n\n\ntransform\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\n\n\nunit_system.ValueUnitPair.convert(new_units: TUnit)\nReturn the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nconverted_value : float\n\nThe converted value.\n\n\n\n\n\n\nunit_system.ValueUnitPair.transform(new_units: TUnit)\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nvalue_unit_pair : ValueUnitPair\n\nThe new ValueUnitPair instance with the value converted to the new units and the new units.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/ValueUnitPair.html#attributes",
    "href": "3_api_docs/api_ref/ValueUnitPair.html#attributes",
    "title": "ValueUnitPair",
    "section": "",
    "text": "value : float\n\nThe numerical value.\n\nunits : Unit\n\nThe units of the value.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/ValueUnitPair.html#methods",
    "href": "3_api_docs/api_ref/ValueUnitPair.html#methods",
    "title": "ValueUnitPair",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconvert\nReturn the value converted to the new units.\n\n\ntransform\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\n\n\nunit_system.ValueUnitPair.convert(new_units: TUnit)\nReturn the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nconverted_value : float\n\nThe converted value.\n\n\n\n\n\n\nunit_system.ValueUnitPair.transform(new_units: TUnit)\nReturn a new ValueUnitPair instance with the value converted to the new units.\n\n\n\nnew_units : Unit\n\nThe new units.\n\n\n\n\n\n\nvalue_unit_pair : ValueUnitPair\n\nThe new ValueUnitPair instance with the value converted to the new units and the new units.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "ValueUnitPair"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulVelocity.html",
    "href": "3_api_docs/api_ref/UnitfulVelocity.html",
    "title": "UnitfulVelocity",
    "section": "",
    "text": "unit_system.UnitfulVelocity()\nCombination of velocity and unit.\n\n\n\nvalue : float\n\nThe velocity value, must be greater than or equal to 0.\n\nunits : UnitTypesVelocity\n\nThe unit of velocity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVelocity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulVelocity.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulVelocity.html#attributes",
    "title": "UnitfulVelocity",
    "section": "",
    "text": "value : float\n\nThe velocity value, must be greater than or equal to 0.\n\nunits : UnitTypesVelocity\n\nThe unit of velocity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVelocity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulLengthRefValue.html",
    "href": "3_api_docs/api_ref/UnitfulLengthRefValue.html",
    "title": "UnitfulLengthRefValue",
    "section": "",
    "text": "unit_system.UnitfulLengthRefValue()\nCombination of length and unit with a reference value.\n\n\n\nvalue : float\n\nThe length value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of length.\n\ntype : VerticalReference\n\nThe vertical reference for the length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLengthRefValue"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulLengthRefValue.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulLengthRefValue.html#attributes",
    "title": "UnitfulLengthRefValue",
    "section": "",
    "text": "value : float\n\nThe length value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of length.\n\ntype : VerticalReference\n\nThe vertical reference for the length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLengthRefValue"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulIntensity.html",
    "href": "3_api_docs/api_ref/UnitfulIntensity.html",
    "title": "UnitfulIntensity",
    "section": "",
    "text": "unit_system.UnitfulIntensity()\nCombination of intensity and unit.\n\n\n\nvalue : float\n\nThe intensity value, must be greater than or equal to 0.\n\nunits : UnitTypesIntensity\n\nThe unit of intensity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulIntensity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulIntensity.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulIntensity.html#attributes",
    "title": "UnitfulIntensity",
    "section": "",
    "text": "value : float\n\nThe intensity value, must be greater than or equal to 0.\n\nunits : UnitTypesIntensity\n\nThe unit of intensity.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulIntensity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulDischarge.html",
    "href": "3_api_docs/api_ref/UnitfulDischarge.html",
    "title": "UnitfulDischarge",
    "section": "",
    "text": "unit_system.UnitfulDischarge()\nCombination of discharge and unit.\n\n\n\nvalue : float\n\nThe discharge value, must be greater than or equal to 0.\n\nunits : UnitTypesDischarge\n\nThe unit of discharge.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDischarge"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulDischarge.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulDischarge.html#attributes",
    "title": "UnitfulDischarge",
    "section": "",
    "text": "value : float\n\nThe discharge value, must be greater than or equal to 0.\n\nunits : UnitTypesDischarge\n\nThe unit of discharge.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDischarge"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulArea.html",
    "href": "3_api_docs/api_ref/UnitfulArea.html",
    "title": "UnitfulArea",
    "section": "",
    "text": "unit_system.UnitfulArea()\nCombination of area and unit.\n\n\n\nvalue : float\n\nThe area value, must be greater than or equal to 0.\n\nunits : UnitTypesArea\n\nThe unit of area.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulArea"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulArea.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulArea.html#attributes",
    "title": "UnitfulArea",
    "section": "",
    "text": "value : float\n\nThe area value, must be greater than or equal to 0.\n\nunits : UnitTypesArea\n\nThe unit of area.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulArea"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesVelocity.html",
    "href": "3_api_docs/api_ref/UnitTypesVelocity.html",
    "title": "UnitTypesVelocity",
    "section": "",
    "text": "unit_system.UnitTypesVelocity()\nUnits of velocity.\n\n\n\nmps : meters per second\n\n\n\nknots : nautical miles per hour\n\n\n\nmph : miles per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVelocity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesVelocity.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesVelocity.html#attributes",
    "title": "UnitTypesVelocity",
    "section": "",
    "text": "mps : meters per second\n\n\n\nknots : nautical miles per hour\n\n\n\nmph : miles per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVelocity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesLength.html",
    "href": "3_api_docs/api_ref/UnitTypesLength.html",
    "title": "UnitTypesLength",
    "section": "",
    "text": "unit_system.UnitTypesLength()\nUnits of length.\n\n\n\nmeters : meters\n\n\n\ncentimeters : centimeters\n\n\n\nmillimeters : millimeters\n\n\n\nfeet : feet\n\n\n\ninch : inch\n\n\n\nmiles : miles",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesLength"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesLength.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesLength.html#attributes",
    "title": "UnitTypesLength",
    "section": "",
    "text": "meters : meters\n\n\n\ncentimeters : centimeters\n\n\n\nmillimeters : millimeters\n\n\n\nfeet : feet\n\n\n\ninch : inch\n\n\n\nmiles : miles",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesLength"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesDischarge.html",
    "href": "3_api_docs/api_ref/UnitTypesDischarge.html",
    "title": "UnitTypesDischarge",
    "section": "",
    "text": "unit_system.UnitTypesDischarge()\nUnits of discharge.\n\n\n\ncfs : cubic feet per second\n\n\n\ncms : cubic meters per second",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDischarge"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesDischarge.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesDischarge.html#attributes",
    "title": "UnitTypesDischarge",
    "section": "",
    "text": "cfs : cubic feet per second\n\n\n\ncms : cubic meters per second",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDischarge"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesArea.html",
    "href": "3_api_docs/api_ref/UnitTypesArea.html",
    "title": "UnitTypesArea",
    "section": "",
    "text": "unit_system.UnitTypesArea()\nUnits of area.\n\n\n\nm2 : square meters\n\n\n\ndm2 : square decimeters\n\n\n\ncm2 : square centimeters\n\n\n\nmm2 : square millimeters\n\n\n\nsf : square feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesArea"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesArea.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesArea.html#attributes",
    "title": "UnitTypesArea",
    "section": "",
    "text": "m2 : square meters\n\n\n\ndm2 : square decimeters\n\n\n\ncm2 : square centimeters\n\n\n\nmm2 : square millimeters\n\n\n\nsf : square feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesArea"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/TypeMapping.html",
    "href": "3_api_docs/api_ref/TypeMapping.html",
    "title": "TypeMapping",
    "section": "",
    "text": "database_builder.TypeMapping()\nContainer for multiple field mappings that define object type filtering.\n\n\n\nmappings : list[FieldMapping]\n\nList of field mappings that together define the type criteria\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_mapping\nAdd a new field mapping.\n\n\nto_sql_filter\nGenerate combined SQL filter string from all mappings.\n\n\n\n\n\ndatabase_builder.TypeMapping.add_mapping(field_name: str, values: list[str])\nAdd a new field mapping.\n\n\n\nfield_name : str\n\nName of the database field.\n\nvalues : list[str]\n\nList of allowed values for this field.\n\n\n\n\n\n\ndatabase_builder.TypeMapping.to_sql_filter()\nGenerate combined SQL filter string from all mappings.\n\n\n\n : str\n\nCombined SQL WHERE clause condition string."
  },
  {
    "objectID": "3_api_docs/api_ref/TypeMapping.html#attributes",
    "href": "3_api_docs/api_ref/TypeMapping.html#attributes",
    "title": "TypeMapping",
    "section": "",
    "text": "mappings : list[FieldMapping]\n\nList of field mappings that together define the type criteria"
  },
  {
    "objectID": "3_api_docs/api_ref/TypeMapping.html#methods",
    "href": "3_api_docs/api_ref/TypeMapping.html#methods",
    "title": "TypeMapping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_mapping\nAdd a new field mapping.\n\n\nto_sql_filter\nGenerate combined SQL filter string from all mappings.\n\n\n\n\n\ndatabase_builder.TypeMapping.add_mapping(field_name: str, values: list[str])\nAdd a new field mapping.\n\n\n\nfield_name : str\n\nName of the database field.\n\nvalues : list[str]\n\nList of allowed values for this field.\n\n\n\n\n\n\ndatabase_builder.TypeMapping.to_sql_filter()\nGenerate combined SQL filter string from all mappings.\n\n\n\n : str\n\nCombined SQL WHERE clause condition string."
  },
  {
    "objectID": "3_api_docs/api_ref/TideGaugeSource.html",
    "href": "3_api_docs/api_ref/TideGaugeSource.html",
    "title": "TideGaugeSource",
    "section": "",
    "text": "TideGaugeSource\ndatabase_builder.TideGaugeSource()\nThe accepted input for the variable source in tide_gauge.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "TideGaugeSource"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Template.html",
    "href": "3_api_docs/api_ref/Template.html",
    "title": "Template",
    "section": "",
    "text": "objects.Template()\nClass describing the accepted input for the variable template in Event.\n\n\n\nSynthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template."
  },
  {
    "objectID": "3_api_docs/api_ref/Template.html#attributes",
    "href": "3_api_docs/api_ref/Template.html#attributes",
    "title": "Template",
    "section": "",
    "text": "Synthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template."
  },
  {
    "objectID": "3_api_docs/api_ref/SyntheticEvent.html",
    "href": "3_api_docs/api_ref/SyntheticEvent.html",
    "title": "SyntheticEvent",
    "section": "",
    "text": "objects.SyntheticEvent()\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "3_api_docs/api_ref/SyntheticEvent.html#attributes",
    "href": "3_api_docs/api_ref/SyntheticEvent.html#attributes",
    "title": "SyntheticEvent",
    "section": "",
    "text": "time : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Synthetic.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "3_api_docs/api_ref/SviConfigModel.html",
    "href": "3_api_docs/api_ref/SviConfigModel.html",
    "title": "SviConfigModel",
    "section": "",
    "text": "database_builder.SviConfigModel()\nModel for Social Vulnerability Index (SVI) spatial join.\nInherits from SpatialJoinModel.\n\n\n\nthreshold : float\n\nThreshold value to specify vulnerability.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "SviConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/SviConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/SviConfigModel.html#attributes",
    "title": "SviConfigModel",
    "section": "",
    "text": "threshold : float\n\nThreshold value to specify vulnerability.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "SviConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Strategy.html",
    "href": "3_api_docs/api_ref/Strategy.html",
    "title": "Strategy",
    "section": "",
    "text": "objects.Strategy()\nClass representing a strategy in FloodAdapt.\nA strategy is a collection of measures that can be applied to a model.\n\n\n\nmeasures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database."
  },
  {
    "objectID": "3_api_docs/api_ref/Strategy.html#attributes",
    "href": "3_api_docs/api_ref/Strategy.html#attributes",
    "title": "Strategy",
    "section": "",
    "text": "measures : list[str]\n\nA list of measures associated with the strategy. Should be a list of measure names that are saved in the database."
  },
  {
    "objectID": "3_api_docs/api_ref/Strategy.html#methods",
    "href": "3_api_docs/api_ref/Strategy.html#methods",
    "title": "Strategy",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_measures\nGet the measures associated with this strategy.\n\n\ninitialize_measure_objects\nInitialize the measure objects associated with this strategy.\n\n\n\n\n\nobjects.Strategy.get_measures()\nGet the measures associated with this strategy.\nNote that this method will return the measure objects, not just their names. The measure objects are initialized using the initialize_measure_objects method.\n\n\n\nmeasures : list[Measure]\n\nThe list of measure objects associated with this strategy.\n\n\n\n\n\n\n: ValueError\n\nIf the measure objects have not been initialized.\n\n\n\n\n\n\nobjects.Strategy.initialize_measure_objects(measures: list[Measure])\nInitialize the measure objects associated with this strategy.\n\n\n\nmeasures : list[Measure]\n\nA list of measure objects to be associated with this strategy. Should be a list of measure objects that are saved in the database."
  },
  {
    "objectID": "3_api_docs/api_ref/SpatialJoinModel.html",
    "href": "3_api_docs/api_ref/SpatialJoinModel.html",
    "title": "SpatialJoinModel",
    "section": "",
    "text": "database_builder.SpatialJoinModel()\nModel for representing a spatial join between geometries and tabular data.\n\n\n\nfile : str\n\nPath to the file containing the spatial data to join.\n\nfield_name : str\n\nName of the field used for joining.\n\nname : Optional[str]\n\nName of the spatial join (optional).\n\nunits : Optional[us.UnitfulLength]\n\nUnit system for the spatial data (optional).",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "SpatialJoinModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/SpatialJoinModel.html#attributes",
    "href": "3_api_docs/api_ref/SpatialJoinModel.html#attributes",
    "title": "SpatialJoinModel",
    "section": "",
    "text": "file : str\n\nPath to the file containing the spatial data to join.\n\nfield_name : str\n\nName of the field used for joining.\n\nname : Optional[str]\n\nName of the spatial join (optional).\n\nunits : Optional[us.UnitfulLength]\n\nUnit system for the spatial data (optional).",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "SpatialJoinModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/SlrScenariosModel.html",
    "href": "3_api_docs/api_ref/SlrScenariosModel.html",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "config.SlrScenariosModel()\nThe accepted input for the variable slr_scenarios.\n\n\n\nfile : str\n\nThe path to the sea level rise scenarios file.\n\nrelative_to_year : int\n\nThe year to which the sea level rise scenarios are relative.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\n\n\n\nconfig.SlrScenariosModel.interp_slr(\n    scenario: str,\n    year: float,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nscenario : str\n\nSLR scenario name to use from the column names in self.file\n\nyear : float\n\nyear to evaluate\n\nunits : us.UnitTypesLength = = us.UnitTypesLength.meters\n\nThe units to convert the SLR value to. Default is meters.\n\n\n\n\n\n\n : float\n\nThe interpolated sea level rise value in the specified units, relative to the reference year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nconfig.SlrScenariosModel.plot_slr_scenarios(\n    scenario_names: list[str],\n    output_loc: Path,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios."
  },
  {
    "objectID": "3_api_docs/api_ref/SlrScenariosModel.html#attributes",
    "href": "3_api_docs/api_ref/SlrScenariosModel.html#attributes",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "file : str\n\nThe path to the sea level rise scenarios file.\n\nrelative_to_year : int\n\nThe year to which the sea level rise scenarios are relative."
  },
  {
    "objectID": "3_api_docs/api_ref/SlrScenariosModel.html#methods",
    "href": "3_api_docs/api_ref/SlrScenariosModel.html#methods",
    "title": "SlrScenariosModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\n\n\n\nconfig.SlrScenariosModel.interp_slr(\n    scenario: str,\n    year: float,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nscenario : str\n\nSLR scenario name to use from the column names in self.file\n\nyear : float\n\nyear to evaluate\n\nunits : us.UnitTypesLength = = us.UnitTypesLength.meters\n\nThe units to convert the SLR value to. Default is meters.\n\n\n\n\n\n\n : float\n\nThe interpolated sea level rise value in the specified units, relative to the reference year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nconfig.SlrScenariosModel.plot_slr_scenarios(\n    scenario_names: list[str],\n    output_loc: Path,\n    units: us.UnitTypesLength = us.UnitTypesLength.meters,\n)\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios."
  },
  {
    "objectID": "3_api_docs/api_ref/SfincsModel.html",
    "href": "3_api_docs/api_ref/SfincsModel.html",
    "title": "SfincsModel",
    "section": "",
    "text": "config.SfincsModel()\nThe expected variables and data types of attributes of the Sfincs class.\n\n\n\nconfig : SfincsConfigModel\n\nThe configuration of the Sfincs model.\n\nwater_level : WaterlevelReferenceModel\n\nThe collection of all datums and the main reference datum.\n\ndem : DemModel\n\nThe digital elevation model.\n\nflood_frequency : FloodFrequencyModel, default = FloodFrequencyModel()\n\nThe flood frequency model.\n\nslr : SlrScenariosModel\n\nSpecification of the sea level rise scenarios.\n\ncyclone_track_database : CycloneTrackDatabaseModel, optional, default = None\n\nThe cyclone track database model.\n\nscs : SCSModel, optional, default = None\n\nThe SCS model.\n\ntide_gauge : TideGauge, optional, default = None\n\nThe tide gauge model.\n\nriver : list[RiverModel], optional, default = None\n\nThe river model.\n\nobs_point : list[ObsPointModel], optional, default = None\n\nThe observation point model."
  },
  {
    "objectID": "3_api_docs/api_ref/SfincsModel.html#attributes",
    "href": "3_api_docs/api_ref/SfincsModel.html#attributes",
    "title": "SfincsModel",
    "section": "",
    "text": "config : SfincsConfigModel\n\nThe configuration of the Sfincs model.\n\nwater_level : WaterlevelReferenceModel\n\nThe collection of all datums and the main reference datum.\n\ndem : DemModel\n\nThe digital elevation model.\n\nflood_frequency : FloodFrequencyModel, default = FloodFrequencyModel()\n\nThe flood frequency model.\n\nslr : SlrScenariosModel\n\nSpecification of the sea level rise scenarios.\n\ncyclone_track_database : CycloneTrackDatabaseModel, optional, default = None\n\nThe cyclone track database model.\n\nscs : SCSModel, optional, default = None\n\nThe SCS model.\n\ntide_gauge : TideGauge, optional, default = None\n\nThe tide gauge model.\n\nriver : list[RiverModel], optional, default = None\n\nThe river model.\n\nobs_point : list[ObsPointModel], optional, default = None\n\nThe observation point model."
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html",
    "href": "3_api_docs/api_ref/Settings.html",
    "title": "Settings",
    "section": "",
    "text": "Settings()\nThe configuration settings for the FloodAdapt database and integrator.\nPrecedence is as follows: user arguments &gt; environment variables &gt; defaults in this class. When loading is done, the settings are validated and the environment variables are updated with the loaded values.\nIf any required settings are missing or invalid, a ValidationError is raised.\n\n\nfrom flood_adapt import Settings\nOne of the following:\n\nLoad settings from environment variables, if no environment variables are set, use defaults defined in the class: settings = Settings()\nLoad settings from a .toml file, overwriting any environment variables set: settings = Settings.read(toml_path: Path)\nLoad settings from keyword arguments, overwriting any environment variables: settings = Settings(DATABASE_ROOT=\"path/to/database\", DATABASE_NAME=\"database_name\")\n\n\n\n\n\ndatabase_name : (str | None, default is None)\n\nThe name of the database. Alias: DATABASE_NAME (environment variable).\n\ndatabase_root : (Path | None, default is None)\n\nThe root directory of the database. Alias: DATABASE_ROOT (environment variable).\n\ndelete_crashed_runs : (bool, default is False)\n\nWhether to delete crashed/corrupted runs immediately after they are detected. Alias: DELETE_CRASHED_RUNS (environment variable).\n\nvalidate_allowed_forcings : (bool, default is False)\n\nWhether to validate the forcing types and sources against the allowed forcings in the event model. Alias: VALIDATE_ALLOWED_FORCINGS (environment variable).\n\nuse_binaries : (bool, default is False)\n\nWhether to validate the existence of the paths to the SFINCS and FIAT binaries. Alias: USE_BINARIES (environment variable).\n\nsfincs_bin_path : (Path | None, default is None)\n\nThe path to the SFINCS binary. Alias: SFINCS_BIN_PATH (environment variable).\n\nsfincs_version : str, default is '2.2.1-alpha col d'Eze'\n\nThe expected version of the SFINCS binary. Alias: SFINCS_VERSION (environment variable).\n\nfiat_bin_path : (Path | None, default is None)\n\nThe path to the FIAT binary. Alias: FIAT_BIN_PATH (environment variable).\n\nfiat_version : (str, default is '0.2.1')\n\nThe expected version of the FIAT binary. Alias: FIAT_VERSION (environment variable).\n\n\n\n\n\ndatabase_path : Path The full path to the database.\n\n\n\n\n: ValidationError\n\nIf required settings are missing or invalid.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_binary_versions\nCheck that the versions of the binaries in the config match those expected.\n\n\nexport_to_env\nExport all settings to environment variables using the aliases as keys.\n\n\nget_fiat_version\nGet the version of the FIAT binary.\n\n\nget_sfincs_version\nGet the version of the SFINCS binary.\n\n\nread\nParse the configuration file and return the parsed settings.\n\n\nwrite\nWrite the configuration settings to a .toml file.\n\n\n\n\n\nSettings.check_binary_versions()\nCheck that the versions of the binaries in the config match those expected.\n\n\n\nSettings.export_to_env()\nExport all settings to environment variables using the aliases as keys.\n\n\n\nSettings.get_fiat_version()\nGet the version of the FIAT binary.\n\n\n\n : str\n\nThe version of the FIAT binary\n\n\n\n\n\nFIAT 0.2.1, build 2025-02-24T16:19:19 UTC+0100 ‚Ä¶\n\n\n\n\nSettings.get_sfincs_version()\nGet the version of the SFINCS binary.\n\n\n\n : str\n\nThe version of the SFINCS binary\n\n\n\n\n\n‚Äî‚Äî‚Äî‚Äî Welcome to SFINCS ‚Äî‚Äî‚Äî‚Äî\nLOGO\n\nBuild-Revision: $Rev: v2.2.1-alpha col d‚ÄôEze Build-Date: $Date: 2025-06-02\n‚Äî‚Äî Preparing model simulation ‚Äî‚Äî‚Äì ‚Ä¶\n\n\n\n\nSettings.read(toml_path: Path)\nParse the configuration file and return the parsed settings.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : Settings\n\nThe parsed configuration settings.\n\n\n\n\n\n\n: ValidationError\n\nIf required configuration values are missing or if there is an error parsing the configuration file.\n\n\n\n\n\n\nSettings.write(toml_path: Path)\nWrite the configuration settings to a .toml file.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html#usage",
    "href": "3_api_docs/api_ref/Settings.html#usage",
    "title": "Settings",
    "section": "",
    "text": "from flood_adapt import Settings\nOne of the following:\n\nLoad settings from environment variables, if no environment variables are set, use defaults defined in the class: settings = Settings()\nLoad settings from a .toml file, overwriting any environment variables set: settings = Settings.read(toml_path: Path)\nLoad settings from keyword arguments, overwriting any environment variables: settings = Settings(DATABASE_ROOT=\"path/to/database\", DATABASE_NAME=\"database_name\")",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html#attributes",
    "href": "3_api_docs/api_ref/Settings.html#attributes",
    "title": "Settings",
    "section": "",
    "text": "database_name : (str | None, default is None)\n\nThe name of the database. Alias: DATABASE_NAME (environment variable).\n\ndatabase_root : (Path | None, default is None)\n\nThe root directory of the database. Alias: DATABASE_ROOT (environment variable).\n\ndelete_crashed_runs : (bool, default is False)\n\nWhether to delete crashed/corrupted runs immediately after they are detected. Alias: DELETE_CRASHED_RUNS (environment variable).\n\nvalidate_allowed_forcings : (bool, default is False)\n\nWhether to validate the forcing types and sources against the allowed forcings in the event model. Alias: VALIDATE_ALLOWED_FORCINGS (environment variable).\n\nuse_binaries : (bool, default is False)\n\nWhether to validate the existence of the paths to the SFINCS and FIAT binaries. Alias: USE_BINARIES (environment variable).\n\nsfincs_bin_path : (Path | None, default is None)\n\nThe path to the SFINCS binary. Alias: SFINCS_BIN_PATH (environment variable).\n\nsfincs_version : str, default is '2.2.1-alpha col d'Eze'\n\nThe expected version of the SFINCS binary. Alias: SFINCS_VERSION (environment variable).\n\nfiat_bin_path : (Path | None, default is None)\n\nThe path to the FIAT binary. Alias: FIAT_BIN_PATH (environment variable).\n\nfiat_version : (str, default is '0.2.1')\n\nThe expected version of the FIAT binary. Alias: FIAT_VERSION (environment variable).",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html#properties",
    "href": "3_api_docs/api_ref/Settings.html#properties",
    "title": "Settings",
    "section": "",
    "text": "database_path : Path The full path to the database.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html#raises",
    "href": "3_api_docs/api_ref/Settings.html#raises",
    "title": "Settings",
    "section": "",
    "text": ": ValidationError\n\nIf required settings are missing or invalid.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Settings.html#methods",
    "href": "3_api_docs/api_ref/Settings.html#methods",
    "title": "Settings",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_binary_versions\nCheck that the versions of the binaries in the config match those expected.\n\n\nexport_to_env\nExport all settings to environment variables using the aliases as keys.\n\n\nget_fiat_version\nGet the version of the FIAT binary.\n\n\nget_sfincs_version\nGet the version of the SFINCS binary.\n\n\nread\nParse the configuration file and return the parsed settings.\n\n\nwrite\nWrite the configuration settings to a .toml file.\n\n\n\n\n\nSettings.check_binary_versions()\nCheck that the versions of the binaries in the config match those expected.\n\n\n\nSettings.export_to_env()\nExport all settings to environment variables using the aliases as keys.\n\n\n\nSettings.get_fiat_version()\nGet the version of the FIAT binary.\n\n\n\n : str\n\nThe version of the FIAT binary\n\n\n\n\n\nFIAT 0.2.1, build 2025-02-24T16:19:19 UTC+0100 ‚Ä¶\n\n\n\n\nSettings.get_sfincs_version()\nGet the version of the SFINCS binary.\n\n\n\n : str\n\nThe version of the SFINCS binary\n\n\n\n\n\n‚Äî‚Äî‚Äî‚Äî Welcome to SFINCS ‚Äî‚Äî‚Äî‚Äî\nLOGO\n\nBuild-Revision: $Rev: v2.2.1-alpha col d‚ÄôEze Build-Date: $Date: 2025-06-02\n‚Äî‚Äî Preparing model simulation ‚Äî‚Äî‚Äì ‚Ä¶\n\n\n\n\nSettings.read(toml_path: Path)\nParse the configuration file and return the parsed settings.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : Settings\n\nThe parsed configuration settings.\n\n\n\n\n\n\n: ValidationError\n\nIf required configuration values are missing or if there is an error parsing the configuration file.\n\n\n\n\n\n\nSettings.write(toml_path: Path)\nWrite the configuration settings to a .toml file.\n\n\n\ntoml_path : Path\n\nThe path to the configuration file.\n\n\n\n\n\n\n : None",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Settings"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Scstype.html",
    "href": "3_api_docs/api_ref/Scstype.html",
    "title": "Scstype",
    "section": "",
    "text": "Scstype\nconfig.Scstype()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/SCSModel.html",
    "href": "3_api_docs/api_ref/SCSModel.html",
    "title": "SCSModel",
    "section": "",
    "text": "config.SCSModel()\nClass describing the accepted input for the variable scs.\nIncludes the file with the non-dimensional SCS rainfall curves in the site folder and the SCS rainfall curve type.\n\n\n\nfile : str\n\nThe path to the SCS rainfall curves file.\n\ntype : Scstype\n\nThe type of the SCS rainfall curve."
  },
  {
    "objectID": "3_api_docs/api_ref/SCSModel.html#attributes",
    "href": "3_api_docs/api_ref/SCSModel.html#attributes",
    "title": "SCSModel",
    "section": "",
    "text": "file : str\n\nThe path to the SCS rainfall curves file.\n\ntype : Scstype\n\nThe type of the SCS rainfall curve."
  },
  {
    "objectID": "3_api_docs/api_ref/RiverModel.html",
    "href": "3_api_docs/api_ref/RiverModel.html",
    "title": "RiverModel",
    "section": "",
    "text": "config.RiverModel()\nModel that describes the accepted input for the variable river in Site.\n\n\n\nname : str\n\nThe name of the river.\n\ndescription : Optional[str], default=None\n\ndescription of the river.\n\nmean_discharge : us.UnitfulDischarge\n\nThe mean discharge of the river.\n\nx_coordinate : float\n\nThe x coordinate of the river.\n\ny_coordinate : float\n\nThe y coordinate of the river."
  },
  {
    "objectID": "3_api_docs/api_ref/RiverModel.html#attributes",
    "href": "3_api_docs/api_ref/RiverModel.html#attributes",
    "title": "RiverModel",
    "section": "",
    "text": "name : str\n\nThe name of the river.\n\ndescription : Optional[str], default=None\n\ndescription of the river.\n\nmean_discharge : us.UnitfulDischarge\n\nThe mean discharge of the river.\n\nx_coordinate : float\n\nThe x coordinate of the river.\n\ny_coordinate : float\n\nThe y coordinate of the river."
  },
  {
    "objectID": "3_api_docs/api_ref/RiskInfographicModel.html",
    "href": "3_api_docs/api_ref/RiskInfographicModel.html",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "database_builder.RiskInfographicModel()\nModel for risk-based infographic configuration.\n\n\n\nhomes : HomesInfographicModel\n\nHomes infographic configuration.\n\nflood_exceedances : FloodExceedanceModel\n\nFlood exceedance configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for risk infographics.\n\n\n\n\n\ndatabase_builder.RiskInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for risk infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification.\n\n\n\n\n\n\n : RiskInfographicModel\n\nPre-configured risk infographic model."
  },
  {
    "objectID": "3_api_docs/api_ref/RiskInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/RiskInfographicModel.html#attributes",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "homes : HomesInfographicModel\n\nHomes infographic configuration.\n\nflood_exceedances : FloodExceedanceModel\n\nFlood exceedance configuration."
  },
  {
    "objectID": "3_api_docs/api_ref/RiskInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/RiskInfographicModel.html#methods",
    "title": "RiskInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for risk infographics.\n\n\n\n\n\ndatabase_builder.RiskInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for risk infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification.\n\n\n\n\n\n\n : RiskInfographicModel\n\nPre-configured risk infographic model."
  },
  {
    "objectID": "3_api_docs/api_ref/Projection.html",
    "href": "3_api_docs/api_ref/Projection.html",
    "title": "Projection",
    "section": "",
    "text": "objects.Projection()\nThe accepted input for a projection in FloodAdapt.\nA projection is a combination of a physical projection and a socio-economic change.\n\n\n\nname : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers."
  },
  {
    "objectID": "3_api_docs/api_ref/Projection.html#attributes",
    "href": "3_api_docs/api_ref/Projection.html#attributes",
    "title": "Projection",
    "section": "",
    "text": "name : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers."
  },
  {
    "objectID": "3_api_docs/api_ref/PhysicalProjection.html",
    "href": "3_api_docs/api_ref/PhysicalProjection.html",
    "title": "PhysicalProjection",
    "section": "",
    "text": "objects.PhysicalProjection()\nThe accepted input for a physical projection in FloodAdapt.\n\n\n\nsea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0."
  },
  {
    "objectID": "3_api_docs/api_ref/PhysicalProjection.html#attributes",
    "href": "3_api_docs/api_ref/PhysicalProjection.html#attributes",
    "title": "PhysicalProjection",
    "section": "",
    "text": "sea_level_rise : us.UnitfulLength\n\nThe sea level rise in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nsubsidence : us.UnitfulLength\n\nThe subsidence in meters. Default=us.UnitfulLength(0.0, us.UnitTypesLength.meters).\n\nrainfall_multiplier : float\n\nThe rainfall multiplier. Default = 1.0.\n\nstorm_frequency_increase : float\n\nThe storm frequency increase as a percentage. Default = 0.0."
  },
  {
    "objectID": "3_api_docs/api_ref/ObsPointModel.html",
    "href": "3_api_docs/api_ref/ObsPointModel.html",
    "title": "ObsPointModel",
    "section": "",
    "text": "config.ObsPointModel()\nThe accepted input for the variable obs_point in Site.\nobs_points is used to define output locations in the hazard model, which will be plotted in the user interface.\n\n\n\nname : Union[int, AsciiStr]\n\nThe name of the observation point.\n\ndescription : Optional[str], default=\"\"\n\nThe description of the observation point.\n\nID : Optional[int], default=None\n\nThe ID of the observation point.\n\nfile : Optional[str], default=None\n\nThe path to the observation point data file."
  },
  {
    "objectID": "3_api_docs/api_ref/ObsPointModel.html#attributes",
    "href": "3_api_docs/api_ref/ObsPointModel.html#attributes",
    "title": "ObsPointModel",
    "section": "",
    "text": "name : Union[int, AsciiStr]\n\nThe name of the observation point.\n\ndescription : Optional[str], default=\"\"\n\nThe description of the observation point.\n\nID : Optional[int], default=None\n\nThe ID of the observation point.\n\nfile : Optional[str], default=None\n\nThe path to the observation point data file."
  },
  {
    "objectID": "3_api_docs/api_ref/NoFootprintsModel.html",
    "href": "3_api_docs/api_ref/NoFootprintsModel.html",
    "title": "NoFootprintsModel",
    "section": "",
    "text": "config.NoFootprintsModel()\nThe configuration on the how to show objects with no footprints.\n\n\n\nshape : Optional[str], default=\"triangle\"\n\nThe shape of the object with no footprints.\n\ndiameter_meters : Optional[float], default=10\n\nThe diameter of the object with no footprints in meters."
  },
  {
    "objectID": "3_api_docs/api_ref/NoFootprintsModel.html#attributes",
    "href": "3_api_docs/api_ref/NoFootprintsModel.html#attributes",
    "title": "NoFootprintsModel",
    "section": "",
    "text": "shape : Optional[str], default=\"triangle\"\n\nThe shape of the object with no footprints.\n\ndiameter_meters : Optional[float], default=10\n\nThe diameter of the object with no footprints in meters."
  },
  {
    "objectID": "3_api_docs/api_ref/MetricModel.html",
    "href": "3_api_docs/api_ref/MetricModel.html",
    "title": "MetricModel",
    "section": "",
    "text": "database_builder.MetricModel()\nRepresents a metric configuration for infometric analysis.\n\n\n\nname : str\n\nThe short name of the metric.\n\nlong_name : str | None, default=None\n\nThe long descriptive name of the metric. If not provided, defaults to name.\n\nshow_in_metrics_table : bool | None, default=True\n\nIndicates whether the metric should be displayed in the metrics table.\n\nshow_in_map : bool | None, default=True\n\nIndicates whether the metric should be displayed on the map.\n\ndescription : str | None, default=None\n\nA detailed description of the metric. If not provided, defaults to name.\n\nselect : str\n\nThe SQL select statement or expression for the metric.\n\nfilter : str | None, default=\"\"\n\nAn optional SQL filter to apply to the metric. Defaults to no filter.\n\n\n\n\n\nIf long_name or description are None, they will be set to the value of name."
  },
  {
    "objectID": "3_api_docs/api_ref/MetricModel.html#attributes",
    "href": "3_api_docs/api_ref/MetricModel.html#attributes",
    "title": "MetricModel",
    "section": "",
    "text": "name : str\n\nThe short name of the metric.\n\nlong_name : str | None, default=None\n\nThe long descriptive name of the metric. If not provided, defaults to name.\n\nshow_in_metrics_table : bool | None, default=True\n\nIndicates whether the metric should be displayed in the metrics table.\n\nshow_in_map : bool | None, default=True\n\nIndicates whether the metric should be displayed on the map.\n\ndescription : str | None, default=None\n\nA detailed description of the metric. If not provided, defaults to name.\n\nselect : str\n\nThe SQL select statement or expression for the metric.\n\nfilter : str | None, default=\"\"\n\nAn optional SQL filter to apply to the metric. Defaults to no filter."
  },
  {
    "objectID": "3_api_docs/api_ref/MetricModel.html#validation",
    "href": "3_api_docs/api_ref/MetricModel.html#validation",
    "title": "MetricModel",
    "section": "",
    "text": "If long_name or description are None, they will be set to the value of name."
  },
  {
    "objectID": "3_api_docs/api_ref/Measure.html",
    "href": "3_api_docs/api_ref/Measure.html",
    "title": "Measure",
    "section": "",
    "text": "objects.Measure()\nThe expected variables and data types of attributes common to all measures.\nA measure is a collection of attributes that can be applied to a model.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.\n\nselection_type : SelectionType\n\nType of selection. Should be one of the SelectionType enum values.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure‚Äôs toml path in the database.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nread_gdf\nRead the polygon file as a GeoDataFrame if it exists.\n\n\nserialize_polygon_file\nSerialize the polygon_file attribute to a string of only the file name.\n\n\n\n\n\nobjects.Measure.read_gdf(reload: bool = False)\nRead the polygon file as a GeoDataFrame if it exists.\n\n\n\nobjects.Measure.serialize_polygon_file(value: Optional[str])\nSerialize the polygon_file attribute to a string of only the file name."
  },
  {
    "objectID": "3_api_docs/api_ref/Measure.html#attributes",
    "href": "3_api_docs/api_ref/Measure.html#attributes",
    "title": "Measure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.\n\nselection_type : SelectionType\n\nType of selection. Should be one of the SelectionType enum values.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure‚Äôs toml path in the database.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô."
  },
  {
    "objectID": "3_api_docs/api_ref/Measure.html#methods",
    "href": "3_api_docs/api_ref/Measure.html#methods",
    "title": "Measure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nread_gdf\nRead the polygon file as a GeoDataFrame if it exists.\n\n\nserialize_polygon_file\nSerialize the polygon_file attribute to a string of only the file name.\n\n\n\n\n\nobjects.Measure.read_gdf(reload: bool = False)\nRead the polygon file as a GeoDataFrame if it exists.\n\n\n\nobjects.Measure.serialize_polygon_file(value: Optional[str])\nSerialize the polygon_file attribute to a string of only the file name."
  },
  {
    "objectID": "3_api_docs/api_ref/IForcing.html",
    "href": "3_api_docs/api_ref/IForcing.html",
    "title": "IForcing",
    "section": "",
    "text": "objects.IForcing()\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncontent_fingerprint\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.content_fingerprint()\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\nIf a file-backed path attribute exists and the file exists, hash its bytes (SHA-256).\nOtherwise, hash a canonical JSON dump of the model (excluding volatile fields like path).\n\n\n\n\n : str\n\nA fingerprint string that changes when the forcing‚Äôs effective data changes.\n\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory."
  },
  {
    "objectID": "3_api_docs/api_ref/IForcing.html#methods",
    "href": "3_api_docs/api_ref/IForcing.html#methods",
    "title": "IForcing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncontent_fingerprint\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\n\nmodel_dump\nOverride the default model_dump to include class variables type and source.\n\n\nsave_additional\nSave additional data of the forcing.\n\n\nserialize_path\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory.\n\n\n\n\n\nobjects.IForcing.content_fingerprint()\nReturn a stable fingerprint of the forcing‚Äôs underlying data.\n\nIf a file-backed path attribute exists and the file exists, hash its bytes (SHA-256).\nOtherwise, hash a canonical JSON dump of the model (excluding volatile fields like path).\n\n\n\n\n : str\n\nA fingerprint string that changes when the forcing‚Äôs effective data changes.\n\n\n\n\n\n\nobjects.IForcing.model_dump(**kwargs: Any)\nOverride the default model_dump to include class variables type and source.\n\n\n\nobjects.IForcing.save_additional(output_dir: Path | str | os.PathLike)\nSave additional data of the forcing.\n\n\n\nobjects.IForcing.serialize_path(value: Path)\nSerialize filepath-like fields by saving only the filename. It is assumed that the file will be saved in the same directory."
  },
  {
    "objectID": "3_api_docs/api_ref/HomesInfographicModel.html",
    "href": "3_api_docs/api_ref/HomesInfographicModel.html",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "database_builder.HomesInfographicModel()\nModel for Homes and SVI (Social Vulnerability Index) infographic configuration.\n\n\n\nsvi : SviModel\n\nSVI classification configuration.\n\nmapping : TypeMapping\n\nDatabase field mapping for filtering relevant objects.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for SVI infographics.\n\n\n\n\n\ndatabase_builder.HomesInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'] = 'OSM',\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for SVI infographics.\n\n\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification. If not provided, SVI will be None.\n\ntype : Literal['OSM', 'NSI'] = \"OSM\"\n\nThe database type to create a template for.\n\n\n\n\n\n\n : HomesInfographicModel\n\nPre-configured Homes infographic model."
  },
  {
    "objectID": "3_api_docs/api_ref/HomesInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/HomesInfographicModel.html#attributes",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "svi : SviModel\n\nSVI classification configuration.\n\nmapping : TypeMapping\n\nDatabase field mapping for filtering relevant objects.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration."
  },
  {
    "objectID": "3_api_docs/api_ref/HomesInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/HomesInfographicModel.html#methods",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for SVI infographics.\n\n\n\n\n\ndatabase_builder.HomesInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'] = 'OSM',\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for SVI infographics.\n\n\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification. If not provided, SVI will be None.\n\ntype : Literal['OSM', 'NSI'] = \"OSM\"\n\nThe database type to create a template for.\n\n\n\n\n\n\n : HomesInfographicModel\n\nPre-configured Homes infographic model."
  },
  {
    "objectID": "3_api_docs/api_ref/GuiUnitModel.html",
    "href": "3_api_docs/api_ref/GuiUnitModel.html",
    "title": "GuiUnitModel",
    "section": "",
    "text": "config.GuiUnitModel()\nThe unit system used in the GUI.\n\n\n\ndefault_length_units : us.UnitTypesLength\n\nThe length units used in the GUI.\n\ndefault_distance_units : us.UnitTypesLength\n\nThe distance units used in the GUI.\n\ndefault_area_units : us.UnitTypesArea\n\nThe area units used in the GUI.\n\ndefault_volume_units : us.UnitTypesVolume\n\nThe volume units used in the GUI.\n\ndefault_velocity_units : us.UnitTypesVelocity\n\nThe velocity units used in the GUI.\n\ndefault_direction_units : us.UnitTypesDirection\n\nThe direction units used in the GUI.\n\ndefault_discharge_units : us.UnitTypesDischarge\n\nThe discharge units used in the GUI.\n\ndefault_intensity_units : us.UnitTypesIntensity\n\nThe intensity units used in the GUI.\n\ndefault_cumulative_units : us.UnitTypesLength\n\nThe cumulative units used in the GUI."
  },
  {
    "objectID": "3_api_docs/api_ref/GuiUnitModel.html#attributes",
    "href": "3_api_docs/api_ref/GuiUnitModel.html#attributes",
    "title": "GuiUnitModel",
    "section": "",
    "text": "default_length_units : us.UnitTypesLength\n\nThe length units used in the GUI.\n\ndefault_distance_units : us.UnitTypesLength\n\nThe distance units used in the GUI.\n\ndefault_area_units : us.UnitTypesArea\n\nThe area units used in the GUI.\n\ndefault_volume_units : us.UnitTypesVolume\n\nThe volume units used in the GUI.\n\ndefault_velocity_units : us.UnitTypesVelocity\n\nThe velocity units used in the GUI.\n\ndefault_direction_units : us.UnitTypesDirection\n\nThe direction units used in the GUI.\n\ndefault_discharge_units : us.UnitTypesDischarge\n\nThe discharge units used in the GUI.\n\ndefault_intensity_units : us.UnitTypesIntensity\n\nThe intensity units used in the GUI.\n\ndefault_cumulative_units : us.UnitTypesLength\n\nThe cumulative units used in the GUI."
  },
  {
    "objectID": "3_api_docs/api_ref/GuiConfigModel.html",
    "href": "3_api_docs/api_ref/GuiConfigModel.html",
    "title": "GuiConfigModel",
    "section": "",
    "text": "database_builder.GuiConfigModel()\nConfiguration for FloodAdapt GUI visualization scaling.\n\n\n\nmax_flood_depth : float\n\nMaximum flood depth for visualization bins (last bin is ‚Äú&gt;value‚Äù).\n\nmax_aggr_dmg : float\n\nMaximum aggregated damage for visualization bins.\n\nmax_footprint_dmg : float\n\nMaximum footprint damage for visualization bins.\n\nmax_benefits : float\n\nMaximum benefits for visualization bins.\n\nadditional_aggregated_layers : Optional[list[MetricLayer]]\n\nAdditional metric layers for aggregation (optional).\n\ntopobathy_min_max : Union[tuple[float, float], Literal['dem']]\n\nMin/max values for DEM color scaling; set to ‚Äúdem‚Äù to derive from the elevation raster or provide explicit bounds in GUI units.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "GuiConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/GuiConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/GuiConfigModel.html#attributes",
    "title": "GuiConfigModel",
    "section": "",
    "text": "max_flood_depth : float\n\nMaximum flood depth for visualization bins (last bin is ‚Äú&gt;value‚Äù).\n\nmax_aggr_dmg : float\n\nMaximum aggregated damage for visualization bins.\n\nmax_footprint_dmg : float\n\nMaximum footprint damage for visualization bins.\n\nmax_benefits : float\n\nMaximum benefits for visualization bins.\n\nadditional_aggregated_layers : Optional[list[MetricLayer]]\n\nAdditional metric layers for aggregation (optional).\n\ntopobathy_min_max : Union[tuple[float, float], Literal['dem']]\n\nMin/max values for DEM color scaling; set to ‚Äúdem‚Äù to derive from the elevation raster or provide explicit bounds in GUI units.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "GuiConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/ForcingType.html",
    "href": "3_api_docs/api_ref/ForcingType.html",
    "title": "ForcingType",
    "section": "",
    "text": "objects.ForcingType()\nEnum class for the different types of forcing parameters.\n\n\n\nRAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level."
  },
  {
    "objectID": "3_api_docs/api_ref/ForcingType.html#attributes",
    "href": "3_api_docs/api_ref/ForcingType.html#attributes",
    "title": "ForcingType",
    "section": "",
    "text": "RAINFALL : The type of forcing parameter for rainfall.\n\n\n\nWIND : The type of forcing parameter for wind.\n\n\n\nDISCHARGE : The type of forcing parameter for discharge.\n\n\n\nWATERLEVEL : The type of forcing parameter for water level."
  },
  {
    "objectID": "3_api_docs/api_ref/FootprintsDmgLayer.html",
    "href": "3_api_docs/api_ref/FootprintsDmgLayer.html",
    "title": "FootprintsDmgLayer",
    "section": "",
    "text": "FootprintsDmgLayer\nconfig.FootprintsDmgLayer()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/FloodWall.html",
    "href": "3_api_docs/api_ref/FloodWall.html",
    "title": "FloodWall",
    "section": "",
    "text": "objects.FloodWall()\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLengthRefValue\n\nHeight of the floodwall."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodWall.html#attributes",
    "href": "3_api_docs/api_ref/FloodWall.html#attributes",
    "title": "FloodWall",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLengthRefValue\n\nHeight of the floodwall."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodModel.html",
    "href": "3_api_docs/api_ref/FloodModel.html",
    "title": "FloodModel",
    "section": "",
    "text": "config.FloodModel()\nThe accepted input for the variable overland_model and offshore_model in Site.\n\n\n\nname : str\n\nThe name of the directory in static/templates/&lt;directory&gt; that contains the template model files.\n\nreference : str\n\nThe name of the vertical reference model that is used as the reference datum. Should be defined in water_level.datums.\n\nvertical_offset : Optional[us.UnitfulLength], default = None\n\nThe vertical offset of the vertical reference model relative to the main reference. Given that the height of the vertical reference model is often determined by external sources, this vertical offset can be used to correct systematic over-/underestimation of a vertical reference model."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodModel.html#attributes",
    "href": "3_api_docs/api_ref/FloodModel.html#attributes",
    "title": "FloodModel",
    "section": "",
    "text": "name : str\n\nThe name of the directory in static/templates/&lt;directory&gt; that contains the template model files.\n\nreference : str\n\nThe name of the vertical reference model that is used as the reference datum. Should be defined in water_level.datums.\n\nvertical_offset : Optional[us.UnitfulLength], default = None\n\nThe vertical offset of the vertical reference model relative to the main reference. Given that the height of the vertical reference model is often determined by external sources, this vertical offset can be used to correct systematic over-/underestimation of a vertical reference model."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodFrequencyModel.html",
    "href": "3_api_docs/api_ref/FloodFrequencyModel.html",
    "title": "FloodFrequencyModel",
    "section": "",
    "text": "FloodFrequencyModel\nconfig.FloodFrequencyModel()\nThe accepted input for the variable flood_frequency in Site.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/FloodAdapt.html",
    "href": "3_api_docs/api_ref/FloodAdapt.html",
    "title": "FloodAdapt",
    "section": "",
    "text": "FloodAdapt(database_path: Path)\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_benefit_scenarios\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\ncopy_event\nCopy an event in the database.\n\n\ncopy_measure\nCopy a measure in the database.\n\n\ncopy_projection\nCopy a projection in the database.\n\n\ncopy_strategy\nCopy a strategy in the database.\n\n\ncreate_benefit\nCreate a new benefit object.\n\n\ncreate_benefit_scenarios\nCreate the benefit scenarios.\n\n\ncreate_event\nCreate a event object from a dictionary of attributes.\n\n\ncreate_event_set\nCreate a event set object from a dictionary of attributes.\n\n\ncreate_measure\nCreate a measure from a dictionary of attributes and a type string.\n\n\ncreate_projection\nCreate a new projection object.\n\n\ncreate_scenario\nCreate a new scenario object.\n\n\ncreate_strategy\nCreate a new strategy object.\n\n\ndelete_benefit\nDelete a benefit object from the database.\n\n\ndelete_event\nDelete an event from the database.\n\n\ndelete_measure\nDelete an measure from the database.\n\n\ndelete_projection\nDelete a projection from the database.\n\n\ndelete_scenario\nDelete a scenario from the database.\n\n\ndelete_strategy\nDelete a strategy from the database.\n\n\nget_aggregated_benefits\nGet the aggregation benefits for a benefit assessment.\n\n\nget_aggregated_impacts\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\nget_aggregation_areas\nGet a list of the aggregation areas that are provided in the site configuration.\n\n\nget_benefit\nGet a benefit from the database by name.\n\n\nget_benefits\nGet all benefits from the database.\n\n\nget_building_footprint_impacts\nReturn a geodataframe of the impacts at the footprint level.\n\n\nget_building_geometries\nGet the buildings exposure that are used in Fiat.\n\n\nget_building_types\nGet the building types/categories that are used in the exposure.\n\n\nget_completed_scenarios\nGet all completed scenarios from the database.\n\n\nget_cyclone_track_by_index\nGet a cyclone track from the database by index.\n\n\nget_depth_conversion\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\nget_event\nGet an event from the database by name.\n\n\nget_events\nGet all events from the database.\n\n\nget_flood_map_geotiff\nReturn the path to the geotiff file with the flood map for the given scenario.\n\n\nget_green_infra_table\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\nget_index_path\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\nget_infographic\nReturn the HTML string of the infographic for the given scenario.\n\n\nget_infometrics\nReturn the infometrics DataFrame for the given scenario and optional aggregation.\n\n\nget_max_water_level_map\nReturn the maximum water level for the given scenario.\n\n\nget_measure\nGet a measure from the database by name.\n\n\nget_measures\nGet all measures from the database.\n\n\nget_model_boundary\nGet the model boundary that is used in SFINCS.\n\n\nget_model_grid\nGet the model grid that is used in SFINCS.\n\n\nget_obs_point_timeseries\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\nget_obs_points\nGet the observation points specified in the site.toml.\n\n\nget_projection\nGet a projection from the database by name.\n\n\nget_projections\nGet all projections from the database.\n\n\nget_road_impacts\nReturn a geodataframe of the impacts at roads.\n\n\nget_scenario\nGet a scenario from the database by name.\n\n\nget_scenarios\nGet all scenarios from the database.\n\n\nget_slr_scn_names\nGet all sea level rise scenario names from the database.\n\n\nget_static_map\nGet a static map from the database.\n\n\nget_strategies\nGet all strategies from the database.\n\n\nget_strategy\nGet a strategy from the database by name.\n\n\nget_svi_map\nGet the SVI map that are used in Fiat.\n\n\nget_topobathy_path\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nload_static_data\nRead the static data into the cache.\n\n\nplot_event_forcing\nPlot forcing data for an event.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\nrun_benefit\nRun the benefit assessment.\n\n\nrun_scenario\nRun a scenario hazard and impacts.\n\n\nsave_benefit\nSave a benefit object to the database.\n\n\nsave_event\nSave an event object to the database.\n\n\nsave_flood_animation\nCreate an animation of the flood extent over time.\n\n\nsave_measure\nSave a measure object to the database.\n\n\nsave_projection\nSave a projection object to the database.\n\n\nsave_scenario\nSave the scenario to the database.\n\n\nsave_strategy\nSave a strategy object to the database.\n\n\n\n\n\nFloodAdapt.check_benefit_scenarios(benefit: Benefit)\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\n\nbenefit : Benefit\n\nThe benefit object to check.\n\n\n\n\n\n\nscenarios : pd.DataFrame\n\nA dataframe with the scenarios needed for this benefit assessment run.\n\n\n\n\n\n\nFloodAdapt.copy_event(old_name: str, new_name: str, new_description: str)\nCopy an event in the database.\n\n\n\nold_name : str\n\nThe name of the event to copy.\n\nnew_name : str\n\nThe name of the new event.\n\nnew_description : str\n\nThe description of the new event\n\n\n\n\n\n\nFloodAdapt.copy_measure(old_name: str, new_name: str, new_description: str)\nCopy a measure in the database.\n\n\n\nold_name : str\n\nThe name of the measure to copy.\n\nnew_name : str\n\nThe name of the new measure.\n\nnew_description : str\n\nThe description of the new measure\n\n\n\n\n\n\nFloodAdapt.copy_projection(old_name: str, new_name: str, new_description: str)\nCopy a projection in the database.\n\n\n\nold_name : str\n\nThe name of the projection to copy.\n\nnew_name : str\n\nThe name of the new projection.\n\nnew_description : str\n\nThe description of the new projection\n\n\n\n\n\n\nFloodAdapt.copy_strategy(old_name: str, new_name: str, new_description: str)\nCopy a strategy in the database.\n\n\n\nold_name : str\n\nThe name of the strategy to copy.\n\nnew_name : str\n\nThe name of the new strategy.\n\nnew_description : str\n\nThe description of the new strategy\n\n\n\n\n\n\nFloodAdapt.create_benefit(attrs: dict[str, Any])\nCreate a new benefit object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the benefit object to create. Should adhere to the Benefit schema.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Benefit schema.\n\n\n\n\n\n\nFloodAdapt.create_benefit_scenarios(benefit: Benefit)\nCreate the benefit scenarios.\n\n\n\nbenefit : Benefit\n\nThe benefit object to create scenarios for.\n\n\n\n\n\n\nFloodAdapt.create_event(attrs: dict[str, Any] | Event)\nCreate a event object from a dictionary of attributes.\n\n\n\nattrs : Event[str, Any]\n\nDictionary of attributes\n\n\n\n\n\n\nevent : Event\n\nDepending on attrs.template an event object. Can be of type: Synthetic, Historical, Hurricane.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Event schema.\n\n\n\n\n\n\nFloodAdapt.create_event_set(\n    attrs: dict[str, Any] | EventSet,\n    sub_events: list[Event],\n)\nCreate a event set object from a dictionary of attributes.\n\n\n\nattrs : EventSet[str, Any]\n\nDictionary of attributes\n\nsub_events : list[Event]\n\nList of events in the event set\n\n\n\n\n\n\nevent_set : EventSet\n\nEventSet object\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the EventSet schema.\n\n\n\n\n\n\nFloodAdapt.create_measure(attrs: dict[str, Any], type: str = None)\nCreate a measure from a dictionary of attributes and a type string.\n\n\n\nattrs : dict[str, Any]\n\nDictionary of attributes for the measure.\n\ntype : str = None\n\nType of measure to create.\n\n\n\n\n\n\nmeasure : Measure\n\nMeasure object.\n\n\n\n\n\n\n: ValueError\n\nIf the type is not valid or if the attributes do not adhere to the Measure schema.\n\n\n\n\n\n\nFloodAdapt.create_projection(attrs: dict[str, Any])\nCreate a new projection object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the projection object to create. Should adhere to the Projection schema.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Projection schema.\n\n\n\n\n\n\nFloodAdapt.create_scenario(attrs: dict[str, Any])\nCreate a new scenario object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the scenario object to create. Should adhere to the Scenario schema.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Scenario schema.\n\n\n\n\n\n\nFloodAdapt.create_strategy(attrs: dict[str, Any])\nCreate a new strategy object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the strategy object to create. Should adhere to the Strategy schema.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object\n\n\n\n\n\n\n: ValueError\n\nIf attrs does not adhere to the Strategy schema.\n\n\n\n\n\n\nFloodAdapt.delete_benefit(name: str)\nDelete a benefit object from the database.\n\n\n\nname : str\n\nThe name of the benefit object to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit object does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_event(name: str)\nDelete an event from the database.\n\n\n\nname : str\n\nThe name of the event to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the event does not exist. If the event is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_measure(name: str)\nDelete an measure from the database.\n\n\n\nname : str\n\nThe name of the measure to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_projection(name: str)\nDelete a projection from the database.\n\n\n\nname : str\n\nThe name of the projection to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection does not exist. If the projection is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_scenario(name: str)\nDelete a scenario from the database.\n\n\n\nname : str\n\nThe name of the scenario to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_strategy(name: str)\nDelete a strategy from the database.\n\n\n\nname : str\n\nThe name of the strategy to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy does not exist.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_benefits(name: str)\nGet the aggregation benefits for a benefit assessment.\n\n\n\nname : str\n\nThe name of the benefit assessment.\n\n\n\n\n\n\naggregated_benefits : gpd.GeoDataFrame\n\nThe aggregation benefits for the benefit assessment.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_impacts(name: str)\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\naggr_impacts : dict[str, gpd.GeoDataFrame]\n\nThe aggregated impacts for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_aggregation_areas()\nGet a list of the aggregation areas that are provided in the site configuration.\nThese are expected to much the ones in the FIAT model.\n\n\n\naggregation_areas : dict[str, GeoDataFrame]\n\nlist of geodataframes with the polygons defining the aggregation areas\n\n\n\n\n\n\nFloodAdapt.get_benefit(name: str)\nGet a benefit from the database by name.\n\n\n\nname : str\n\nThe name of the benefit to retrieve.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object with the given name. See Benefit for details.\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_benefits()\nGet all benefits from the database.\n\n\n\nbenefits : dict[str, Any]\n\nA dictionary containing all benefits. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_building_footprint_impacts(name: str)\nReturn a geodataframe of the impacts at the footprint level.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nfootprints : gpd.GeoDataFrame\n\nThe impact footprints for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_building_geometries()\nGet the buildings exposure that are used in Fiat.\n\n\n\nbuildings : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the buildings from FIAT exposure\n\n\n\n\n\n\nFloodAdapt.get_building_types()\nGet the building types/categories that are used in the exposure.\nThese are used to filter the buildings in the FIAT model, and can include types like: ‚ÄòResidential‚Äô, ‚ÄòCommercial‚Äô, ‚ÄòIndustrial‚Äô, etc.\n\n\n\nbuilding_types : list[str]\n\nlist of building types\n\n\n\n\n\n\nFloodAdapt.get_completed_scenarios()\nGet all completed scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each output.\n\n\n\n\n\n\nFloodAdapt.get_cyclone_track_by_index(index: int)\nGet a cyclone track from the database by index.\n\n\n\nindex : int\n\nThe index of the cyclone track to retrieve.\n\n\n\n\n\n\ncyclone : TropicalCyclone\n\nThe cyclone track object with the given index.\n\n\n\n\n\n\n: DatabaseError\n\nIf the cyclone track database is not defined in the site configuration. If the cyclone track with the given index does not exist.\n\n\n\n\n\n\nFloodAdapt.get_depth_conversion()\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\n\nfdc : float\n\nThe flood depth conversion.\n\n\n\n\n\n\nFloodAdapt.get_event(name: str)\nGet an event from the database by name.\n\n\n\nname : str\n\nThe name of the event to retrieve.\n\n\n\n\n\n\nevent : Event | EventSet\n\nThe event with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the event with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_events()\nGet all events from the database.\n\n\n\nevents : dict[str, Any]\n\nA dictionary containing all events. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_flood_map_geotiff(name: str, rp: int | None = None)\nReturn the path to the geotiff file with the flood map for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None. Only for event set scenarios.\n\n\n\n\n\n\nflood_map_geotiff : Path | None\n\nThe path to the geotiff file with the flood map for the scenario if it exists, otherwise None.\n\n\n\n\n\n\nFloodAdapt.get_green_infra_table(measure_type: str)\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\n\nmeasure_type : str\n\nThe type of green infrastructure measure.\n\n\n\n\n\n\ntable : pd.DataFrame\n\nA table with different types of green infrastructure measures and their infiltration depths.\n\n\n\n\n\n\nFloodAdapt.get_index_path()\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\n\nindex_path : str\n\nThe path to the index file.\n\n\n\n\n\n\nFloodAdapt.get_infographic(name: str)\nReturn the HTML string of the infographic for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml : str\n\nThe HTML string of the infographic.\n\n\n\n\n\n\nFloodAdapt.get_infometrics(name: str, aggr_name: str | None = None)\nReturn the infometrics DataFrame for the given scenario and optional aggregation.\n\n\n\nname : str\n\nThe name of the scenario.\n\naggr_name : str | None = None\n\nThe name of the aggregation, if any.\n\n\n\n\n\n\ndf : pd.DataFrame\n\nThe infometrics DataFrame for the scenario (and aggregation if specified).\n\n\n\n\n\n\n: FileNotFoundError\n\nIf the metrics file does not exist for the given scenario (and aggregation).\n\n\n\n\n\n\nFloodAdapt.get_max_water_level_map(name: str, rp: int | None = None)\nReturn the maximum water level for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None\n\n\n\n\n\n\nwater_level_map : np.ndarray\n\n2D gridded map with the maximum waterlevels for each cell.\n\n\n\n\n\n\nFloodAdapt.get_measure(name: str)\nGet a measure from the database by name.\n\n\n\nname : str\n\nThe name of the measure to retrieve.\n\n\n\n\n\n\nmeasure : Measure\n\nThe measure object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_measures()\nGet all measures from the database.\n\n\n\nmeasures : dict[str, Any]\n\nA dictionary containing all measures. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each measure.\n\n\n\n\n\n\nFloodAdapt.get_model_boundary()\nGet the model boundary that is used in SFINCS.\n\n\n\nmodel_boundary : GeoDataFrame\n\nGeoDataFrame with the model boundary\n\n\n\n\n\n\nFloodAdapt.get_model_grid()\nGet the model grid that is used in SFINCS.\n\n\n\ngrid : QuadtreeGrid\n\nQuadtreeGrid with the model grid\n\n\n\n\n\n\nFloodAdapt.get_obs_point_timeseries(name: str)\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\ngdf : (GeoDataFrame, optional)\n\nA GeoDataFrame with the observation points and their corresponding HTML paths for the timeseries. Each row contains the station name and the path to the HTML file with the timeseries. None if no observation points are found or if the scenario has not been run yet.\n\n\n\n\n\n\nFloodAdapt.get_obs_points()\nGet the observation points specified in the site.toml.\nThese are also added to the flood hazard model. They are used as marker locations to plot water level time series in the output tab.\n\n\n\nobservation_points : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with observation points from the site.toml.\n\n\n\n\n\n\nFloodAdapt.get_projection(name: str)\nGet a projection from the database by name.\n\n\n\nname : str\n\nThe name of the projection to retrieve.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_projections()\nGet all projections from the database.\n\n\n\nprojections : dict[str, Any]\n\nA dictionary containing all projections. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each projection.\n\n\n\n\n\n\nFloodAdapt.get_road_impacts(name: str)\nReturn a geodataframe of the impacts at roads.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nroads : gpd.GeoDataFrame\n\nThe impacted roads for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_scenario(name: str)\nGet a scenario from the database by name.\n\n\n\nname : str\n\nThe name of the scenario to retrieve.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_scenarios()\nGet all scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô. Each value is a list of the corresponding attribute for each scenario.\n\n\n\n\n\n\nFloodAdapt.get_slr_scn_names()\nGet all sea level rise scenario names from the database.\n\n\n\nnames : list[str]\n\nlist of scenario names\n\n\n\n\n\n\nFloodAdapt.get_static_map(path: str | Path)\nGet a static map from the database.\n\n\n\npath : str | Path\n\npath to the static map\n\n\n\n\n\n\nstatic_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with the static map\n\n\n\n\n\n\n: DatabaseError\n\nIf the static map with the given path does not exist.\n\n\n\n\n\n\nFloodAdapt.get_strategies()\nGet all strategies from the database.\n\n\n\nstrategies : dict[str, Any]\n\nA dictionary containing all strategies. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each strategy.\n\n\n\n\n\n\nFloodAdapt.get_strategy(name: str)\nGet a strategy from the database by name.\n\n\n\nname : str\n\nThe name of the strategy to retrieve.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_svi_map()\nGet the SVI map that are used in Fiat.\n\n\n\nsvi_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the SVI map, None if not available\n\n\n\n\n\n\nFloodAdapt.get_topobathy_path()\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\n\ntopo_path : str\n\nThe path to the topobathy file.\n\n\n\n\n\n\nFloodAdapt.interp_slr(slr_scenario: str, year: float)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nslr_scenario : str\n\nSLR scenario name from the coulmn names in static/slr/slr.csv\n\nyear : float\n\nyear to evaluate\n\n\n\n\n\n\ninterpolated : float\n\nThe interpolated sea level rise for the given scenario and year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nFloodAdapt.load_static_data()\nRead the static data into the cache.\nThis is used to speed up the loading of the static data.\n\n\n\nFloodAdapt.plot_event_forcing(event: Event, forcing_type: ForcingType)\nPlot forcing data for an event.\n\n\n\nevent : Event\n\nThe event object\n\nforcing_type : ForcingType\n\nThe type of forcing data to plot\n\n\n\n\n\n\nFloodAdapt.plot_slr_scenarios()\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.\n\n\n\n\n\n\nFloodAdapt.run_benefit(name: str | list[str])\nRun the benefit assessment.\n\n\n\nname : str | list[str]\n\nThe name of the benefit object to run.\n\n\n\n\n\n\nFloodAdapt.run_scenario(scenario_name: str | list[str])\nRun a scenario hazard and impacts.\n\n\n\nscenario_name : str | list[str]\n\nname(s) of the scenarios to run.\n\n\n\n\n\n\n: RuntimeError\n\nIf an error occurs while running one of the scenarios\n\n\n\n\n\n\nFloodAdapt.save_benefit(benefit: Benefit, overwrite: bool = False)\nSave a benefit object to the database.\n\n\n\nbenefit : Benefit\n\nThe benefit object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing benefit with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_event(event: Event, overwrite: bool = False)\nSave an event object to the database.\n\n\n\nevent : Event\n\nThe event object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing event with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the event object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_flood_animation(\n    scenario: str,\n    bbox: list[float] | None = None,\n    zoomlevel: int = 15,\n)\nCreate an animation of the flood extent over time.\nProduced floodmap is in the units defined in the sfincs config settings.\n\n\n\nscenario : str\n\nName of the scenario for which to create the floodmap.\n\nbbox : list[float] = None\n\nBounding box to limit the animation to a specific area (default is None, which means no bounding box). Format: [lon_min, lat_min, lon_max, lat_max]\n\nzoomlevel : int = 15\n\nZoom level for the animation (default is 15).\n\n\n\n\n\n\nFloodAdapt.save_measure(measure: Measure, overwrite: bool = False)\nSave a measure object to the database.\n\n\n\nmeasure : Measure\n\nThe measure object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing measure with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_projection(projection: Projection, overwrite: bool = False)\nSave a projection object to the database.\n\n\n\nprojection : Projection\n\nThe projection object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing projection with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_scenario(scenario: Scenario, overwrite: bool = False)\nSave the scenario to the database.\n\n\n\nscenario : Scenario\n\nThe scenario to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing scenario with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario object is not valid or if it already exists and overwrite is False.\n\n\n\n\n\n\nFloodAdapt.save_strategy(strategy: Strategy, overwrite: bool = False)\nSave a strategy object to the database.\n\n\n\nstrategy : Strategy\n\nThe strategy object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing strategy with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy object is not valid. If the strategy object already exists.",
    "crumbs": [
      "API Reference",
      "FloodAdapt",
      "FloodAdapt"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/FloodAdapt.html#methods",
    "href": "3_api_docs/api_ref/FloodAdapt.html#methods",
    "title": "FloodAdapt",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_benefit_scenarios\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\ncopy_event\nCopy an event in the database.\n\n\ncopy_measure\nCopy a measure in the database.\n\n\ncopy_projection\nCopy a projection in the database.\n\n\ncopy_strategy\nCopy a strategy in the database.\n\n\ncreate_benefit\nCreate a new benefit object.\n\n\ncreate_benefit_scenarios\nCreate the benefit scenarios.\n\n\ncreate_event\nCreate a event object from a dictionary of attributes.\n\n\ncreate_event_set\nCreate a event set object from a dictionary of attributes.\n\n\ncreate_measure\nCreate a measure from a dictionary of attributes and a type string.\n\n\ncreate_projection\nCreate a new projection object.\n\n\ncreate_scenario\nCreate a new scenario object.\n\n\ncreate_strategy\nCreate a new strategy object.\n\n\ndelete_benefit\nDelete a benefit object from the database.\n\n\ndelete_event\nDelete an event from the database.\n\n\ndelete_measure\nDelete an measure from the database.\n\n\ndelete_projection\nDelete a projection from the database.\n\n\ndelete_scenario\nDelete a scenario from the database.\n\n\ndelete_strategy\nDelete a strategy from the database.\n\n\nget_aggregated_benefits\nGet the aggregation benefits for a benefit assessment.\n\n\nget_aggregated_impacts\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\nget_aggregation_areas\nGet a list of the aggregation areas that are provided in the site configuration.\n\n\nget_benefit\nGet a benefit from the database by name.\n\n\nget_benefits\nGet all benefits from the database.\n\n\nget_building_footprint_impacts\nReturn a geodataframe of the impacts at the footprint level.\n\n\nget_building_geometries\nGet the buildings exposure that are used in Fiat.\n\n\nget_building_types\nGet the building types/categories that are used in the exposure.\n\n\nget_completed_scenarios\nGet all completed scenarios from the database.\n\n\nget_cyclone_track_by_index\nGet a cyclone track from the database by index.\n\n\nget_depth_conversion\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\nget_event\nGet an event from the database by name.\n\n\nget_events\nGet all events from the database.\n\n\nget_flood_map_geotiff\nReturn the path to the geotiff file with the flood map for the given scenario.\n\n\nget_green_infra_table\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\nget_index_path\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\nget_infographic\nReturn the HTML string of the infographic for the given scenario.\n\n\nget_infometrics\nReturn the infometrics DataFrame for the given scenario and optional aggregation.\n\n\nget_max_water_level_map\nReturn the maximum water level for the given scenario.\n\n\nget_measure\nGet a measure from the database by name.\n\n\nget_measures\nGet all measures from the database.\n\n\nget_model_boundary\nGet the model boundary that is used in SFINCS.\n\n\nget_model_grid\nGet the model grid that is used in SFINCS.\n\n\nget_obs_point_timeseries\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\nget_obs_points\nGet the observation points specified in the site.toml.\n\n\nget_projection\nGet a projection from the database by name.\n\n\nget_projections\nGet all projections from the database.\n\n\nget_road_impacts\nReturn a geodataframe of the impacts at roads.\n\n\nget_scenario\nGet a scenario from the database by name.\n\n\nget_scenarios\nGet all scenarios from the database.\n\n\nget_slr_scn_names\nGet all sea level rise scenario names from the database.\n\n\nget_static_map\nGet a static map from the database.\n\n\nget_strategies\nGet all strategies from the database.\n\n\nget_strategy\nGet a strategy from the database by name.\n\n\nget_svi_map\nGet the SVI map that are used in Fiat.\n\n\nget_topobathy_path\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\ninterp_slr\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\nload_static_data\nRead the static data into the cache.\n\n\nplot_event_forcing\nPlot forcing data for an event.\n\n\nplot_slr_scenarios\nPlot sea level rise scenarios.\n\n\nrun_benefit\nRun the benefit assessment.\n\n\nrun_scenario\nRun a scenario hazard and impacts.\n\n\nsave_benefit\nSave a benefit object to the database.\n\n\nsave_event\nSave an event object to the database.\n\n\nsave_flood_animation\nCreate an animation of the flood extent over time.\n\n\nsave_measure\nSave a measure object to the database.\n\n\nsave_projection\nSave a projection object to the database.\n\n\nsave_scenario\nSave the scenario to the database.\n\n\nsave_strategy\nSave a strategy object to the database.\n\n\n\n\n\nFloodAdapt.check_benefit_scenarios(benefit: Benefit)\nReturn a dataframe with the scenarios needed for this benefit assessment run.\n\n\n\nbenefit : Benefit\n\nThe benefit object to check.\n\n\n\n\n\n\nscenarios : pd.DataFrame\n\nA dataframe with the scenarios needed for this benefit assessment run.\n\n\n\n\n\n\nFloodAdapt.copy_event(old_name: str, new_name: str, new_description: str)\nCopy an event in the database.\n\n\n\nold_name : str\n\nThe name of the event to copy.\n\nnew_name : str\n\nThe name of the new event.\n\nnew_description : str\n\nThe description of the new event\n\n\n\n\n\n\nFloodAdapt.copy_measure(old_name: str, new_name: str, new_description: str)\nCopy a measure in the database.\n\n\n\nold_name : str\n\nThe name of the measure to copy.\n\nnew_name : str\n\nThe name of the new measure.\n\nnew_description : str\n\nThe description of the new measure\n\n\n\n\n\n\nFloodAdapt.copy_projection(old_name: str, new_name: str, new_description: str)\nCopy a projection in the database.\n\n\n\nold_name : str\n\nThe name of the projection to copy.\n\nnew_name : str\n\nThe name of the new projection.\n\nnew_description : str\n\nThe description of the new projection\n\n\n\n\n\n\nFloodAdapt.copy_strategy(old_name: str, new_name: str, new_description: str)\nCopy a strategy in the database.\n\n\n\nold_name : str\n\nThe name of the strategy to copy.\n\nnew_name : str\n\nThe name of the new strategy.\n\nnew_description : str\n\nThe description of the new strategy\n\n\n\n\n\n\nFloodAdapt.create_benefit(attrs: dict[str, Any])\nCreate a new benefit object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the benefit object to create. Should adhere to the Benefit schema.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Benefit schema.\n\n\n\n\n\n\nFloodAdapt.create_benefit_scenarios(benefit: Benefit)\nCreate the benefit scenarios.\n\n\n\nbenefit : Benefit\n\nThe benefit object to create scenarios for.\n\n\n\n\n\n\nFloodAdapt.create_event(attrs: dict[str, Any] | Event)\nCreate a event object from a dictionary of attributes.\n\n\n\nattrs : Event[str, Any]\n\nDictionary of attributes\n\n\n\n\n\n\nevent : Event\n\nDepending on attrs.template an event object. Can be of type: Synthetic, Historical, Hurricane.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Event schema.\n\n\n\n\n\n\nFloodAdapt.create_event_set(\n    attrs: dict[str, Any] | EventSet,\n    sub_events: list[Event],\n)\nCreate a event set object from a dictionary of attributes.\n\n\n\nattrs : EventSet[str, Any]\n\nDictionary of attributes\n\nsub_events : list[Event]\n\nList of events in the event set\n\n\n\n\n\n\nevent_set : EventSet\n\nEventSet object\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the EventSet schema.\n\n\n\n\n\n\nFloodAdapt.create_measure(attrs: dict[str, Any], type: str = None)\nCreate a measure from a dictionary of attributes and a type string.\n\n\n\nattrs : dict[str, Any]\n\nDictionary of attributes for the measure.\n\ntype : str = None\n\nType of measure to create.\n\n\n\n\n\n\nmeasure : Measure\n\nMeasure object.\n\n\n\n\n\n\n: ValueError\n\nIf the type is not valid or if the attributes do not adhere to the Measure schema.\n\n\n\n\n\n\nFloodAdapt.create_projection(attrs: dict[str, Any])\nCreate a new projection object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the projection object to create. Should adhere to the Projection schema.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Projection schema.\n\n\n\n\n\n\nFloodAdapt.create_scenario(attrs: dict[str, Any])\nCreate a new scenario object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the scenario object to create. Should adhere to the Scenario schema.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object created from the attributes.\n\n\n\n\n\n\n: ValueError\n\nIf the attributes do not adhere to the Scenario schema.\n\n\n\n\n\n\nFloodAdapt.create_strategy(attrs: dict[str, Any])\nCreate a new strategy object.\n\n\n\nattrs : dict[str, Any]\n\nThe attributes of the strategy object to create. Should adhere to the Strategy schema.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object\n\n\n\n\n\n\n: ValueError\n\nIf attrs does not adhere to the Strategy schema.\n\n\n\n\n\n\nFloodAdapt.delete_benefit(name: str)\nDelete a benefit object from the database.\n\n\n\nname : str\n\nThe name of the benefit object to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit object does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_event(name: str)\nDelete an event from the database.\n\n\n\nname : str\n\nThe name of the event to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the event does not exist. If the event is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_measure(name: str)\nDelete an measure from the database.\n\n\n\nname : str\n\nThe name of the measure to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_projection(name: str)\nDelete a projection from the database.\n\n\n\nname : str\n\nThe name of the projection to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection does not exist. If the projection is used in a scenario.\n\n\n\n\n\n\nFloodAdapt.delete_scenario(name: str)\nDelete a scenario from the database.\n\n\n\nname : str\n\nThe name of the scenario to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario does not exist.\n\n\n\n\n\n\nFloodAdapt.delete_strategy(name: str)\nDelete a strategy from the database.\n\n\n\nname : str\n\nThe name of the strategy to delete.\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy does not exist.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_benefits(name: str)\nGet the aggregation benefits for a benefit assessment.\n\n\n\nname : str\n\nThe name of the benefit assessment.\n\n\n\n\n\n\naggregated_benefits : gpd.GeoDataFrame\n\nThe aggregation benefits for the benefit assessment.\n\n\n\n\n\n\nFloodAdapt.get_aggregated_impacts(name: str)\nReturn a dictionary with the aggregated impacts as geodataframes.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\naggr_impacts : dict[str, gpd.GeoDataFrame]\n\nThe aggregated impacts for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_aggregation_areas()\nGet a list of the aggregation areas that are provided in the site configuration.\nThese are expected to much the ones in the FIAT model.\n\n\n\naggregation_areas : dict[str, GeoDataFrame]\n\nlist of geodataframes with the polygons defining the aggregation areas\n\n\n\n\n\n\nFloodAdapt.get_benefit(name: str)\nGet a benefit from the database by name.\n\n\n\nname : str\n\nThe name of the benefit to retrieve.\n\n\n\n\n\n\nbenefit : Benefit\n\nThe benefit object with the given name. See Benefit for details.\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_benefits()\nGet all benefits from the database.\n\n\n\nbenefits : dict[str, Any]\n\nA dictionary containing all benefits. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_building_footprint_impacts(name: str)\nReturn a geodataframe of the impacts at the footprint level.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nfootprints : gpd.GeoDataFrame\n\nThe impact footprints for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_building_geometries()\nGet the buildings exposure that are used in Fiat.\n\n\n\nbuildings : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the buildings from FIAT exposure\n\n\n\n\n\n\nFloodAdapt.get_building_types()\nGet the building types/categories that are used in the exposure.\nThese are used to filter the buildings in the FIAT model, and can include types like: ‚ÄòResidential‚Äô, ‚ÄòCommercial‚Äô, ‚ÄòIndustrial‚Äô, etc.\n\n\n\nbuilding_types : list[str]\n\nlist of building types\n\n\n\n\n\n\nFloodAdapt.get_completed_scenarios()\nGet all completed scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each output.\n\n\n\n\n\n\nFloodAdapt.get_cyclone_track_by_index(index: int)\nGet a cyclone track from the database by index.\n\n\n\nindex : int\n\nThe index of the cyclone track to retrieve.\n\n\n\n\n\n\ncyclone : TropicalCyclone\n\nThe cyclone track object with the given index.\n\n\n\n\n\n\n: DatabaseError\n\nIf the cyclone track database is not defined in the site configuration. If the cyclone track with the given index does not exist.\n\n\n\n\n\n\nFloodAdapt.get_depth_conversion()\nReturn the flood depth conversion that is need in the gui to plot the flood map.\n\n\n\nfdc : float\n\nThe flood depth conversion.\n\n\n\n\n\n\nFloodAdapt.get_event(name: str)\nGet an event from the database by name.\n\n\n\nname : str\n\nThe name of the event to retrieve.\n\n\n\n\n\n\nevent : Event | EventSet\n\nThe event with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the event with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_events()\nGet all events from the database.\n\n\n\nevents : dict[str, Any]\n\nA dictionary containing all events. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each benefit.\n\n\n\n\n\n\nFloodAdapt.get_flood_map_geotiff(name: str, rp: int | None = None)\nReturn the path to the geotiff file with the flood map for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None. Only for event set scenarios.\n\n\n\n\n\n\nflood_map_geotiff : Path | None\n\nThe path to the geotiff file with the flood map for the scenario if it exists, otherwise None.\n\n\n\n\n\n\nFloodAdapt.get_green_infra_table(measure_type: str)\nReturn a table with different types of green infrastructure measures and their infiltration depths.\n\n\n\nmeasure_type : str\n\nThe type of green infrastructure measure.\n\n\n\n\n\n\ntable : pd.DataFrame\n\nA table with different types of green infrastructure measures and their infiltration depths.\n\n\n\n\n\n\nFloodAdapt.get_index_path()\nReturn the path of the index tiles which are used to connect each water level cell with the topobathy tiles.\n\n\n\nindex_path : str\n\nThe path to the index file.\n\n\n\n\n\n\nFloodAdapt.get_infographic(name: str)\nReturn the HTML string of the infographic for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nhtml : str\n\nThe HTML string of the infographic.\n\n\n\n\n\n\nFloodAdapt.get_infometrics(name: str, aggr_name: str | None = None)\nReturn the infometrics DataFrame for the given scenario and optional aggregation.\n\n\n\nname : str\n\nThe name of the scenario.\n\naggr_name : str | None = None\n\nThe name of the aggregation, if any.\n\n\n\n\n\n\ndf : pd.DataFrame\n\nThe infometrics DataFrame for the scenario (and aggregation if specified).\n\n\n\n\n\n\n: FileNotFoundError\n\nIf the metrics file does not exist for the given scenario (and aggregation).\n\n\n\n\n\n\nFloodAdapt.get_max_water_level_map(name: str, rp: int | None = None)\nReturn the maximum water level for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\nrp : int = None\n\nThe return period of the water level, by default None\n\n\n\n\n\n\nwater_level_map : np.ndarray\n\n2D gridded map with the maximum waterlevels for each cell.\n\n\n\n\n\n\nFloodAdapt.get_measure(name: str)\nGet a measure from the database by name.\n\n\n\nname : str\n\nThe name of the measure to retrieve.\n\n\n\n\n\n\nmeasure : Measure\n\nThe measure object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_measures()\nGet all measures from the database.\n\n\n\nmeasures : dict[str, Any]\n\nA dictionary containing all measures. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each measure.\n\n\n\n\n\n\nFloodAdapt.get_model_boundary()\nGet the model boundary that is used in SFINCS.\n\n\n\nmodel_boundary : GeoDataFrame\n\nGeoDataFrame with the model boundary\n\n\n\n\n\n\nFloodAdapt.get_model_grid()\nGet the model grid that is used in SFINCS.\n\n\n\ngrid : QuadtreeGrid\n\nQuadtreeGrid with the model grid\n\n\n\n\n\n\nFloodAdapt.get_obs_point_timeseries(name: str)\nReturn the HTML strings of the water level timeseries for the given scenario.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\ngdf : (GeoDataFrame, optional)\n\nA GeoDataFrame with the observation points and their corresponding HTML paths for the timeseries. Each row contains the station name and the path to the HTML file with the timeseries. None if no observation points are found or if the scenario has not been run yet.\n\n\n\n\n\n\nFloodAdapt.get_obs_points()\nGet the observation points specified in the site.toml.\nThese are also added to the flood hazard model. They are used as marker locations to plot water level time series in the output tab.\n\n\n\nobservation_points : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with observation points from the site.toml.\n\n\n\n\n\n\nFloodAdapt.get_projection(name: str)\nGet a projection from the database by name.\n\n\n\nname : str\n\nThe name of the projection to retrieve.\n\n\n\n\n\n\nprojection : Projection\n\nThe projection object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_projections()\nGet all projections from the database.\n\n\n\nprojections : dict[str, Any]\n\nA dictionary containing all projections. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each projection.\n\n\n\n\n\n\nFloodAdapt.get_road_impacts(name: str)\nReturn a geodataframe of the impacts at roads.\n\n\n\nname : str\n\nThe name of the scenario.\n\n\n\n\n\n\nroads : gpd.GeoDataFrame\n\nThe impacted roads for the scenario.\n\n\n\n\n\n\nFloodAdapt.get_scenario(name: str)\nGet a scenario from the database by name.\n\n\n\nname : str\n\nThe name of the scenario to retrieve.\n\n\n\n\n\n\nscenario : Scenario\n\nThe scenario object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_scenarios()\nGet all scenarios from the database.\n\n\n\nscenarios : dict[str, Any]\n\nA dictionary containing all scenarios. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô. Each value is a list of the corresponding attribute for each scenario.\n\n\n\n\n\n\nFloodAdapt.get_slr_scn_names()\nGet all sea level rise scenario names from the database.\n\n\n\nnames : list[str]\n\nlist of scenario names\n\n\n\n\n\n\nFloodAdapt.get_static_map(path: str | Path)\nGet a static map from the database.\n\n\n\npath : str | Path\n\npath to the static map\n\n\n\n\n\n\nstatic_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrame with the static map\n\n\n\n\n\n\n: DatabaseError\n\nIf the static map with the given path does not exist.\n\n\n\n\n\n\nFloodAdapt.get_strategies()\nGet all strategies from the database.\n\n\n\nstrategies : dict[str, Any]\n\nA dictionary containing all strategies. Includes keys: ‚Äòname‚Äô, ‚Äòdescription‚Äô, ‚Äòpath‚Äô, ‚Äòlast_modification_date‚Äô, ‚Äòobjects‚Äô Each value is a list of the corresponding attribute for each strategy.\n\n\n\n\n\n\nFloodAdapt.get_strategy(name: str)\nGet a strategy from the database by name.\n\n\n\nname : str\n\nThe name of the strategy to retrieve.\n\n\n\n\n\n\nstrategy : Strategy\n\nThe strategy object with the given name.\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy with the given name does not exist.\n\n\n\n\n\n\nFloodAdapt.get_svi_map()\nGet the SVI map that are used in Fiat.\n\n\n\nsvi_map : gpd.GeoDataFrame\n\ngpd.GeoDataFrames with the SVI map, None if not available\n\n\n\n\n\n\nFloodAdapt.get_topobathy_path()\nReturn the path of the topobathy tiles in order to create flood maps with water level maps.\n\n\n\ntopo_path : str\n\nThe path to the topobathy file.\n\n\n\n\n\n\nFloodAdapt.interp_slr(slr_scenario: str, year: float)\nInterpolate SLR value and reference it to the SLR reference year from the site toml.\n\n\n\nslr_scenario : str\n\nSLR scenario name from the coulmn names in static/slr/slr.csv\n\nyear : float\n\nyear to evaluate\n\n\n\n\n\n\ninterpolated : float\n\nThe interpolated sea level rise for the given scenario and year.\n\n\n\n\n\n\n: ValueError\n\nif the reference year is outside of the time range in the slr.csv file\n\n: ValueError\n\nif the year to evaluate is outside of the time range in the slr.csv file\n\n\n\n\n\n\nFloodAdapt.load_static_data()\nRead the static data into the cache.\nThis is used to speed up the loading of the static data.\n\n\n\nFloodAdapt.plot_event_forcing(event: Event, forcing_type: ForcingType)\nPlot forcing data for an event.\n\n\n\nevent : Event\n\nThe event object\n\nforcing_type : ForcingType\n\nThe type of forcing data to plot\n\n\n\n\n\n\nFloodAdapt.plot_slr_scenarios()\nPlot sea level rise scenarios.\n\n\n\nhtml_path : str\n\nThe path to the html plot of the sea level rise scenarios.\n\n\n\n\n\n\nFloodAdapt.run_benefit(name: str | list[str])\nRun the benefit assessment.\n\n\n\nname : str | list[str]\n\nThe name of the benefit object to run.\n\n\n\n\n\n\nFloodAdapt.run_scenario(scenario_name: str | list[str])\nRun a scenario hazard and impacts.\n\n\n\nscenario_name : str | list[str]\n\nname(s) of the scenarios to run.\n\n\n\n\n\n\n: RuntimeError\n\nIf an error occurs while running one of the scenarios\n\n\n\n\n\n\nFloodAdapt.save_benefit(benefit: Benefit, overwrite: bool = False)\nSave a benefit object to the database.\n\n\n\nbenefit : Benefit\n\nThe benefit object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing benefit with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the benefit object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_event(event: Event, overwrite: bool = False)\nSave an event object to the database.\n\n\n\nevent : Event\n\nThe event object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing event with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the event object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_flood_animation(\n    scenario: str,\n    bbox: list[float] | None = None,\n    zoomlevel: int = 15,\n)\nCreate an animation of the flood extent over time.\nProduced floodmap is in the units defined in the sfincs config settings.\n\n\n\nscenario : str\n\nName of the scenario for which to create the floodmap.\n\nbbox : list[float] = None\n\nBounding box to limit the animation to a specific area (default is None, which means no bounding box). Format: [lon_min, lat_min, lon_max, lat_max]\n\nzoomlevel : int = 15\n\nZoom level for the animation (default is 15).\n\n\n\n\n\n\nFloodAdapt.save_measure(measure: Measure, overwrite: bool = False)\nSave a measure object to the database.\n\n\n\nmeasure : Measure\n\nThe measure object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing measure with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the measure object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_projection(projection: Projection, overwrite: bool = False)\nSave a projection object to the database.\n\n\n\nprojection : Projection\n\nThe projection object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing projection with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the projection object is not valid.\n\n\n\n\n\n\nFloodAdapt.save_scenario(scenario: Scenario, overwrite: bool = False)\nSave the scenario to the database.\n\n\n\nscenario : Scenario\n\nThe scenario to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing scenario with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the scenario object is not valid or if it already exists and overwrite is False.\n\n\n\n\n\n\nFloodAdapt.save_strategy(strategy: Strategy, overwrite: bool = False)\nSave a strategy object to the database.\n\n\n\nstrategy : Strategy\n\nThe strategy object to save.\n\noverwrite : bool = False\n\nWhether to overwrite an existing strategy with the same name (default is False).\n\n\n\n\n\n\n: DatabaseError\n\nIf the strategy object is not valid. If the strategy object already exists.",
    "crumbs": [
      "API Reference",
      "FloodAdapt",
      "FloodAdapt"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/FiatModel.html",
    "href": "3_api_docs/api_ref/FiatModel.html",
    "title": "FiatModel",
    "section": "",
    "text": "config.FiatModel()\nThe expected variables and data types of attributes of the Fiat class.\n\n\n\nrisk : Optional[RiskModel]\n\nConfiguration of probabilistic risk runs. default=None\n\nconfig : FiatConfigModel\n\nConfiguration for the FIAT model.\n\nbenefits : Optional[BenefitsModel]\n\nConfiguration for running benefit calculations. default=None"
  },
  {
    "objectID": "3_api_docs/api_ref/FiatModel.html#attributes",
    "href": "3_api_docs/api_ref/FiatModel.html#attributes",
    "title": "FiatModel",
    "section": "",
    "text": "risk : Optional[RiskModel]\n\nConfiguration of probabilistic risk runs. default=None\n\nconfig : FiatConfigModel\n\nConfiguration for the FIAT model.\n\nbenefits : Optional[BenefitsModel]\n\nConfiguration for running benefit calculations. default=None"
  },
  {
    "objectID": "3_api_docs/api_ref/EventSet.html",
    "href": "3_api_docs/api_ref/EventSet.html",
    "title": "EventSet",
    "section": "",
    "text": "objects.EventSet()\nBaseModel describing the expected variables and data types for parameters of EventSet.\nAn EventSet is a collection of events that can be used to create a scenario and perform a probabilistic risk assessment.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path."
  },
  {
    "objectID": "3_api_docs/api_ref/EventSet.html#attributes",
    "href": "3_api_docs/api_ref/EventSet.html#attributes",
    "title": "EventSet",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set."
  },
  {
    "objectID": "3_api_docs/api_ref/EventSet.html#methods",
    "href": "3_api_docs/api_ref/EventSet.html#methods",
    "title": "EventSet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path."
  },
  {
    "objectID": "3_api_docs/api_ref/Event.html",
    "href": "3_api_docs/api_ref/Event.html",
    "title": "Event",
    "section": "",
    "text": "objects.Event()\nThe accepted input for an event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_equivalent\nDeep-compare two events, including forcing data contents.\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.data_equivalent(other: Event)\nDeep-compare two events, including forcing data contents.\nCompares core attributes (time, template, mode, rainfall_multiplier) and then verifies that each forcing (by type) has the same data fingerprint. For path-based forcings, the fingerprint hashes the file bytes; for others, a canonical attribute-based hash is used.\n\n\n\nother : Event\n\nThe event to compare against.\n\n\n\n\n\n\n : bool\n\nTrue when events are equivalent in terms of their hazard inputs.\n\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event."
  },
  {
    "objectID": "3_api_docs/api_ref/Event.html#attributes",
    "href": "3_api_docs/api_ref/Event.html#attributes",
    "title": "Event",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event.\n\nmode : Mode\n\nThe mode of the event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "3_api_docs/api_ref/Event.html#methods",
    "href": "3_api_docs/api_ref/Event.html#methods",
    "title": "Event",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_equivalent\nDeep-compare two events, including forcing data contents.\n\n\nget_forcings\nReturn a list of all forcings in the event.\n\n\nsave_additional\nSave any additional files associated with the event.\n\n\n\n\n\nobjects.Event.data_equivalent(other: Event)\nDeep-compare two events, including forcing data contents.\nCompares core attributes (time, template, mode, rainfall_multiplier) and then verifies that each forcing (by type) has the same data fingerprint. For path-based forcings, the fingerprint hashes the file bytes; for others, a canonical attribute-based hash is used.\n\n\n\nother : Event\n\nThe event to compare against.\n\n\n\n\n\n\n : bool\n\nTrue when events are equivalent in terms of their hazard inputs.\n\n\n\n\n\n\nobjects.Event.get_forcings()\nReturn a list of all forcings in the event.\n\n\n\nobjects.Event.save_additional(output_dir: Path | str | os.PathLike)\nSave any additional files associated with the event."
  },
  {
    "objectID": "3_api_docs/api_ref/Elevate.html",
    "href": "3_api_docs/api_ref/Elevate.html",
    "title": "Elevate",
    "section": "",
    "text": "objects.Elevate()\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/Elevate.html#attributes",
    "href": "3_api_docs/api_ref/Elevate.html#attributes",
    "title": "Elevate",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/DatumModel.html",
    "href": "3_api_docs/api_ref/DatumModel.html",
    "title": "DatumModel",
    "section": "",
    "text": "config.DatumModel()\nThe accepted input for the variable datums in WaterlevelReferenceModel.\n\n\n\nname : str\n\nThe name of the vertical reference model.\n\nheight : us.UnitfulLength\n\nThe height of the vertical reference model relative to the main reference."
  },
  {
    "objectID": "3_api_docs/api_ref/DatumModel.html#attributes",
    "href": "3_api_docs/api_ref/DatumModel.html#attributes",
    "title": "DatumModel",
    "section": "",
    "text": "name : str\n\nThe name of the vertical reference model.\n\nheight : us.UnitfulLength\n\nThe height of the vertical reference model relative to the main reference."
  },
  {
    "objectID": "3_api_docs/api_ref/CurrentSituationModel.html",
    "href": "3_api_docs/api_ref/CurrentSituationModel.html",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "objects.CurrentSituationModel()\nThe accepted input for a current situation in FloodAdapt.\n\n\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation."
  },
  {
    "objectID": "3_api_docs/api_ref/CurrentSituationModel.html#attributes",
    "href": "3_api_docs/api_ref/CurrentSituationModel.html#attributes",
    "title": "CurrentSituationModel",
    "section": "",
    "text": "projection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nyear : int\n\nThe year of the current situation."
  },
  {
    "objectID": "3_api_docs/api_ref/ConfigModel.html",
    "href": "3_api_docs/api_ref/ConfigModel.html",
    "title": "ConfigModel",
    "section": "",
    "text": "database_builder.ConfigModel()\nMain configuration model for FloodAdapt database builder.\n\n\n\nname : str\n\nName of the site (must be valid for folder names).\n\ndescription : Optional[str]\n\nDescription of the site.\n\ndatabase_path : Optional[str]\n\nPath to the database root directory.\n\nunit_system : UnitSystems\n\nUnit system for all calculations (imperial or metric).\n\nis_coastal : Optional[bool] = None\n\nIndicates whether the site is coastal.\n\ngui : GuiConfigModel\n\nGUI visualization scaling configuration.\n\ninfographics : bool\n\nEnable/disable infographics.\n\nevent_infographics : Optional[EventInfographicModel]\n\nConfiguration for event infographics.\n\nrisk_infographics : Optional[RiskInfographicModel]\n\nConfiguration for risk infographics.\n\nevent_additional_infometrics : Optional[list[MetricModel]]\n\nAdditional event infometrics.\n\nrisk_additional_infometrics : Optional[list[MetricModel]]\n\nAdditional risk infometrics.\n\nfiat : str\n\nPath to the FIAT model directory.\n\naggregation_areas : Optional[list[SpatialJoinModel]]\n\nList of aggregation area spatial join models.\n\nbuilding_footprints : Optional[SpatialJoinModel | FootprintsOptions]\n\nBuilding footprints source or spatial join model.\n\nfiat_buildings_name : str | list[str]\n\nName(s) of buildings geometry in FIAT model.\n\nfiat_roads_name : Optional[str]\n\nName of roads geometry in FIAT model.\n\nbfe : Optional[SpatialJoinModel]\n\nBase Flood Elevation spatial join model.\n\nsvi : Optional[SviConfigModel]\n\nSocial Vulnerability Index spatial join model.\n\nroad_width : us.UnitfulLength\n\nRoad width (default 5 meters).\n\nreturn_periods : Optional[list[int]]\n\nList of return periods for risk calculations.\n\nfloodmap_type : Optional[FloodmapType]\n\nType of floodmap to use.\n\nreferences : Optional[WaterlevelReferenceModel]\n\nWater level reference model.\n\nsfincs_overland : FloodModel\n\nOverland SFINCS model configuration.\n\nsfincs_offshore : Optional[FloodModel]\n\nOffshore SFINCS model configuration.\n\ndem : Optional[DemModel]\n\nDigital Elevation Model configuration.\n\nriver_names : Optional[list[str]]\n\nList of river names (optional).\n\nexcluded_datums : list[str]\n\nList of datums to exclude from plotting.\n\nslr_scenarios : Optional[SlrScenariosModel]\n\nSea level rise scenarios configuration.\n\nscs : Optional[SCSModel]\n\nSCS model configuration.x\n\ntide_gauge : Optional[TideGaugeConfigModel]\n\nTide gauge configuration.\n\ncyclones : Optional[bool]\n\nEnable/disable cyclones.\n\ncyclone_basin : Optional[Basins]\n\nCyclone basin selection.\n\nobs_point : Optional[list[ObsPointModel]]\n\nList of observation point models.\n\nprobabilistic_set : Optional[str]\n\nPath to probabilistic event set.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nread\nRead a configuration file and returns the validated attributes.\n\n\nwrite\nWrite the configuration model to a TOML file.\n\n\n\n\n\ndatabase_builder.ConfigModel.read(toml_path: Union[str, Path])\nRead a configuration file and returns the validated attributes.\nArgs: toml_path (str | Path): The path to the configuration file.\n\n\n\n : ConfigModel: The validated attributes from the configuration file.\n\n\n\n\n\n\n\n\ndatabase_builder.ConfigModel.write(toml_path: Path)\nWrite the configuration model to a TOML file.\n\n\n\ntoml_path : Path\n\nThe path to the TOML file where the configuration will be saved.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "ConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/ConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/ConfigModel.html#attributes",
    "title": "ConfigModel",
    "section": "",
    "text": "name : str\n\nName of the site (must be valid for folder names).\n\ndescription : Optional[str]\n\nDescription of the site.\n\ndatabase_path : Optional[str]\n\nPath to the database root directory.\n\nunit_system : UnitSystems\n\nUnit system for all calculations (imperial or metric).\n\nis_coastal : Optional[bool] = None\n\nIndicates whether the site is coastal.\n\ngui : GuiConfigModel\n\nGUI visualization scaling configuration.\n\ninfographics : bool\n\nEnable/disable infographics.\n\nevent_infographics : Optional[EventInfographicModel]\n\nConfiguration for event infographics.\n\nrisk_infographics : Optional[RiskInfographicModel]\n\nConfiguration for risk infographics.\n\nevent_additional_infometrics : Optional[list[MetricModel]]\n\nAdditional event infometrics.\n\nrisk_additional_infometrics : Optional[list[MetricModel]]\n\nAdditional risk infometrics.\n\nfiat : str\n\nPath to the FIAT model directory.\n\naggregation_areas : Optional[list[SpatialJoinModel]]\n\nList of aggregation area spatial join models.\n\nbuilding_footprints : Optional[SpatialJoinModel | FootprintsOptions]\n\nBuilding footprints source or spatial join model.\n\nfiat_buildings_name : str | list[str]\n\nName(s) of buildings geometry in FIAT model.\n\nfiat_roads_name : Optional[str]\n\nName of roads geometry in FIAT model.\n\nbfe : Optional[SpatialJoinModel]\n\nBase Flood Elevation spatial join model.\n\nsvi : Optional[SviConfigModel]\n\nSocial Vulnerability Index spatial join model.\n\nroad_width : us.UnitfulLength\n\nRoad width (default 5 meters).\n\nreturn_periods : Optional[list[int]]\n\nList of return periods for risk calculations.\n\nfloodmap_type : Optional[FloodmapType]\n\nType of floodmap to use.\n\nreferences : Optional[WaterlevelReferenceModel]\n\nWater level reference model.\n\nsfincs_overland : FloodModel\n\nOverland SFINCS model configuration.\n\nsfincs_offshore : Optional[FloodModel]\n\nOffshore SFINCS model configuration.\n\ndem : Optional[DemModel]\n\nDigital Elevation Model configuration.\n\nriver_names : Optional[list[str]]\n\nList of river names (optional).\n\nexcluded_datums : list[str]\n\nList of datums to exclude from plotting.\n\nslr_scenarios : Optional[SlrScenariosModel]\n\nSea level rise scenarios configuration.\n\nscs : Optional[SCSModel]\n\nSCS model configuration.x\n\ntide_gauge : Optional[TideGaugeConfigModel]\n\nTide gauge configuration.\n\ncyclones : Optional[bool]\n\nEnable/disable cyclones.\n\ncyclone_basin : Optional[Basins]\n\nCyclone basin selection.\n\nobs_point : Optional[list[ObsPointModel]]\n\nList of observation point models.\n\nprobabilistic_set : Optional[str]\n\nPath to probabilistic event set.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "ConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/ConfigModel.html#methods",
    "href": "3_api_docs/api_ref/ConfigModel.html#methods",
    "title": "ConfigModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nread\nRead a configuration file and returns the validated attributes.\n\n\nwrite\nWrite the configuration model to a TOML file.\n\n\n\n\n\ndatabase_builder.ConfigModel.read(toml_path: Union[str, Path])\nRead a configuration file and returns the validated attributes.\nArgs: toml_path (str | Path): The path to the configuration file.\n\n\n\n : ConfigModel: The validated attributes from the configuration file.\n\n\n\n\n\n\n\n\ndatabase_builder.ConfigModel.write(toml_path: Path)\nWrite the configuration model to a TOML file.\n\n\n\ntoml_path : Path\n\nThe path to the TOML file where the configuration will be saved.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "ConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/BuildingsInfographicModel.html",
    "href": "3_api_docs/api_ref/BuildingsInfographicModel.html",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "database_builder.BuildingsInfographicModel()\nModel for building infographic configuration.\n\n\n\ntypes : list[str]\n\nList of building types.\n\nicons : list[str]\n\nList of icon names corresponding to each building type.\n\ntype_mapping : dict[str, TypeMapping]\n\nMapping of building types to their database filtering criteria.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for building infographics.\n\n\nvalidate_icons_length\nValidate that icons list length matches types list length.\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n)\nGet a pre-configured template for building infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\n\n\n\n\n\n : BuildingsInfographicModel\n\nPre-configured building infographic model.\n\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.validate_icons_length(icons, info)\nValidate that icons list length matches types list length.\n\n\n\nicons : list[str]\n\nList of icon names.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated icons list.\n\n\n\n\n\n\n: ValueError\n\nIf icons length doesn‚Äôt match types length."
  },
  {
    "objectID": "3_api_docs/api_ref/BuildingsInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/BuildingsInfographicModel.html#attributes",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "types : list[str]\n\nList of building types.\n\nicons : list[str]\n\nList of icon names corresponding to each building type.\n\ntype_mapping : dict[str, TypeMapping]\n\nMapping of building types to their database filtering criteria.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration."
  },
  {
    "objectID": "3_api_docs/api_ref/BuildingsInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/BuildingsInfographicModel.html#methods",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for building infographics.\n\n\nvalidate_icons_length\nValidate that icons list length matches types list length.\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n)\nGet a pre-configured template for building infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\n\n\n\n\n\n : BuildingsInfographicModel\n\nPre-configured building infographic model.\n\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.validate_icons_length(icons, info)\nValidate that icons list length matches types list length.\n\n\n\nicons : list[str]\n\nList of icon names.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated icons list.\n\n\n\n\n\n\n: ValueError\n\nIf icons length doesn‚Äôt match types length."
  },
  {
    "objectID": "3_api_docs/api_ref/BenefitsLayer.html",
    "href": "3_api_docs/api_ref/BenefitsLayer.html",
    "title": "BenefitsLayer",
    "section": "",
    "text": "BenefitsLayer\nconfig.BenefitsLayer()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/Basins.html",
    "href": "3_api_docs/api_ref/Basins.html",
    "title": "Basins",
    "section": "",
    "text": "database_builder.Basins()\nEnumeration of global cyclone basins.\n\n\nNA : North Atlantic SA : South Atlantic EP : Eastern North Pacific (includes Central Pacific) WP : Western North Pacific SP : South Pacific SI : South Indian NI : North Indian",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Basins"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Basins.html#values",
    "href": "3_api_docs/api_ref/Basins.html#values",
    "title": "Basins",
    "section": "",
    "text": "NA : North Atlantic SA : South Atlantic EP : Eastern North Pacific (includes Central Pacific) WP : Western North Pacific SP : South Pacific SI : South Indian NI : North Indian",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Basins"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/AggregationDmgLayer.html",
    "href": "3_api_docs/api_ref/AggregationDmgLayer.html",
    "title": "AggregationDmgLayer",
    "section": "",
    "text": "AggregationDmgLayer\nconfig.AggregationDmgLayer()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "2_technical_docs/dem.html",
    "href": "2_technical_docs/dem.html",
    "title": "Updating the DEM",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "2_technical_docs/EventScenario.html",
    "href": "2_technical_docs/EventScenario.html",
    "title": "Event scenario",
    "section": "",
    "text": "The FloodAdapt calculation framework to calculate flooding and impacts for an event scenario will be described here, first for the flooding (hazard calculation) and then for the impact calculation.\nThe calculation framework includes the open-source, process-based compound flood model SFINCS that can accurately predict compound flooding due to tide, surge, rainfall, and river discharge, at a fraction of the computation time typically required by physics-based models. It also includes the open-source flood impact assessment tool Delft-FIAT which rapidly calculates flood damages to individual buildings and roads. When FloodAdapt is set up in a new location, baseline SFINCS and Delft-FIAT models must be set up as part of that process. FloodAdapt then updates these baseline models to reflect user-defined scenarios, runs the simulations, and post-processes the output to make the evaluation of the scenario as easy as possible for the user. The FloodAdapt setup guide provides guidance for setting up these baseline models: click the links to view the SFINCS setup guide and Delft-FIAT setup guide.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/EventScenario.html#hazard-calculation",
    "href": "2_technical_docs/EventScenario.html#hazard-calculation",
    "title": "Event scenario",
    "section": "Hazard calculation",
    "text": "Hazard calculation\nThrough the use of the FloodAdapt user interface, users enter information on (1) a hydrometeorological event, (2) a projection of future conditions, and (3) a strategy composed of adaptation measures. These three ‚Äòingredients‚Äô define an event scenario. FloodAdapt uses this information to initiate the workflow to calculate flooding and impacts for the event scenario. Figure¬†1 zooms in on the hazard calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.\nIn FloodAdapt there is the option to include two SFINCS models - an ‚Äúoffshore‚Äù model and an ‚Äúoverland‚Äù model. The offshore model is typically a coarser model with an offshore domain adjacent to the area of interest. It is forced by astronomic tide and wind, pressure, and precipitation fields, and calculates nearshore water level time series that serve as boundary conditions for the overland model. The overland model is typically finer resolution and its domain is a hydrological area over land that includes the project area of interest. Only the overland model is strictly necessary in FloodAdapt, but some event types will not be possible without an offshore model, most notably hurricanes.\n\n\n\n\n\n\nFigure¬†1: Hazard calculation framework for an event scenario\n\n\n\nThe hydro-meteorological event is defined by an ‚Äúevent type‚Äù. This is either (1) a historical hurricane, (2) a historical non-hurricane, or (3) a synthetic event. For a historical non-hurricane, there are further two options - (2a) the user has nearshore observed time series of coastal water levels, or (2b) the user does not have observed time series and needs to run an offshore model to generate the nearshore water level time series. Each of these four types has a unique workflow for calculating the overland flooding, which will be described in the coming paragraphs.\nWhat is common to all the overland flooding workflows is the handling of adaptation measures. There are three measure types in FloodAdapt that affect the flood modeling: (1) levee or floodwall, (2) pump, and (3) urban green infrastructure. All of these choices initiate modifications to the overland SFINCS model schematization. When users specify a levee or floodwall as an adaptation measure, FloodAdapt coordinates the updating of the ‚Äúweir‚Äù file in the SFINCS overland model. This file contains coordinates of linear features and their elevation, and serve to block flow in the overland model up to the specified height of the floodwall or levee. The FloodAdapt user interfaces allows users to click a polyline on a map, or import a polyline, and then uses the specifications (location and elevation) to update the weir file. When users specify a pump as (part of) an adaptation measure, FloodAdapt coordinates the updating of the ‚Äúdrn‚Äù (drainage) file in the SFINCS overland model. This file contains the coordinates of the intake and outfall locations and the pump capacity. When a user specifies green infrastructure as a measure, FloodAdapt coordinates the creation or updating of a storage volume input for the SFINCS overland model, based on the green infrastructure area and storage specified. SFINCS ‚Äòstores‚Äô this water volume (defined per cell) before any overland flooding takes place.\nFor historical hurricanes, the track information is pulled by the user interface from the National Hurricane Center HURDAT2 database. The first step in the workflow is to translate the track information, like maximum wind speeds and radius, into the wind, pressure, and precipitation fields needed by the offshore SFINCS model. The wind and pressure fields are generated using the Holland 2010 method and the rainfall field is generated using the IPET method. This translation is done by an open-source python package called the Coastal Hazard Toolkit - Cyclone, or CHT-cyclone. The astronomic tidal boundary for the offshore SFINCS model is obtained using another CHT package called CHT-tide. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The wind, pressure, and precipitation fields and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels (tide + surge). The input to the SFINCS overland model includes the simulated nearshore water level time series, the wind, pressure, and precipitation fields generated from the track, and any river discharge time series specified by the user in the user interface (when rivers are present in the site). It is also possible in FloodAdapt for a user to ‚Äúturn off‚Äù the rainfall in the overland model, for example to explore the difference in flooding with and without the inclusion of rainfall. Using these inputs, the SFINCS overland model is run and the resulting maximum flood depth maps are returned. Additionally, if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured, water level time series will be saved for these locations.\nFor a historical event without observed nearshore water levels, FloodAdapt orchestrates the downloading of gridded wind, pressure, and precipitation data from the NOAA global forecasting system reanalysis data. These data are available at a spatial resolution of 0.5 degrees for dates prior to February 2021, and 0.25 degrees after. The downloading and formatting of these data are done with the Coastal Hazard Toolkit package CHT-meteo. If the user has specified sea level rise in their scenario future-conditions projection, that sea level rise will be added to the tidal levels. The gridded wind, pressure, and precipitation data and the tidal levels are then input into the offshore SFINCS model which generates time series of nearshore water levels. For this event type, users are able to specify rainfall, wind, and river discharge inputs for the overland flood model. These values, together with the simulated nearshore water levels are input into the overland flood model which outputs maximum flood depth maps and - if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.\n\n\n\n\n\n\nNoteSea level offset for offshore simulations\n\n\n\nFor hazard simulations that use the offshore SFINCS model, the nearshore water levels are returned relative to mean sea level. However, sea levels have risen since the mean sea level was set for the 1983-2001 epoch. This discrepancy results in predicted/simulated nearshore water levels that are lower than what would be observed at a tide gauge. Trend analysis can be done to determine an appropriate level of ‚Äúoffset‚Äù to correct mean sea level to present day conditions. This value is set in the FloodAdapt site configuration file, and can be modified by an advanced user. The offset is applied in the workflow where the future-condition sea level rise is added. This is only done for offshore events, because nearshore gauged data represent observed water levels and will already include sea level increases in the measurements. Similarly, for synthetic events, it is assumed that users will select a nearshore water level of interest, and any sea level rise of interest will be captured as a projection relative to current conditions.\n\n\n\n\n\n\n\n\nNoteVertical datum references in the offshore and overland models\n\n\n\nIf there is a difference in vertical datum between the offshore and overland model, FloodAdapt automatically corrects the water level time series output from the offshore model to the datum used in the overland model prior to running the overland model.\n\n\nFor a historical event with observed nearshore water levels, FloodAdapt offers the user the choice to upload their own time series data of nearshore water levels, or the user can specify a start and stop time of the event and click the ‚ÄòDownload water levels button‚Äô which downloads the time series data from the NOAA website. More details about this and how users can specify or import rainfall, wind, and river discharge data for the event are provided in the user manual here. If the user has specified sea level rise in their scenario future-conditions projection, it will be added to the specified nearshore water levels at this point in the workflow prior to running the overland model. For this event type, only the SFINCS overland model needs to be run. The water level time series, rainfall, wind, and river discharge inputs are used to force the overland model, which then outputs maximum flood depth maps and - if ‚Äúobservation points‚Äù have been specified when the FloodAdapt system was configured - water level time series will be saved for these locations.\nFor a synthetic event, the workflow to derive the flood map and simulated water level time series at observation points is identical to the workflow for the historical event with observed nearshore water levels. It only differs in terms of the specification of the forcing data. To see more details on how users can specify synthetic events in the user manual here.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/EventScenario.html#impact-calculation",
    "href": "2_technical_docs/EventScenario.html#impact-calculation",
    "title": "Event scenario",
    "section": "Impact calculation",
    "text": "Impact calculation\nOnce a hazard calculation is complete, FloodAdapt initiates the impact calculation, making use of the simulated flood depth map. Figure¬†2 zooms in on the impact calculation portion of the FloodAdapt workflow for an event scenario. Referring to the figure can support the description of the calculation.\nIn the user interface, the user is able to specify impact-related future conditions (economic growth and/or population growth) and impact-reducing adaptation options: buyout, elevate, and floodproof. The user manual describes how a user can specify impact-related projections here and impact-reducting adaptation options here. When a scenario is created containing any of these features it initiates a modification of the baseline Delft-FIAT model.\n\n\n\n\n\n\nFigure¬†2: Impact calculation framework for an event scenario\n\n\n\nThere are three impact-reducing adaptation measures in FloodAdapt that affect the impact model schematization: (1) buyouts (2) elevate, and (3) floodproof. These are all measures taken at the building level. When users specify a buyout measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù, setting them both to zero for buildings selected for buyout. This ensures that these buildings no longer accrue any damage during flood events. When users specify an elevate measure, FloodAdapt coordinates the updating of the Delft-FIAT exposure data attribute ‚Äúfinished floor height‚Äù, setting it to the user-specified height. Users are able to elevate buildings to a specified height above base flood elevation (BFE) if they have included a BFE map during system setup. In this case, FloodAdapt calculates the elevation of the finished floor using the BFE and specified height above BFE, and then subtracts the ground elevation at the building location to determine the required finished floor height. The ground elevation is an attribute of the building in the Delft-FIAT exposure data (which should be aligned with the DEM used in the flood model, something that is arranged during system setup). When users specify a floodproofing measure, FloodAdapt coordinates the updating of the depth-damage curves for the buildings selected for floodproofing. It sets the damage fraction to zero in the depth-damage curve up to the floodpoofing height. After that height, the depth-damage curve resumes its original shape.\nFuture socio-economic projections also initiate updating of the Delft-FIAT model. Users can choose economic growth or population growth. For population growth there are two options: (1) the population increases in the current built area or (2) population increases in currently undeveloped areas. For the former, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù by the percentage population increase specified. The idea is that the building stock density will increase, and hence also the potential damages during flood events. For population growth in currently-undeveloped areas, FloodAdapt coordinates the creation of a hybrid exposure asset with the footprint of the specified to-be-developed area. The attributes of this hybrid asset are a weighted average of the existing exposed assets, meaning the new area is assumed to reflect the make-up (in terms of building types) of the existing built area. This method was implemented to evaluate future development and assess how it will contribute to risk in the future. The method allows for users to specify the finished floor height of the new development buildings, helping to provide a foundation for ordinances on new development heights. NOTE: the ‚Äúpopulation growth in new development areas‚Äù feature is under-tested and is considered by the FloodAdapt development team to be in need of improvements before it reaches its potential. When users enter a percentage for economic growth, FloodAdapt coordinates a simplified representation by increasing the Delft-FIAT exposure data attributes ‚Äúmaximum potential damages - structure‚Äù and ‚Äúmaximum potential damages - content‚Äù by the percentage economic growth specified.\nOnce the Delft-FIAT model schematization has been updated, FloodAdapt coordinates the running of Delft-FIAT with the simulated flood depth map from the hazard calculation. The calculation method of Delft-FIAT follows a standard approach and is described in the Delft-FIAT github documentation and in the Delft-FIAT setup documentation. Figure¬†3 shows conceptually how Delft-FIAT calculates damages. Note that no indirect damages are calculated with Delft-FIAT, only direct damages to assets in the exposure dataset.\n\n\n\n\n\n\nFigure¬†3: Overview of the calculation method in Delft-FIAT\n\n\n\nThe impact calculation returns inundation depths and economic damages for every asset in the Delft-FIAT model. These results are passed through a post-processing toolkit. This aggregates the damages to aggregation levels specified during system setup, creates vector files of impacts, and generates the FloodAdapt infographic and metrics.\nTo read more about the output from an event scenario calculation, please see the user manual section on Output here.",
    "crumbs": [
      "Event scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/BenefitCalc.html",
    "href": "2_technical_docs/BenefitCalc.html",
    "title": "Benefit Calculation",
    "section": "",
    "text": "Flood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits. The user guide section on benefits provides comprehensive guidance on preparing and evaluating benefits in FloodAdapt. This technical documentation is limited to the description of the benefit calculation.\nThe benefit calculation uses output from four scenarios:\n\nThe risk without the strategy implemented in current conditions\nThe risk with the strategy implemented in current conditions\nThe risk without the strategy implemented in future conditions\nThe risk with the strategy implemented in future conditions\n\nWhen a user runs a benefit analysis in FloodAdapt, the following benefit calculations are carried out:\n\nThe risk-reduction benefit under current conditions is calculated as the difference in the risk without the strategy and with the strategy under the ‚Äúcurrent‚Äù projection (representing current conditions).\nThe risk-reduction benefit under future conditions (for the year specified in the end-of-analysis situation) is calculated as the difference in the risk without the strategy and with the strategy under the future projection specified in the end-of-analysis situation when you created your benefit analysis.\nThe annual risk-reduction benefits are calculated by linearly interpolating between the risk-reduction benefits under current conditions (in the current year) and the risk-reduction benefits under future conditions (in the end-of-analysis year).\nThe annual discounted benefits (\\(B_d(t)\\)) are calculated as\n\\(B_d\\ (t)=B(t)/(1+r)^t\\ \\)\nwhere \\(B(t)\\) is the risk-reduction benefit in year \\(t\\), \\(t\\) is the year since implementation, and \\(r\\) is the discount rate.\nThe (present value of the) benefits are calculated as the sum of the annual discounted benefits over the analysis duration (\\(N\\) years).\n\\(Benefits\\ =\\ \\sum_{t=0}^N B_d\\ (t)\\ \\)\n\nWhen cost information is provided, FloodAdapt additionally calculates:\n\nThe (present value of the) costs - calculated only when implementation and/or maintenance costs are provided in the benefit analysis input. This is calculated in the same way as the present value of the benefits: \\(Costs\\ =\\ \\sum_{t=0}^N C_d\\ (t)\\ \\)\nwhere \\(C_d(t)\\) is the discounted cost in year \\(t\\).\nThe benefit-cost ratio (BCR) is calculated as the present value of the benefits divided by the present value of the costs.\nThe net present value (NPV) is the difference in annual discounted benefits and costs, summed up over the analysis period.\n\\(NPV\\ =\\ \\sum_{t=0}^N [(B(t)-C(t))/(1+r)^t]\\ \\)\nThe internal rate of return (IRR) represents the discount rate at which the NPV would be equal to zero. Higher IRR indicates a better investment, because in this case the benefits weigh strongly against the costs.\n\n\n\n\n\n\n\nWarningSome metrics are only calculated when cost information is provided!\n\n\n\nThe present value of the costs, benefit cost ratio, net present value, and internal rate of return are only calculated if the user has provided information on implementation and/or maintenance costs when they created their benefit analysis. When this information is not provided, the benefits are calculated, but none of the metrics that require comparison with costs.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Benefit Calculation"
    ]
  },
  {
    "objectID": "1_user_guide/site_tab.html",
    "href": "1_user_guide/site_tab.html",
    "title": "Site tab",
    "section": "",
    "text": "Don‚Äôt feel like reading? No problem! Check out our video about the FloodAdapt site tab: \nThe user interface opens by default to the Site tab, shown for the example of Charleston, South Carolina in Figure¬†1. The site tab shows the aggregation areas that have been defined for the site. If more than one type of aggregation area has been defined, the user can select which one they want to view from the drop-down box ‚ÄòAggregation Areas Type‚Äô. Examples of aggregation area types are census blocks, neighborhoods, or zip codes. The ‚ÄòAggregation Areas‚Äô box populates with the different areas for the selected aggregation type. The user can hover over an area and see the name of that area. Similarly, they can select an area of the ‚ÄòAggregation Areas‚Äô list and that area will become highlighted on the map.\n\n\n\n\n\n\nFigure¬†1: The site tab, shown here for the example of Charleston, South Carolina\n\n\n\nThe site tab also shows the extent of the flood model. This can be substantially larger than the area of interest. If a user zooms out they can see the extent of the area, as show in Figure¬†2\n\n\n\n\n\n\nFigure¬†2: The site tab, zoomed out to show the full flood model extent (in red)\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Site tab"
    ]
  },
  {
    "objectID": "1_user_guide/scenario_results/single_event.html",
    "href": "1_user_guide/scenario_results/single_event.html",
    "title": "Single-event scenario output",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_user_guide/scenario_results/event_set.html",
    "href": "1_user_guide/scenario_results/event_set.html",
    "title": "Event-set (probabilistic risk) scenario output",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_user_guide/projections/index.html",
    "href": "1_user_guide/projections/index.html",
    "title": "Projections",
    "section": "",
    "text": "FloodAdapt can simulate future climate and socio-economic conditions.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt can simulate future climate projections - sea level rise, increased tropical storm frequencies, precipitation changes, and socio-economic projections - population growth and economic growth\n\n\n\nOn the Projections Tab in FloodAdapt, click ‚ÄòAdd Projection‚Äô to open the projections window (see Figure¬†2)\n\n\n\n\n\n\nFigure¬†2: Projections window on the Projections tab in FloodAdapt\n\n\n\nIn this window you can specify a climate projection, a socio-economic projection, or a combination (for example: 10% population growth with 1 foot of SLR).\nClick the following links to learn more about how climate and socio-economic projections can be specified in FloodAdapt, and how they are represented in the modeling.\nClimate projections\nSocio-economic projections\n\n\n\n Back to top",
    "crumbs": [
      "Projections"
    ]
  },
  {
    "objectID": "1_user_guide/output/index.html",
    "href": "1_user_guide/output/index.html",
    "title": "Output",
    "section": "",
    "text": "The FloodAdapt Output tab displays flood and impact maps, time series of water levels at observation points, a tabulated summary of metrics, and a visual infographic for simulated scenarios to help users understand and evaluate their scenarios. The output for event scenarios and risk scenarios differs slightly, but output for both types of scenarios is accessible from the Output tab. FloodAdapt additionally places scenario output locally on your computer in an Output folder within your FloodAdapt database.",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "1_user_guide/output/index.html#floodadapt-output-tab",
    "href": "1_user_guide/output/index.html#floodadapt-output-tab",
    "title": "Output",
    "section": "FloodAdapt output tab",
    "text": "FloodAdapt output tab\nThe Output tab has a map window and below it a panel (see Figure¬†1). The left section of the panel contains a scenario table with the scenarios that have been simulated. These can be sorted by name, date created, or by scenario components (event, projection, strategy). Selecting a scenario in this panel will load the output results for that scenario. The middle section of the panel contains different map visualization options, and the right section contains tabulated metrics. The collapsible frame on the Output tab can be used to view the scenario infographic (see Figure¬†2 and Figure¬†3). Note that the creation of the infographic is optional (specified at system setup). When an infographic is not configured for a site, the collapsible frame will display the documentation instead of the infographic.\n\n\n\n\n\n\nFigure¬†1: Output tab in FloodAdapt\n\n\n\n\n\n\n\n\n\nTipViewing the infographic\n\n\n\nThe infographic is visible in the map window‚Äôs collapsible frame. The user can view the infographic by clicking the little white triangle on the border of the frame to the right of the map window (see Figure¬†1).\n\n\n\nMetrics and infographic\nThe metrics and infographic will contain different information for a risk scenario and an event scenario. This information is configured separately for event scenarios and risk scenarios at system set-up (see information on how the infometrics and infographic are configured in the setup guide. Figure¬†2 shows an example of the infographic for an event scenario and Figure¬†3 shows an example of the infographic for a risk scenario. The basic structure of the infographic, highlighted in the figures, is fixed but the information within that structure can be tailored at system setup.\n\n\n\n\n\n\nFigure¬†2: Infographic for an event scenario\n\n\n\n\n\n\n\n\n\nFigure¬†3: Infographic for a risk scenario\n\n\n\n\n\nTime series at observation points\nIf observation points have been configured for a site (these are optional), the time series of modeled water levels at these points can be viewed by clicking on the observation points in the map window (see Figure¬†4). A graph window will pop up and show the modeled water level time series over the duration of the event. If one of the observation points is located at a water level gauge, the measured water levels will also be displayed. To make the time series popup disappear, click anywhere else in the map window.\n\n\n\n\n\n\nFigure¬†4: Time series of water levels at observation points\n\n\n\n\n\nMap visualization options for an event scenario\nWhen an event scenario is selected in the scenario panel, there are four map visualization options (see Figure¬†1). Clicking the check boxes next to any of these four options will display the corresponding layer in the map window.\n\nFlood map - shows the extent and depth of flooding for the scenario.\nBuilding damages - displayed as a heat map when zoomed out (this helps identify which areas are interesting to look at in more detail). Zooming in transitions the heat map to a display of building-level damages.\nAggregated damages - show the damages summed up over different areas, such as census blocks or neighborhoods. The areas will correspond to the aggregation areas that are shown in the site tab; these areas are specified at system setup. The aggregation drop-down menu to the right of the ‚ÄúAggregated damages‚Äù check box can be used to switch between different areas.\nRoad flooding - shows the water depth on the roads.\n\nIn addition to the four map layers, there is also the option to select an additional layer to view in the map window. This is found in the ‚ÄúShow Layer‚Äù drop-down menu. The specific layers available will depend on how the system was configured at setup, but could contain layers like income, social vulnerability index, or aggregation areas. These layers are often useful to visualize in combination with building level damages or flooding, to better understand who is being impacted in the scenario.\n\n\n\n\n\n\nNoteHow accurate are the building-level damages?\n\n\n\nThe building-level damages show what appear to be precise damage amounts; for example, a building could show $67,233 of damage. In reality, there is uncertainty around this estimate. The uncertainty stems from multiple sources including the accuracy of the flood map at the building location, the correctness of the depth-damage curve for the building, and the accuracy of the exposure data (such as building value or finished floor height). At this moment, uncertainty bands are not provided with the damage estimates in FloodAdapt, but it is important to be aware that these values are not as precisely known as they appear.\n\n\n\n\n\n\n\n\nTipKeeping things clean\n\n\n\nIt is possible to have all the map layers visible at the same time, but we recommend turning off the other layers when selecting aggregated damages. It makes for a cleaner map!\n\n\n\n\nMap visualization options for a risk scenario\nA risk scenario calculates return period flooding and damages, and also combines this information to calculate risk in terms of expected annual damages. The risk scenario map visualization options allow users to view both return period and risk output.\nWhen a risk scenario is selected, two radio buttons will appear: ‚ÄúReturn period‚Äù and ‚ÄúRisk‚Äù (see Figure¬†5). If you select ‚ÄúReturn period‚Äù, a drop-down window appears from which you can select a return period for which you want to view output. For individual return periods, the map visualization options are identical to those for the event scenario.\n\n\n\n\n\n\nFigure¬†5: Map visualization options for a risk scenario, showing both ‚Äòreturn period‚Äô options and ‚Äòrisk‚Äô options\n\n\n\nWhen the ‚ÄúRisk‚Äù radio button is selected (see Figure¬†5), two map layers can be viewed:\n\nBuilding damages - these damages represent the annual expected damages. When zoomed out this layer is displayed as a heat map (this helps identify which areas are interesting to look at in more detail). Zooming in transitions the heat map to a display of building-level expected annual damages.\nAggregated damages - this layer shows the expected annual damages (risk) summed up over different areas, such as census blocks or neighborhoods. The aggregation drop-down menu to the right of the ‚ÄúAggregated damages‚Äù check box can be used to switch between different areas.\n\nThere are a couple of special notes about the map visualization options for risk results compared to the return period or event scenario results:\n\nEquity weighting\nNext to the Risk radio button there is a checkbox ‚ÄúEquity-weighted‚Äù. Checking it allows users to see equity-weighted risk estimates. Equity weights are calculated in FloodAdapt using information on income. These weights are then multiplied by the damages to derive the equity-weighted risk estimates. This visualization is only available at the same scale for which income data is available. This will typically be census block level. Figure¬†6 shows the difference with and without equity weights, highlighting how it affects low-income and high-income neighborhoods. The low income neighborhoods are represented with blue stars and the high-income with yellow stars. Note that the equity-weighted risk for the low-income neighborhoods is higher than the risk when equity weights are not used.\nNo flood maps\nIn the case of risk results, the flood map and road flooding options are disabled because risk is a damage metric that is integrated over several different flood events, and does not correspond to any single flood event.\n\n\n\n\n\n\n\nFigure¬†6: Aggregated risk map, without equity weighting on the left and with equity weighting on the right. The yellow stars indicate high-income areas and the blue stars indicate low-income areas. The equity-weighted risk is higher for the low-income neighborhoods than without equity weighting, providing a more equitable interpretation of the risk burden for lower-income areas\n\n\n\nIn addition to the output map layers, there is also the option to select an additional layer to view in the map window. This is found in the ‚ÄúShow Layer‚Äù drop-down menu. The specific layers available will depend on how the system was configured at setup, but could contain layers like income, social vulnerability index, or aggregation areas. These layers are often useful to visualize in combination with building level (expected annual) damages, to better understand who is being impacted in the scenario.",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "1_user_guide/output/index.html#output-folder",
    "href": "1_user_guide/output/index.html#output-folder",
    "title": "Output",
    "section": "Output folder",
    "text": "Output folder\nThe output from a simulated scenario is saved on a user‚Äôs computer, aspiring to provide full access and transparency. This section will describe the output folder structure for both an event and a risk scenario.\n\n\n\n\n\n\nNoteWhere can I find the output folder?\n\n\n\nFigure¬†7 shows where the output folder is located within the FloodAdapt database. The database root directory could contain multiple site databases, for different locations, or even variations of databases for the same location. The output folder is located directly inside the site database folder.\n\n\n\n\n\n\nFigure¬†7: Location of the ‚Äúoutput‚Äù folder within the FloodAdapt folder structure\n\n\n\n\n\nThe output folders for the event scenarios and risk scenarios have mostly the same structure; they only differ in the output flood data. Figure¬†8 shows the output structure for an Event scenario and Figure¬†9 shows the output structure for a Risk scenario.\nThe output folder contains a subfolder named ‚Äúscenarios‚Äù. Within this subfolder you will find one folder for each scenario that has been simulated. The name of the folder will be the name of the scenario. Each scenario folder will contain two subfolders: ‚ÄúFlooding‚Äù and ‚ÄúImpacts‚Äù. It will also contain the infographic as an HTML file, a log file with details about the simulation, and the infometrics as CSV files; there will be one CSV for buildling-level metrics and one CSV per aggregation area (e.g.¬†neighborhood or census block group) with aggregated metrics.\nThe ‚ÄúImpacts‚Äù folder will contain multiple files:\n\nDetailed impacts (CSV file) with asset-level information on the assets and their impacts\nImpacts on the buildings, as a geopackage (GPKG) file.\nAggregated impacts, one GPKG file for each aggregation area (e.g.¬†neighborhoods or census block groups)\nImpacts on the roads (GPKG file). Note that these ‚Äúimpacts‚Äù are actually inundation depth on the roads.\n\n\n\n\n\n\n\nNoteInterpreting ‚ÄúImpacts‚Äù for a risk scenario\n\n\n\nFor the risk scenarios, the detailed impacts (CSV file) will have both return period damages and risk per asset. The Impacts on the buildings and the aggregated impacts (GPKG files) will similarly contain return period damages and expected annual damages. For the impacts on the roads (GPKG file), the output will contain the inundation depth on the roads for the different return periods.\n\n\n\nOutput folder structure for an event scenario\nFor an event scenario, the ‚ÄúFlooding‚Äù folder will contain a flood depth map as a GeoTIFF file, a water level map as a NetCDF, and (if observation points have been set up for the site) the water level time series for each observation point at the site, as HTML files (see Figure¬†8).\n\n\n\n\n\n\nFigure¬†8: Folder structure of the ‚Äúoutput‚Äù folder for an event scenario\n\n\n\n\n\nOutput folder structure for a risk scenario\nFor a risk scenario, the ‚ÄúFlooding‚Äù folder will contain the return period water level maps as NetCDF files and the water depth maps as GeoTIFFs (see Figure¬†9).\n\n\n\n\n\n\nFigure¬†9: Folder structure of the ‚Äúoutput‚Äù folder for a risk scenario",
    "crumbs": [
      "Output"
    ]
  },
  {
    "objectID": "1_user_guide/measures/hydraulic.html",
    "href": "1_user_guide/measures/hydraulic.html",
    "title": "Hydraulic (grey) measures",
    "section": "",
    "text": "Hydraulic (grey) measures aim to prevent floodwaters from reaching residents and infrastructure through construction of structures or pumps. More natural measures to prevent flooding are described in the section on urban green infrastructure. FloodAdapt can simulate two main types of hydraulic (grey) measures: floodwalls and levees and pumps. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a hydraulic measure, the user goes to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu selects ‚ÄúHydraulic‚Äù (see Figure¬†2). The user can then choose for ‚ÄúMeasure‚Äù one of the measure types: floodwall or levee, or pumps. For each of these measures, the user will choose an ‚ÄúArea type‚Äù. This indicates how the user will specify the location of the measure. There are two options:\nWhen specifying a hydraulic measure, it is useful to see the underlying hazard model grid which helps understand how the measure will be schematized in the model (hydraulic measures are always snapped to the hazard model grid). For this the user can click the ‚ÄúShow Grid‚Äù box. In addition, if you click the ‚ÄúShow Grid Snapper‚Äù box, FloodAdapt will show you how your polyline will be snapped to the hazard model grid. This is especially important when drawing a floodwall or leveel to make sure that the area you want to protect is well-represented once the polyline is snapped to the grid.",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/hydraulic.html#floodwalls-and-levees",
    "href": "1_user_guide/measures/hydraulic.html#floodwalls-and-levees",
    "title": "Hydraulic (grey) measures",
    "section": "Floodwalls and levees",
    "text": "Floodwalls and levees\nFloodwalls and levees are engineered structures designed to provide barriers against flood waters, thereby mitigating flood risks and protecting vulnerable areas from inundation. To implement floodwalls or levees in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúHydraulic‚Äù for the Category\nFrom the Measure drop-down menu, Select ‚ÄúFloowall‚Äù or ‚ÄúLevee‚Äù\nSelect one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù.\n\nIf you selected ‚ÄúDraw polyline‚Äù, you can now begin clicking within the map to draw a polyline where you want to implement your floodwall. When drawing the floodwall or levee, it is useful to turn on the ‚Äúshow grid‚Äù and ‚Äúgrid snapper‚Äù options so you are clear how your floodwall or levee will be implemented in the hydraulic model. We also recommend turning on the topography layer to ensure that your floodwall or levee ties into high ground, so that water does not flow around the edges of your floodwall or levee. Figure¬†3 shows an example of a polyline representing a floodwall without the grid, grid snapper, and topography visible. Figure¬†4 shows the same measure with these features enabled. You can see in Figure¬†4 how the wall will be implemented in the hydraulic model, and that the edges of the wall are tied into high ground.\n\n\n\n\n\n\nFigure¬†3: Implementing a floodwall in FloodAdapt by drawing a polyline\n\n\n\n\n\n\n\n\n\nFigure¬†4: Using the ‚Äúshow grid‚Äù, ‚Äúgrid snapper‚Äù and topography layers to better specify your floodwall or levee\n\n\n\n\n\n\n\n\n\nTipTurning on the topography layer\n\n\n\nTo turn on the topography layer, go to the top menu bar in FloodAdapt, click the ‚ÄúView‚Äù menu, and then from the drop-down menu click ‚ÄúTopography‚Äù. The topography layer will turn on. To turn the layer back off, again go to ‚ÄúView‚Äù, and again click ‚ÄúTopography‚Äù and the layer will disappear.\n\n\nOnce you have drawn your polyline or selected to import a polyline, a specification window opens (see Figure¬†5 for the example of a floodwall). In the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, and the elevation of the floodwall or levee. Once you enter the information and click ‚ÄúOK‚Äù, your floodwall or levee will show up in the measures window.\n\n\n\n\n\n\nFigure¬†5: Specifying information for a floodwall or levee\n\n\n\n\nEditing a floodwall or levee\nOnce you have created a floodwall or levee, you can edit it as long as you have not yet included it in a strategy. You can edit either the geometry or the parameters (the elevation) of the floodwall or levee.\nHere are the steps to edit the geometry of a floodwall or levee:\n\nSelect the measure in the ‚ÄúMeasures‚Äù tab\nClick ‚ÄúEdit measure‚Äù\nA pop-up window appears asking if you want to edit the geometry or parameters; select ‚ÄúGeometry‚Äù\nThe polyline is now ‚Äòclickable‚Äô\nClick the orange dots to reshape the polyline. If you have the grid snapper shown, the snapped floodwall or levee will automatically update as you edit the polyline (see Figure¬†6)\nWhen you are finished editing the polyline, click anywhere else on the map\nA pop-up window asks you if you would like to keep the new geometry; click yes\nThe geometry is now updated\n\n\n\n\n\n\n\nFigure¬†6: Editing a floodwall or levee\n\n\n\nHere are the steps to edit the parameters of a floodwall or levee:\n\nSelect the measure in the ‚ÄúMeasures‚Äù tab\nClick ‚ÄúEdit measure‚Äù\nA pop-up window appears asking if you want to edit the geometry or parameters; select ‚ÄúParameters‚Äù\nThe specification window opens\nYou may change the description or the elevation of the floodwall or levee\nWhen you are finished, click ‚ÄúOK‚Äù\nThe parameters are now updated",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/hydraulic.html#pumps",
    "href": "1_user_guide/measures/hydraulic.html#pumps",
    "title": "Hydraulic (grey) measures",
    "section": "Pumps",
    "text": "Pumps\nPumps remove water from low-lying areas or drainage systems to mitigate flooding. They are needed when gravity alone cannot allow for floodwaters to escape, or in combination with floodwalls which - without the inclusion of pumps - can trap rainwater within the area shielded by the floodwall. To implement floodwalls or levees in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúHydraulic‚Äù for the Category\nFrom the Measure drop-down menu, Select ‚Äúpump‚Äù\nSelect one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù.\n\nIf you selected ‚ÄúDraw polyline‚Äù, you can now click on the map. While FloodAdapt allows you to click multiple points in your polyline, the only points that will be retained for a pump are the first and last point. The first point will be treated as the ‚Äòintake‚Äô location (where the water will enter the pump) and the last point will be treated as the ‚Äòouttake‚Äô location (where the water will be pumped to). When drawing pump intake/outtake points, it is useful to turn on the ‚Äúshow grid‚Äù option so you are sure your intake and outtake points do not fall within the same model grid cell. When you have finished clicking your intake/outtake points, double-click on the last point to open the specification window.\nIn the specification window, you enter a name for the measure (no spaces or special characters), an optional description, and the pump capacity. When you have finished you click ‚ÄúOK‚Äù and the pump will be added and visible from the Measures tab.\n\n\n\n\n\n\nNoteHow are pumps represented in the modeling?\n\n\n\nA pump in FloodAdapt is represented as a discharge between the intake and outtake points, using the discharge rate specified by the user when creating the measure. The discharge within the intake cell influences surrounding cells, causing water from these cells to drain into the intake cell as it is being discharged. However, this setup does not represent a pump connected to drainage infrastructure, and the effects of the pump are fairly localized to the intake location.",
    "crumbs": [
      "Measures",
      "Hydraulic (grey) measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/buildings.html",
    "href": "1_user_guide/measures/buildings.html",
    "title": "Building-level measures",
    "section": "",
    "text": "FloodAdapt can simulate different types of building-level adaptation actions: elevate, buyout, and floodproof properties. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a building-level measure, the user goes to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu selects ‚ÄúBuildings‚Äù (see Figure¬†2). The user can then choose for ‚ÄúMeasure‚Äù one of the three measure types: elevate, buyout, or floodproof properties. For each of these measures, the user will choose an ‚ÄúArea type‚Äù. This indicates how the user will select the buildings to which they want to apply the measure. There are three options:\nWhen selecting buildings using the ‚ÄúDraw polygon‚Äù feature, it is useful to click on the ‚ÄúShow Buildings‚Äù button in the Measures tab (see example in Figure¬†2). This shows the buildings that are in the exposure data of the impact model within FloodAdapt.\nEach of the building-level measures allows users to specify a property type to which the measure should be applied. So, for example, if a user selects a neighborhood, but only wants to apply the measure to the residential properties within the neighborhood, they are able to specify this. The property type is linked to an attribute in the impact model called the ‚Äòprimary object type‚Äô. In the U.S, these are typically residential (RES) commercial (COM), industrial (IND), or public (PUB). You can also choose to apply the measure to all the buildings in the selected area.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/buildings.html#elevate",
    "href": "1_user_guide/measures/buildings.html#elevate",
    "title": "Building-level measures",
    "section": "Elevate",
    "text": "Elevate\nElevating properties refers to raising structures to make them less susceptible to floodwaters. To implement elevating buildings in FloodAdapt, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúElevate properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure (see example in Figure¬†3). When you are finished clicking the polygon, right click or double click to open the measure specification window (see Figure¬†7).\n\n\n\n\n\n\nFigure¬†3: Selecting buildings for applying the elevate measure\n\n\n\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the elevation in feet, a specification what this elevation is relative to (see info box below for more details), and the property type that the measure should be applied to. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab. Note that if the user selects the ‚ÄúAggregation area‚Äù option for selecting buildings, the specification window will automatically open and they will additionally be asked to choose an aggregation area (see Figure¬†5 for the example of buyouts)\n\n\n\n\n\n\nFigure¬†4: Specifying information for an elevate measure\n\n\n\n\n\n\n\n\n\nNoteElevate properties relative to‚Ä¶\n\n\n\nThe elevate properties specification window asks the user to specify what the elevation of the property is relative to. The user can select the datum; in this case, the elevation is the elevation of the finished floor of the property above the specific datum. The user can also select to elevate properties relative to ‚ÄúBase Flood Elevation‚Äù (BFE). In this case the elevation is actually a height above this reference. In the U.S, BFE is a regulatory flood level that is related to insurance, and is often used in ordinances on how high new development must be built. In areas of the world where this is not used, the base flood elevation option may not be visible.\n\n\n\n\n\n\n\n\nNoteHow is elevating properties represented in the modeling?\n\n\n\nThe exposed assets have multiple attributes, one of which is the height of the finished floor above the ground. When a user elevates properties, FloodAdapt adjusts this attribute for the selected properties to represent the user specifications. Whether a user specifies a property elevation as an elevation relative to a datum, or a height above a reference level like base flood elevation, FloodAdapt calculates for each selected property the equivalent height above the ground, and assigns this value to the finished floor height attribute of the elevated property. For example, if a user selects 12 feet above datum, and the ground elevation where a property is located is 10 feet above datum, FloodAdapt calculates that the finished floor height of the property as 2 feet, and assigns this as the finished floor height attribute of the elevated property. Similarly, if a user selects 2 feet above BFE, and the BFE at the location of a property is 9 feet, then the property must be raised to 11 feet relative to datum. If the ground elevation at that location is 8 feet, FloodAdapt would calculate that the finished floor height for the elevated property is 3 feet.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/buildings.html#buyout",
    "href": "1_user_guide/measures/buildings.html#buyout",
    "title": "Building-level measures",
    "section": "Buyout",
    "text": "Buyout\nBuyouts refer to the purchase and subsequent removal of a property, usually one that is high risk or has experienced repetitive flooding. To implement the buyout measure, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúBuyout properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù for the Area type, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure. When you are finished clicking the polygon, right click or double click to open the measure specification window. If you select ‚ÄúAggregation area‚Äù the specification window will automatically open when you click ‚ÄúAdd measure‚Äù and you will additionally choose an aggregation area to apply the measure (see Figure¬†5).\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the property type that the measure should be applied to, and - if you selected ‚ÄúAggregation area‚Äù - the aggregation area where the measure should be applied. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab.\n\n\n\n\n\n\nFigure¬†5: Specifying information for a buyout measure\n\n\n\n\n\n\n\n\n\nNoteHow are buyouts represented in the modeling?\n\n\n\nWhen a property has been bought out and removed, it is no longer an exposed asset in the project area. However, the implementation in FloodAdapt does not actually remove the properties from the exposure data; instead, the selected properties are assigned a maximum potential damage value of zero. The damage is calculated as the damage fraction (based on the inundation depth) multiplied by the maximum potential damage. Because the maximum potential damage is set to zero, the bought out properties will result in damages of zero, regardless of the inundation depth. In this way, it represents the situation that the property has been removed.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/buildings.html#floodproof",
    "href": "1_user_guide/measures/buildings.html#floodproof",
    "title": "Building-level measures",
    "section": "Floodproof",
    "text": "Floodproof\nFloodproofing in FloodAdapt refers to dry floodproofing, which involves sealing a building‚Äôs exterior, typically through barriers or seals, to prevent floodwaters from entering and causing damage. The effect of floodproofing is that the building will not incur any damages until floodwaters exceed the height of the floodproofing seals.\nTo implement floodproofing to buildings in FloodAdapt, go to the Measures tab, select ‚ÄúBuildings‚Äù for the Category, and then from the Measure drop-down menu, select ‚ÄúFloodproof properties‚Äù. Select one of the ‚ÄúArea type‚Äù options and then click ‚ÄúAdd Measure‚Äù. If you selected ‚ÄúDraw polygon‚Äù, you can now begin clicking within the map to draw a polygon to enclose the buildings to which you want to apply the measure (see example in Figure¬†6). When you are finished clicking the polygon, right click or double click to open the measure specification window (see Figure¬†7).\n\n\n\n\n\n\nFigure¬†6: Selecting buildings for applying the floodproofing measure\n\n\n\nIn the specification window, the user enters a name for the measure (no spaces or special characters), an optional description, the height of the floodproofing, and the property type that the measure should be applied to. The floodproofing height ensures that damages only occur when the inundation depth is greater than the floodproofing height. When these entries are complete, the user can click ‚ÄòOK‚Äô and the measure will be added to the list of measures in the Measures tab. Note that if the user selects the ‚ÄúAggregation area‚Äù option for selecting buildings, the specification window will automatically open when they click ‚ÄúAdd measure‚Äù and they will additionally be asked to choose an aggregation area (see Figure¬†5 for the example of buyouts)\n\n\n\n\n\n\nFigure¬†7: Specifying information for a floodproofing measure\n\n\n\n\n\n\n\n\n\nNoteHow is floodproofing represented in the modeling?\n\n\n\nThe impact model uses depth-damage curves that relate inundation depths to fractions of total asset damage. When a user selects a floodproofing height, there will be no damage to the property until the inundation depths exceed that height. This is represented by modifying the depth-damage curve so that the damage fraction is zero below the floodproofing height. Above the floodproofing height, the damage curve is unchanged because once the inundation exceeds the floodproofing height, it is assumed the water will then enter the property and reach the levels it would have reached without the floodproofing barrier.",
    "crumbs": [
      "Measures",
      "Building-level measures"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html",
    "href": "1_user_guide/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This page will help you get started with FloodAdapt. It covers the following topics:",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html#system-requirements",
    "href": "1_user_guide/getting_started.html#system-requirements",
    "title": "Getting Started",
    "section": "System requirements",
    "text": "System requirements\nIn order to run FloodAdapt, the following are required:\n\nA Windows operating system\nAccess to the internet (for loading maps).\nAt least 1 GB of storage for the FloodAdapt system files and the underlying database\nApproximately 150 MB of storage for each user-generated scenario\n\n\n\n\n\n\n\nNoteWhich windows systems have been tested?\n\n\n\nFloodAdapt has been tested on Windows 10 and 11. It is expected to work on older systems, but has not been tested.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html#installation-steps",
    "href": "1_user_guide/getting_started.html#installation-steps",
    "title": "Getting Started",
    "section": "Installation steps",
    "text": "Installation steps\nTo download and install FloodAdapt on your computer:\n\nDownload the FloodAdapt installer from the Deltares website.\nDouble-click the ‚ÄúFloodAdaptInstaller-v1.0.0.exe‚Äù file and the setup wizard will open (see Figure¬†1). Follow the steps of the installation wizard.\n\n\n\n\n\n\n\nFigure¬†1: FloodAdapt installation setup wizard",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html#opening-floodadapt",
    "href": "1_user_guide/getting_started.html#opening-floodadapt",
    "title": "Getting Started",
    "section": "Opening FloodAdapt",
    "text": "Opening FloodAdapt\nWhen you open the FloodAdapt application you will be prompted to select a database root folder. This is the location where you store one or more FloodAdapt databases (don‚Äôt select your database here - you want to select the folder your database is contained within). Once you select this root folder, the databases within the root folder will appear. Select the database you want to work with and click ‚ÄúStart‚Äù to open the FloodAdapt application. Each time you open FloodAdapt you have the opportunity to change the database root and/or select a different database. It will remember the root folder you selected in the previous session.\n\n\n\n\n\n\nFigure¬†2: Database selector when opening FloodAdapt\n\n\n\n\n\n\n\n\n\nNoteWhy do I have to select a database?\n\n\n\nThe FloodAdapt application is a calculation ‚Äúshell‚Äù that requires a FloodAdapt database to work. Details on setting up a FloodAdapt database in a new location are provided in the Setup Guide. If you are interested in obtaining support or training from the Deltares team, you can reach us as floodadapt@deltares.nl.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html#downloading-a-demonstration-database",
    "href": "1_user_guide/getting_started.html#downloading-a-demonstration-database",
    "title": "Getting Started",
    "section": "Downloading a demonstration database",
    "text": "Downloading a demonstration database\nTo try out FloodAdapt, you can download a demonstration database for the city of Charleston, South Carolina on the Deltares website. This database contains some simplifications and is for educational purposes only. It will allow you to test out all of the FloodAdapt functionality.\nDownload the demonstration database here\nFor help setting up a database for your location, check out the Setup Guide or contact the FloodAdapt team for support or training packages at floodadapt@deltares.nl.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/getting_started.html#floodadapt-database-structure",
    "href": "1_user_guide/getting_started.html#floodadapt-database-structure",
    "title": "Getting Started",
    "section": "FloodAdapt database structure",
    "text": "FloodAdapt database structure\nThe FloodAdapt database uses a normal folder structure so that it is easily accessible by users, without requiring database knowledge. Figure¬†3 shows the overall folder structure. The ‚ÄúDatabase Root Folder‚Äù is folder where you can store one ore more FloodAdapt site databases. Within each site database, there are three folders: Input, Output, and Static. The input and output folders are populated when you use the FloodAdapt application. The input folder contains information about scenario components: events, projections, measures, strategies and scenarios. The output folder contains the flooding and impact output from simulated scenarios, and is described in more detail in the Output section. The Static folder contains information that is prepared when setting up FloodAdapt for a particular site location.\n\n\n\n\n\n\nFigure¬†3: FloodAdapt database folder structure",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "1_user_guide/events/probabilistic_events.html",
    "href": "1_user_guide/events/probabilistic_events.html",
    "title": "Probabilistic event set",
    "section": "",
    "text": "A probabilistic event set is the combination of a set of synthetic events and their occurrence probabilities. These can be both tropical storms (hurricanes), as well as non-tropical events. They should include all event types that can lead to flooding in the site area (now or in the future), and can be compound flood events, meaning a combination of different flood drivers, like water level, rainfall, river discharge, or wind. It can be complicated to set up this set of events, and is therefore recommended to be done by an expert during the set-up of FloodAdapt for the site location (see guidance on setting up an event set in the Setup Guide)\nIn the events tab in FloodAdapt, a probabilistic event set can be recognized by the Type specification at the bottom of the window (see Figure¬†1). These event sets cannot be modified or deleted via the user interface.\n\n\n\n\n\n\nFigure¬†1: Probabilistic event set in the Events window. The Type is specified as Probabilistic Event Set and cannot be modified\n\n\n\n\n\n\n\n\n\nNoteHow are probabilistic event sets used in FloodAdapt?\n\n\n\nWhen a user selects a scenario with a probabilistic event set, FloodAdapt calculates the flooding for each of the events in the event set. Using the flood output for the events and information about the frequencies of the events (also provided as part of the event set), FloodAdapt calculates return period flood maps (such as the 100 year flood map), return period damages, and expected annual damages (risk) for the scenario. Details of how FloodAdapt makes these calculations is presented in the Technical Documentation.\nFor an example how to use a probabilistic event set in a scenario, let‚Äôs say a user wants to explore the risk to their community with 1 foot of sea level rise and with a floodwall in place. Their scenario components would be: projection = 1 ft. sea level rise, strategy = floodwall, event = probabilistic event set. The calculation of risk allows a user to explore the risk-reduction benefits of adaptation options, as well as obtaining more comprehensive insight into how risk is distributed. The page on scenarios gives more examples how users can define scenarios to answer different questions.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Events",
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "1_user_guide/events/hurricane.html",
    "href": "1_user_guide/events/hurricane.html",
    "title": "Hurricanes",
    "section": "",
    "text": "The ‚ÄúHurricane‚Äù option allows users to select and shift a historical hurricane from a hurricane track database. When the user selects the ‚ÄúHurricane‚Äù option from the Events tab, they will see a hurricane selection window appear (see Figure¬†1), which is populated with historical hurricanes from the National Hurricane Center (NHC) HURDAT2 database. This database is updated by the NHC annually and will require an annual maintenance update to keep the hurricane database in FloodAdapt up to date. The user can see all hurricanes within a specified distance of the site, or between specified years.\n\n\n\n\n\n\nFigure¬†1: Hurricane selector window. You can search by name, and can filter the selection by distance to the site or time window\n\n\n\n\n\n\n\n\n\nFigure¬†2: Event template window for a historical hurricane.\n\n\n\nOnce a hurricane is selected, the hurricane event template window opens (see Figure¬†2). The event name and the timing will be automatically filled in. The user can edit these if desired.\n\n\n\n\n\n\nTipRecommended for speed: edit the default duration\n\n\n\nThe automatic event duration can be shortened to cover just the part of the track relevant at the site. Users can hover their mouse over the track icons in the map window to see date and time stamps. Choose dates from 1-2 days before to 1 day after landfall.\n\n\nIn the ‚ÄúHurricane track shift‚Äù box, users can shift the hurricane track by specifying the distance (e.g.¬†in miles or kms) of horizontal or vertical shift. The shifted hurricane will be displayed beside the original track. Note that when shifting a historical hurricane track, the new track will be assigned the attributes of the original hurricane (like wind and pressure fields).\nThe wind and rain are automatically derived from information about the hurricane track. The rainfall is derived from the track using the IPET method. The user does not need to specify any information here, but if they wish to override the default ‚Äòtrack‚Äô rainfall option, all the rainfall time series options available for the historical event are also available in the hurricane event template (constant, CSV upload, synthetic). In addition, users can specify a ‚Äòprecipitation multiplier‚Äô by which the rainfall will be multiplied at each time step. This can be useful, for example, if a user wants to use the track-derived rainfall but see a ‚Äòworse-case‚Äô situation.\nThe river discharge represents the discharge at the model boundary and will be automatically filled to a default (average) value specified during system set-up. The user can modify this value. If there are multiple rivers at the model boundary, the user will be able to select each river to view or modify the discharge. Similar to the historical event, users can also upload a CSV or specify a synthetic discharge time series.\n\n\n\n\n Back to top",
    "crumbs": [
      "Events",
      "Hurricanes"
    ]
  },
  {
    "objectID": "1_user_guide/compare/index.html",
    "href": "1_user_guide/compare/index.html",
    "title": "Compare tabs",
    "section": "",
    "text": "Being able to compare scenarios is important when addressing user questions. For example, consider the question ‚ÄúHow would a historic storm look with sea evel rise?‚Äù This question is best answered by simulating the historic storm without and then with sea level rise and comparing the output to evaluate where and by how much flooding and impacts would increase.\nFloodAdapt supports users in comparing scenarios with two comparison tabs, one to compare spatial output and one to compare scenario metrics. These are described in separate sections below.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "1_user_guide/compare/index.html#comparing-spatial-output",
    "href": "1_user_guide/compare/index.html#comparing-spatial-output",
    "title": "Compare tabs",
    "section": "Comparing spatial output",
    "text": "Comparing spatial output\nThe ‚ÄúCompare - map‚Äù tab in FloodAdapt (see Figure¬†1) allows users to compare the spatial output of two scenarios using a slider bar in the map window. The lower panel has two selection boxes, one to select the scenario that will show up on the left side of the slider bar, and one to select the scenario that will show up on the right side of the slider bar.\nTo compare the spatial output of two scenarios:\n\nGo to the ‚ÄúCompare - map‚Äù tab\nSelect a scenario in the ‚ÄúScenario left‚Äù selection box\nSelect a scenario in the ‚ÄúScenario right‚Äù selection box\nSelect the map layers you wish to view\nIn the map window, drag the slider bar left and right to compare the spatial output\n\n\n\n\n\n\n\nFigure¬†1: Comparing map outputs for two scenarios. This example shows a compound high-tide and rainfall event from 2023 without sea level rise (left scenario) and with sea level rise (right scenario)\n\n\n\n\n\n\n\n\n\nNoteAutomatic scenario filtering\n\n\n\nOnce a selection is made in the ‚ÄúScenario left‚Äù selection box, the ‚ÄúScenario right‚Äù selection box will update to only include scenarios of the same type - either a risk scenario or event scenario. Because the output differs between these scenario types, only scenarios of the same type can be compared.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "1_user_guide/compare/index.html#comparing-output-metrics",
    "href": "1_user_guide/compare/index.html#comparing-output-metrics",
    "title": "Compare tabs",
    "section": "Comparing output metrics",
    "text": "Comparing output metrics\nIn addition to comparing the spatial output, it is informative to compare scenario output metrics, such as residential damages or the number of businesses impacted. This helps summarize the impacts and how they are changing under different scenarios.\nThe ‚ÄúCompare - table‚Äù tab (see Figure¬†2) allows users to select multiple scenarios and add them to a metrics comparison box. There is no limit on the number of scenarios that can be compared.\nTo compare scenario output metrics:\n\nSelect a scenario in the scenario selection box\nClick the ‚ÄúAdd‚Äù button\nRepeat the above steps until all of the scenarios you wish to compare are included in the metric comparison box\n\nIf you want to remove a scenario from the metric comparison box:\n\nSelect the column of the scenario in the metric comparison box\nClick the ‚ÄúRemove‚Äù button\n\n\n\n\n\n\n\nFigure¬†2: Comparing metrics outputs for multiple scenarios. This example shows the metrics for current risk, risk with 1 foot of sea level rise, and risk with 1 foot of sea level rise and a flood wall implemented.\n\n\n\n\n\n\n\n\n\nNoteAutomatic scenario filtering\n\n\n\nSimilar to the spatial comparison tab, once a scenario has been added to the metric comparison box, the scenario selection box will update to only include scenarios of the same type - either a risk scenario or an event scenario. Because the output differs between these scenario types, only scenarios of the same type can be compared.",
    "crumbs": [
      "Compare tabs"
    ]
  },
  {
    "objectID": "1_user_guide/arc_gis/index.html",
    "href": "1_user_guide/arc_gis/index.html",
    "title": "ArcGis",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_user_guide/benefits.html",
    "href": "1_user_guide/benefits.html",
    "title": "Benefits",
    "section": "",
    "text": "Flood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits.\nWhen you first go to the Benefits tab in FloodAdapt (see Figure¬†1) you will see an empty list box in the lower panel. Once you create benefit analyses these will appear in the list. To the right of the list box there are buttons to add, edit, or delete a benefit analysis. Before creating your first benefit analysis, only the ‚ÄòAdd benefit analysis‚Äô button is active.\nThe following sections will describe how to create a benefit analysis, how benefits are calculated, how to view benefit analysis output in the Benefits tab, and where you can find output on your computer for more detailed investigation.",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "1_user_guide/benefits.html#creating-a-new-benefit-analysis",
    "href": "1_user_guide/benefits.html#creating-a-new-benefit-analysis",
    "title": "Benefits",
    "section": "Creating a new benefit analysis",
    "text": "Creating a new benefit analysis\nFloodAdapt users can evaluate the risk-reduction benefits of any strategy they have created (which can be composed of a single measure or a collection of measures). To do this, go to the Benefits tab in FloodAdapt, and in the bottom panel click on ‚ÄúAdd benefit analysis‚Äù. A popup window will appear within which you will specify important choices about your benefit analysis.\n\n\n\n\n\n\nFigure¬†2: Benefit analysis popup window\n\n\n\nFor the following description please refer to Figure¬†2. To create a new benefit analysis:\n\nAnalysis name: Enter a name for your analysis. This cannot have any spaces or special characters (underscores are ok). Choose a name that will help you identify your analysis easily in the benefits tab; for example ‚Äúbenefits_floodwall‚Äù. You can optionally also add a description.\nStrategy to evaluate: In the ‚ÄúStrategy to evaluate‚Äù panel, select the strategy for which you want to calculate benefits. The baseline strategy is selected for you and consists of the ‚Äòno-measures‚Äô strategy.\nSituation at implementation: The implementation situation consists of the ‚Äòcurrent‚Äô projection representing current climate and socio-economic conditions (pre-selected). The implementation year can be adjusted but by default is set to the ‚Äòcurrent‚Äô year defined during system setup.\nSituation at end of analysis: In the end-of-analysis situation, specify the year that corresponds to the duration over which you want to calculate benefits. In Figure¬†2, the year 2060 is specified. That means benefits will be calculated between the current year up to and including 2060. From the ‚ÄúProjection‚Äù dropdown menu, select the climate and/or socio-economic conditions you expect at this end-of-analysis year. For example, if you expect sea level rise to be 1 foot at the year specified (e.g.¬†2060 in Figure¬†2), then choose a projection with 1 foot of SLR. Note that you must have already created such a projection in order to select it here. The projection dropdown menu will contain all projections that have been created in the Projections tab.\nCosts: If you have information on the implementation and maintenance costs of your project, you can set ‚ÄúAdd costs‚Äù to ‚ÄúYes‚Äù and a ‚ÄúCosts‚Äù panel will appear. Here you can enter the costs. If you do not have this information, set ‚ÄúAdd costs‚Äù to ‚ÄúNo‚Äù and the ‚ÄúCosts‚Äù panel will disappear. When cost information is not available, FloodAdapt will only calculate the risk-reduction benefits. When cost information is available, it will additionally calculate the benefit-cost ratio, net present value, and internal rate of return. These latter two are saved on your computer but not presented in the Benefits tab.\nDiscount rate: Enter a discount rate. A discount rate is used in benefit-cost analysis to discount future benefits and costs. It reflects the idea that benefits and costs are worth more if they are experienced sooner. When discount rates are higher, the overall present value of benefits will be lower than when the discount rate is lower. Users are free to explore different discount rates and the effect these have on the present value of benefits and the benefit-cost ratio.\nCheck scenarios: Once you have entered the above information, click the ‚ÄúCheck scenarios‚Äù button. FloodAdapt helps you to determine which scenarios need to be run in order to carry out the benefit analysis you specified. The risk-reduction benefit analysis requires risk calculations with and without the selected strategy under current conditions and with and without the strategy under the projection selected for the end of the analysis situation. When you click ‚ÄúCheck scenarios‚Äù, the scenarios that need to be run will be shown in the table in the popup window (see Figure¬†3). The column ‚Äúscenario created‚Äù will list the scenario name if the scenario has already been created and will say ‚ÄúNo‚Äù if the scenario has not been created. The column ‚Äúscenario run‚Äù will indicate whether the scenario has already been run (True) or not (False).\nCreate missing scenarios: If any of the required scenarios is missing when you click ‚ÄúCheck scenarios‚Äù, you can click ‚ÄúCreate missing scenarios‚Äù and FloodAdapt will automatically create the missing scenarios and place them in the scenarios table in the Scenarios tab.\nClick ‚ÄúOK‚Äù to add the analysis to the Benefits tab\n\n\n\n\n\n\n\nFigure¬†3: The ‚ÄúCheck scenarios‚Äù feature in the Benefit analysis popup window\n\n\n\n\n\n\n\n\n\nNoteRequired scenarios need to be run before running your benefit analysis\n\n\n\nThe ‚ÄúCheck scenarios‚Äù and ‚ÄúCreate missing scenarios‚Äù buttons guide users to ensure the required scenarios are created for the benefit analysis. However, scenarios can only be run from the Scenarios tab. If any of the four required scenarios have not been run, you need to go to the Scenarios tab and run them. If any of the required scenarios have not yet been run, the ‚ÄúCalculate benefits‚Äù button will be greyed out and you will see text beneath it informing you that ‚ÄúYou cannot calculate benefits before running the required scenarios (use Scenarios tab)‚Äù, see Figure¬†4.\n\n\n\n\n\n\nFigure¬†4: All required scenarios must first be simulated before running a benefit analysis",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "1_user_guide/benefits.html#calculating-benefits",
    "href": "1_user_guide/benefits.html#calculating-benefits",
    "title": "Benefits",
    "section": "Calculating benefits",
    "text": "Calculating benefits\nOnce the required scenarios have been simulated, the ‚ÄúCalculate benefits‚Äù button will be active, see Figure¬†5. When the button is clicked, the benefit calculation happens on-the-fly, but because the risk information is already calculated, the benefit calculation happens very quickly and the results appear instantly.\n\n\n\n\n\n\nFigure¬†5: When all scenarios have been run, ‚ÄúCalculate benefits‚Äù button is active\n\n\n\nThe benefit calculation uses output from four scenarios:\n\nThe risk without the strategy implemented in current conditions\nThe risk with the strategy implemented in current conditions\nThe risk without the strategy implemented in future conditions\nThe risk with the strategy implemented in future conditions\n\nWhen the ‚ÄúCalculate benefits‚Äù button is clicked, the following benefit calculations are carried out:\n\nThe risk-reduction benefit under current conditions is calculated as the difference in the risk without the strategy and with the strategy under the ‚Äúcurrent‚Äù projection (representing current conditions).\nThe risk-reduction benefit under future conditions (for the year specified in the end-of-analysis situation) is calculated as the difference in the risk without the strategy and with the strategy under the future projection specified in the end-of-analysis situation when you created your benefit analysis.\nThe annual risk-reduction benefits are calculated by linearly interpolating between the risk-reduction benefits under current conditions (in the current year) and the risk-reduction benefits under future conditions (in the end-of-analysis year).\nThe annual discounted benefits (\\(B_d(t)\\)) are calculated as\n\\(B_d\\ (t)=B(t)/(1+r)^t\\ \\)\nwhere \\(B(t)\\) is the risk-reduction benefit in year \\(t\\), \\(t\\) is the year since implementation, and \\(r\\) is the discount rate.\nThe (present value of the) benefits are calculated as the sum of the annual discounted benefits over the analysis duration (\\(N\\) years).\n\\(Benefits\\ =\\ \\sum_{t=0}^N B_d\\ (t)\\ \\)\n\nWhen cost information is provided, FloodAdapt additionally calculates:\n\nThe (present value of the) costs - calculated only when implementation and/or maintenance costs are provided in the benefit analysis input. This is calculated in the same way as the present value of the benefits: \\(Costs\\ =\\ \\sum_{t=0}^N C_d\\ (t)\\ \\)\nwhere \\(C_d(t)\\) is the discounted cost in year \\(t\\).\nThe benefit-cost ratio (BCR) is calculated as the present value of the benefits divided by the present value of the costs.\nThe net present value (NPV) is the difference in annual discounted benefits and costs, summed up over the analysis period.\n\\(NPV\\ =\\ \\sum_{t=0}^N [(B(t)-C(t))/(1+r)^t]\\ \\)\nThe internal rate of return (IRR) represents the discount rate at which the NPV would be equal to zero. Higher IRR indicates a better investment, because in this case the benefits weigh strongly against the costs.\n\nThe output from these calculation steps can be viewed in the Benefits output tab and can additionally be accessed on the user‚Äôs computer.\n\n\n\n\n\n\nWarningSome metrics are only calculated when cost information is provided!\n\n\n\nThe present value of the costs, benefit cost ratio, net present value, and internal rate of return are only calculated if the user has provided information on implementation and/or maintenance costs when they created their benefit analysis. When this information is not provided, the benefits are calculated, but none of the metrics that require comparison with costs.",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "1_user_guide/benefits.html#viewing-benefit-output-in-the-benefits-tab",
    "href": "1_user_guide/benefits.html#viewing-benefit-output-in-the-benefits-tab",
    "title": "Benefits",
    "section": "Viewing benefit output in the Benefits tab",
    "text": "Viewing benefit output in the Benefits tab\nFigure¬†6 shows the Benefits tab in FloodAdapt once a benefit analysis has been completed. The window is separated into a top panel with a map window on the left and, when using the collapsible frame, a time series of benefits on the right. When a benefit analysis is selected in the list, the measures in the strategy for which benefits are being calculated will appear in the map window. The bottom panel will show a summary of the user-provided input to the benefit analysis, such as discount rate or end-year of the analysis. Once the user clicks the ‚ÄúCalculate benefits‚Äù button, output will appear in the panel. This output consists of the (present value of the) benefits and a benefit-cost ratio (if cost information was provided). The collapsible frame contains a graphic with the risk-reduction benefits calculated under current conditions and under future conditions (green dots in the figure), the interpolated benefits over time (black line), the discounted benefits over time (dark green line), and the area under the discounted benefits curve (green shading) representing the present value of the benefits.\n\n\n\n\n\n\nNoteWhy don‚Äôt I see the NPV and IRR in the Benefits tab?\n\n\n\nIn addition to the above results which can be viewed in the Output tab, FloodAdapt also calculates - when implementation and/or maintenance cost information is provided - the net present value and the internal rate of return. These are provided in a results text file in the benefits output folder.\n\n\n\n\n\n\n\n\nFigure¬†6: The FloodAdapt Benefits tab showing a selected benefit analysis\n\n\n\nThe benefits can also be viewed spatially; the lower panel contains map visualization options (see Figure¬†6). The user can click ‚ÄúAggregated benefits‚Äù to see the spatial distribution of benefits (see Figure¬†7 for an example). They can choose from the ‚ÄúAggregation‚Äù drop-down menu which aggregation level they would like to view, for example neighborhoods or census blocks.\n\n\n\n\n\n\nFigure¬†7: Visualizing the benefits spatially\n\n\n\nIn the map visualization options, there is also an equity-weighted button. When this is checked the distributed (aggregated) benefits are displayed using equity weights, see Figure¬†8. The figure shows the benefits without equity weights on the left and with equity weights on the right. In the figure, blue stars have been added (outside of FloodAdapt) to highlight how the equity weighting affects lower-income census-block groups. When equity weights are applied, the benefits of these lower-income areas will be weighted more heavily; in contrast, high-income area benefits will be weighted less heavily. Equity weights are calculated in FloodAdapt using information on income. Risk estimates are multiplied by the equity weights to derive equity-weighted risk estimates, from which equity-weighted benefits are calculated. This visualization is only available at the same scale for which income data is available. This will typically be census block level.\n\n\n\n\n\n\nFigure¬†8: Visualizing equity-weighted benefits. The blue stars indicate lower-income census block groups. Their benefits are more weighted more heavily when equity-weights are applied (right side versus left side)",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "1_user_guide/benefits.html#benefits-output-folder",
    "href": "1_user_guide/benefits.html#benefits-output-folder",
    "title": "Benefits",
    "section": "Benefits output folder",
    "text": "Benefits output folder\nThe output from a benefit analysis is saved on a user‚Äôs computer, aspiring to provide full access and transparency. This section will describe the output files saved from the benefit analysis.\n\n\n\n\n\n\nNoteWhere can I find the output folder?\n\n\n\nFigure¬†9 shows where the output folder is located within the FloodAdapt database. The database root directory could contain multiple site databases, for different locations, or even variations of databases for the same location. The output folder is located directly inside the site database folder.\n\n\n\n\n\n\nFigure¬†9: Location of the ‚Äúoutput‚Äù folder within the FloodAdapt folder structure\n\n\n\n\n\nThe output folder contains a subfolder named ‚ÄúBenefits‚Äù. Within this subfolder you will find one folder for each benefit analysis that has been run. The name of the folder will be the name of the benefit analysis. Each folder will contain several files (see Figure¬†10):\n\nBenefits graphic (HTML file) that contains the same graphic displayed in the collapsible frame in the Benefits tab.\nBenefits per aggregation area, one CSV file for each aggregation scale defined for the site (e.g.¬†neighborhoods or census block groups). For the aggregation scale for which income data is available (usually census block group), the CSV file will contain a column on benefits and one on equity-weighted benefits.\nSpatial benefits as geopackage (GPKG) files, one file for each aggregation scale defined for the site.\nSummary results of the benefit analysis as a text file (TOML file). This file always contains the total benefits (present value). If cost information was provided when setting up the benefit analysis, this file will also contain costs (present value), net present value (NPV), the benefit cost ratio (BCR), and the internal rate of return (IRR).\nA time series of annual risk with and without the strategy implemented, annual costs and benefits (absolute and discounted), and annual profit as the difference between benefits and costs (absolute and discounted).\n\n\n\n\n\n\n\nFigure¬†10: Benefits output folder",
    "crumbs": [
      "Benefits"
    ]
  },
  {
    "objectID": "1_user_guide/events/historical.html",
    "href": "1_user_guide/events/historical.html",
    "title": "Historical events",
    "section": "",
    "text": "FloodAdapt gives users the option to select and modify historical events, which they can then build what-if scenarios around. This is a powerful feature that engages stakeholders and facilitates a concrete understanding of risks and effectiveness of measures. For example, if a community experienced a high tide flood event, they can explore how that same event will look in the future as sea level rises, or how it would have been worsened had it coincided with rainfall. They can test out different measures and assess how effective they would be against this type of event. Historical events also allow users to develop confidence in the system (or identify model-improvement needs) by comparing with their experience or measurements of where floods and impacts occurred in the event.\nBelow is a video that demonstrates the creation of a historical event, followed by complete documentation on all the options for creating and modifying historical events.\nWhen a user selects the ‚ÄúHistorical‚Äù option from the Events tab, they will see the event template window shown in Figure¬†1. This window allows the user to input (historical) time series for:\nThe event window also allows users to modify these elements with synthetic options to create what-if event scenarios around a historic event. For example, a user could add synthetic rainfall to a historical king tide event.\nUsers can view the time series for the different event components in the ‚Äòplotting‚Äô section of the event template window (see Figure¬†1). The dropdown menu ‚ÄúForcing‚Äù allows users to select any of the four components. Users can select the component they want to view, and then click ‚ÄúGenerate plot‚Äù to visualize the time series.",
    "crumbs": [
      "Events",
      "Historical events"
    ]
  },
  {
    "objectID": "1_user_guide/events/historical.html#water-levels",
    "href": "1_user_guide/events/historical.html#water-levels",
    "title": "Historical events",
    "section": "Water levels",
    "text": "Water levels\nThe water level time series for the historical event can be specified in different ways (see Figure¬†1). These are:\n\nGauged - if a gauge exists at the site and has been connected to the system at setup, the option ‚Äúgauge‚Äù will be selected by default, and water levels for the selected time period will be automatically downloaded and displayed. If the user changes the start or stop time, they will need to click ‚Äòdownload water levels‚Äô to refresh the download and the display.\nCSV - users can import water level time series as a two-column CSV file. The first column should contain the date and time in the format yyyy-mm-dd hh:mm:ss, and the second column the water level relative to the reference level for the site (for example, mean lower low water). There is an ‚Äúi‚Äù button next to the option to import a time series. Clicking this button will display an example of the format required for the CSV, including the water level units and reference.\nSynthetic - when users have a historical record of rainfall or river discharge, but water levels were unknown or unmeasured, users can choose to generate a synthetic water level time series. The simple option is to specify a peak water level (default is average high tide), and the duration of the peak. Advanced options are described in the synthetic event documentation.\n\n\n\n\n\n\n\n\nNoteWhat do we mean by ‚Äòwater levels‚Äô\n\n\n\nIn this documentation, we refer to water levels as the combined effect of (1) astronomoical tide and (2) the surge caused by wind.",
    "crumbs": [
      "Events",
      "Historical events"
    ]
  },
  {
    "objectID": "1_user_guide/events/historical.html#rainfall",
    "href": "1_user_guide/events/historical.html#rainfall",
    "title": "Historical events",
    "section": "Rainfall",
    "text": "Rainfall\nThe user has the following options for specifying a rainfall time series for the event:\nNone - Selecting this option means that no rainfall will be included in the calculation.\nConstant - For a constant rainfall, the user is asked to enter a rainfall intensity. This rainfall will be applied over the entire duration of the event.\nCSV - The user can upload a two-column CSV file with the rainfall time series. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, and the second column contains the rainfall intensity (depth/time). The units of the rainfall will depend on how the system is configured. In the event specification window, when you choose ‚ÄòCSV‚Äô for the rainfall source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the rainfall intensity units. There is an option to increase the rainfall by a fixed amount (‚Äúprecipitation multiplier‚Äù). All rainfall values in the time series will be multiplied by the value entered in this field.\nSynthetic - The synthetic option allows users to build what-if rainfall scenarios to explore what would have happened if they had coincided with historical water level events, like a high tide event. The synthetic options ask a user for the cumulative rainfall, the duration of the rainfall, and a time when the peak rainfall occurred. More details about the synethtic options are covered in the synthetic event documentation.",
    "crumbs": [
      "Events",
      "Historical events"
    ]
  },
  {
    "objectID": "1_user_guide/events/historical.html#wind",
    "href": "1_user_guide/events/historical.html#wind",
    "title": "Historical events",
    "section": "Wind",
    "text": "Wind\nThe user has the following options for entering time series for the wind:\nNone - Selecting none means no wind will be included in the calculation.\nConstant - For a constant wind speed, the user is asked to enter the wind speed and wind direction.\nCSV - The user can upload a wind time series; this should be a three-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the wind speed, and the third column contains the wind direction. The units of the wind speed and direction will depend on how the system is configured. In the event specification window, when you choose ‚ÄòCSV‚Äô for the wind source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\n\n\n\n\n\n\n\nNoteWhat role does wind play when using measured or synthetic nearshore water levels?\n\n\n\nThe largest effect of wind on flooding is the surge it causes in the nearshore water levels. For gauged or synthetic nearshore water levels, this effect is already included. The (more limited) role wind plays in this event type is to skew the water levels from the model boundary (usually near the gauge) to the land. Unless this is of particular interest to a user, the wind can be ignored.",
    "crumbs": [
      "Events",
      "Historical events"
    ]
  },
  {
    "objectID": "1_user_guide/events/historical.html#river-discharge",
    "href": "1_user_guide/events/historical.html#river-discharge",
    "title": "Historical events",
    "section": "River discharge",
    "text": "River discharge\nThe river discharge represents the discharge in a river at the model boundary. If there are multiple rivers at the model boundary, the user will be able to select each river to specify the discharge. The user has three options for specifying the river discharge time series: a constant discharge, an uploaded time series, or a synthetic time series.\nConstant - by default, this option is selected and an average discharge value is used; this value is specified in a FloodAdapt configuration folder at system setup. The user can change the value of the constant discharge in the event specification window.\nCSV - The user can upload a river discharge time series; this should be a two-column csv. The first column contains the date and time in the format yyyy-mm-dd hh:mm:ss, the second column contains the river discharge. The units of the river discharge will depend on how the system is configured. In the event specification window, when you choose ‚Äòtimeseries‚Äô for the river discharge source, you will see an ‚Äúi‚Äù button appear. Clicking this button will display an example of the format required for the csv, including the units.\nSynthetic - The synthetic option allows users to build a synthetic river discharge time series. The synthetic options ask a user for peak discharge above base discharge, the duration of the discharge wave, and the time when the peak discharge occurs (relative to the start of the selected time period). The base discharge is automatically set to the average discharge, but can be modified. More details about the synthetic options are covered in the synthetic event documentation.",
    "crumbs": [
      "Events",
      "Historical events"
    ]
  },
  {
    "objectID": "1_user_guide/events/index.html",
    "href": "1_user_guide/events/index.html",
    "title": "Events",
    "section": "",
    "text": "FloodAdapt allows users to specify and simulate the flooding and impacts for many different types of (compound) events. These can be either historically-based or synthetic events. The historically-based events are referred to as ‚ÄúHistorical‚Äù when using historical water levels or rainfall, and as ‚ÄúHurricane‚Äù when using a historical hurricane track. Historical events can be modified by users to create what-if event scenarios, for example by adding or intensifying rainfall or shifting a hurricane track.\nThere are three event types users can add:\nTo create an event, the user goes to the Events tab in FloodAdapt (see Figure¬†1). Prior to creating any events, there may be one event already shown in the event list window. This will be a probabilistic event set that is prepared as part of system setup, and is used to calculate risk. Underneath the event set window, the event ‚ÄúType‚Äù is indicated. For event sets this will say ‚ÄúProbabilistic Event Set.‚Äù For events that you create in the Events tab, these will say ‚ÄúSingle Event‚Äù. Next to the event list window there are buttons to add, edit, delete, and copy an event. Note that when event sets are selected, only the ‚ÄúAdd event‚Äù button will be active.\nWhen a user clicks Add event in the event window, they will be prompted to choose from one of the three event types. Each selection opens a window where the user can specify event information.\nEach event type will have unique input that is required, but they also share some common input. The user must provide an event name, and - optionally - a description. Additionally, the ‚ÄúHistorical‚Äù and ‚ÄúHurricane‚Äù events require a start and stop date and time for the event.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "1_user_guide/events/index.html#how-are-events-modeled-in-floodadapt",
    "href": "1_user_guide/events/index.html#how-are-events-modeled-in-floodadapt",
    "title": "Events",
    "section": "How are events modeled in FloodAdapt?",
    "text": "How are events modeled in FloodAdapt?\nFloodAdapt supports two levels of hydrodynamic models:\n\nAn overland model that calculates the inundation over land due to nearshore water levels, wind, rainfall, and river discharge. \nAn offshore model that calculates nearshore water levels (which are passed to the overland model) based on astronomic tides, wind fields and pressure fields. These nearshore water levels are used to force the overland model.\n\nWhen a user selects a Hurricane, FloodAdapt will pull in wind and pressure information about the track, and use this information to generate wind and pressure fields using the Holland 2010 method. It also uses the track information to estimate the rainfall field using the IPET method. The wind and pressure fields are used by the offshore model to calculate nearshore water levels. The nearshore water levels and estimated rainfall are then used as input to the overland flood model.\n\nFor a Historical event and for a Synthetic event, only the overland model will be run, using the water level, rainfall, wind, and river discharge information specified by the user.\n\n\n\n\n\n\nNoteWhy don‚Äôt I see ‚ÄúHurricane‚Äù event type?\n\n\n\nIn some cases, the Hurricane option may not be available. FloodAdapt uses two underlying flood models - an overland model (required) and an offshore model (optional). The overland model simulates flooding from rainfall, river discharge, wind, and water levels - this supports both the Historical and Synthetic even types. The offshore model adds the ability to simulate hurricanes by translating hurricane wind and pressure into nearshore water levels. If your system doesn‚Äôt include an offshore model, the Hurricane event type won‚Äôt appear.",
    "crumbs": [
      "Events"
    ]
  },
  {
    "objectID": "1_user_guide/events/synthetic_events.html",
    "href": "1_user_guide/events/synthetic_events.html",
    "title": "Synthetic events",
    "section": "",
    "text": "Synthetic events allow users to create a wide array of different types of events, without needing to have any recorded data. Each event component - water levels, wind, rainfall, and river discharge - can be specified using synthetic curves. This documentation walks the user through the different options.\nWhen the user selects the ‚ÄúSynthetic‚Äù option from the Events tab, they will see the event template window shown in Figure¬†1. This window allows the user to input synthetic time series for:",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "1_user_guide/events/synthetic_events.html#water-level",
    "href": "1_user_guide/events/synthetic_events.html#water-level",
    "title": "Synthetic events",
    "section": "Water level",
    "text": "Water level\nFor a synthetic event, there are two options to specify the water level time series: a simple option, and an advanced option. The simple option is what is shown by default in the event template window (Figure¬†1). The user only has to specify a peak water level (combined tide and surge) and the duration of the high water. For example, if average high tide is 6 ft + MLLW, a user might select 8 ft MLLW as a peak, with a duration of 12 hours. This superimposes a Gaussian surge of 2 ft with a 12 hour duration on top of the regular tidal series. The simple option always imposes the surge peak at the same time as high tide.\nThe advanced options appear when a user clicks the ‚ÄòAdvanced options‚Äô checkbox (see Figure¬†2). The user then can modify the tide and surge components separately. The tidal time series is defined by an amplitude above or below mean sea level, and a peak time which specifies when the high tide should occur relative to the start of the event. By default the peak time will be the midpoint of the event. The surge is specified by a ‚Äòshape‚Äô which can be a Gaussian, triangular or block shaped curve, the peak surge, the duration of the surge, and the timing of the surge peak relative to the start of the event. In general, the simple option is expected to suffice in most cases. In some cases, for example if a user wants to explore the sensitivity of the timing of a surge peak relative to high tide, the advanced options would be useful.\n\n\n\n\n\n\nFigure¬†2: Event template window showing the advanced options for the water level time series.\n\n\n\n\n\n\n\n\n\nNoteDatums in the water level plots\n\n\n\nThere are several datums shown in the water level plot (see Figure¬†1 or Figure¬†2): mean lower low water (MLLW), mean sea level (MSL), and mean higher high water (MHHW). These datums, as well as the reference level (the ‚Äòzero‚Äô in the plot), are configurable and chosen at system set-up to be most intuitive for the intended users of the system.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "1_user_guide/events/synthetic_events.html#rainfall",
    "href": "1_user_guide/events/synthetic_events.html#rainfall",
    "title": "Synthetic events",
    "section": "Rainfall",
    "text": "Rainfall\nFor a synthetic event, users can choose none, a constant intensity that will be applied over the entire duration of the event, or a synthetic rainfall (time series) curve.\n\nRainfall curves\nThere are four rainfall curves that a user can select to specify the rainfall time series. In each case, the user specifies the cumulative rainfall, the duration of the rainfall and the peak time of the rainfall relative to the start of the event.\n\nGaussian - the rainfall time series is based on a Gaussian curve.\nSCS - These curves, often used in practice in the US, were developed by the Soil Conservation Service (SCS), now known as the National Resources Conservation Service. They have a more peaked nature than a Gaussian curve and therefore represent a more intense rainfall event. There are three SCS rainfall curves for different parts of the US. The curve that a user can select in the event teplate window will already be configured for the site location (part of system set-up).\nBlock - the rainfall time series has a rectangular shape.\nTriangle - the rainfall time series has a triangular shape.\n\n\n\n\n\n\n\nFigure¬†3: The Gaussian, SCS, and block rainfall curves for a synthetic event. The top shows the Gaussian curve, the middle shows the SCS curve, and the bottom shows the block curve. All three represent three inches of rainfall over 12 hours (note: the vertical axis ranges are different in each plot)",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "1_user_guide/events/synthetic_events.html#wind",
    "href": "1_user_guide/events/synthetic_events.html#wind",
    "title": "Synthetic events",
    "section": "Wind",
    "text": "Wind\nFor a synthetic event, the user can only enter either none or a constant wind speed. When entering a constant wind speed, the user is asked to enter both the wind speed and wind direction. The direction should be entered in nautical degrees. This represents the direction where the wind is coming from. A direction of 0 degrees means wind is blowing from the North, 90 degrees means wind is blowing from the East.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "1_user_guide/events/synthetic_events.html#river-discharge",
    "href": "1_user_guide/events/synthetic_events.html#river-discharge",
    "title": "Synthetic events",
    "section": "River discharge",
    "text": "River discharge\nThe river discharge represents the discharge time series in a river at the model boundary. If there are multiple rivers at the model boundary, the user will be able to select each river to specify the discharge. The user has two options for specifying the river discharge: a constant discharge or a synthetic time series.\nConstant - A constant discharge is the default option. An average discharge value is filled in, which is specified in a FloodAdapt configuration folder at system setup. The user can change the value of the constant discharge.\nSynthetic - The synthetic option offers the option to use a Gaussian curve, a block shape or a triangle. The user must specify the base discharge (this can be left at the default value, which is the average discharge), a peak discharge, a duration, and a peak time. The duration refers to the duration that the river discharge is above its base value. For a block shape, the ‚Äòpeak time‚Äô is referred to as a ‚ÄòMidpoint‚Äô and is the time associated with the halfway point of the discharge block.",
    "crumbs": [
      "Events",
      "Synthetic events"
    ]
  },
  {
    "objectID": "1_user_guide/index.html",
    "href": "1_user_guide/index.html",
    "title": "FloodAdapt User Guide",
    "section": "",
    "text": "Welcome to the FloodAdapt user guide! This guide will help you learn how to set up and run scenarios to assess current and future flood impacts and risks. It also shows how to evaluate scenario output, and explore the benefits of different adaptation options. FloodAdapt lets you create, run, visualize, and compare scenarios. For an overview of what FloodAdapt is and how it works, see the Introduction page. To install the application and begin using it, head to the Getting Started page.\n\n\n\n\n\n\nNoteWhat is a scenario in FloodAdapt?\n\n\n\nA FloodAdapt ‚Äúscenario‚Äù refers to a combination of (1) a weather event that can lead to flooding, like a hurricane, coastal storm, or heavy rainfall, (2) a projection representing future socio-economic or climate conditions and (3) a strategy, which can include any number of adaptation options.\n\n\nFigure¬†1 shows the FloodAdapt application. There are a number of tabs in the lower panel. FloodAdapt is designed for users to walk through these tabs to create events, projections, measures, and strategies. The Scenarios tab then supports the creation and simulation of scenarios, after which results can be viewed in the Output and Comparison tabs. FloodAdapt also supports the evaluation of benefits in the Benefits tab.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt opens to the ‚ÄúSite‚Äù tab. The user walks through the various tabs to create events, projections, measures, strategies, and scenarios for simulation. There are also tabs for viewing output and for creating benefit analyses. This guide describes the process for each of the FloodAdapt tabs\n\n\n\nEach of the FloodAdapt tabs is described briefly below with a link to visit the detailed documentation for that tab. The user guide content can also be found in the left-hand navigation pane. Figure¬†2 presents a diagram showing the tabs of the user interface and highlighting the information needed to run scenarios and benefit analyses, and view results. \n\nThe Site tab is an informative tab where the user is not required to input any information.\nThe Events, Projections, Measures, and Strategy tabs are input tabs where the user will specify the ‚Äòingredients‚Äô for their scenarios.\nThe Scenarios tab is a management tab, where the user can specify and run scenarios.\n\n\n\nThe Output tab is where a user can view maps showing the flooding and impacts and see infometrics and an infographic for scenarios that have been run.\nThe user can compare scenarios spatially (map comparison) in the Compare - map tab and can compare scenarios based on their tabulated metrics in the Compare - table tab.\nThe user can evaluate the risk-reduction benefits of an adaptation strategy, including spatial distribution of benefits, and equity-weighted benefits in the Benefits tab.\n\n\n\n\n\n\n\nFigure¬†2: Tabs of the FloodAdapt user interface. Blue-grey fill indicates required user input, and the arrows show the flow of information from one tab to another.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "1_user_guide/measures/green_infra.html",
    "href": "1_user_guide/measures/green_infra.html",
    "title": "Urban green infrastructure",
    "section": "",
    "text": "Urban green infrastructure integrates natural elements like parks, green roofs, and permeable pavements into city landscapes to absorb, slow down, and manage stormwater runoff, thereby reducing flood risk and enhancing urban resilience. FloodAdapt includes a high-level representation of urban green infrastructure that is intended to help users identify the required capacity of urban green infrastructure solutions and the best placement of these options within the city to achieve community objectives. Currently there are three ‚Äòflavors‚Äô of urban green infrastructure that can be simulated and evaluated with FloodAdapt: water square, greening, and total storage. This section describes how these measures can be specified in FloodAdapt and how they are represented in the modeling.\nTo specify a green infrastructure measure, go to the Measures tab, and in the ‚ÄúCategory‚Äù drop-down menu select ‚ÄúGreen infrastructure‚Äù. Then for ‚ÄúMeasure‚Äù choose one of the three measure types: water square, greening, or total storage. Next, choose an ‚ÄúArea type‚Äù. This indicates how you will select the area to which you want to apply the green infrastructure measure. There are three options:\nWhen selecting an area to apply green infrastructure, it is useful to turn on the ‚Äúshow grid‚Äù option so you can see where the measure will be applied in the flood model.",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "1_user_guide/measures/green_infra.html#water-square",
    "href": "1_user_guide/measures/green_infra.html#water-square",
    "title": "Urban green infrastructure",
    "section": "Water Square",
    "text": "Water Square\nA water square is a multi-functional urban space designed to temporarily store excess rainwater during heavy rainfall, reducing flooding while providing recreational and aesthetic benefits during dry periods. A schematic of a water square is shown in Figure¬†2.\n\n\n\n\n\n\nFigure¬†2: A water square schematic, from https://urbangreenbluegrids.com/measures/water-squares/\n\n\n\nTo implement a water square in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúWater square‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\n\n\n\n\n\n\nFigure¬†3: Implementing a water square in FloodAdapt. This water square would affect two cells in the flood model by increasing their storage\n\n\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon that represents the shape of your water square. It is useful to turn on the ‚Äúshow grid‚Äù option so you can see where your water square will be implemented in the flood model. Figure¬†3 shows an implementation of a water square in FloodAdapt. In this example, the water square is implemented over two flood model grid cells, so those cells will have a higher storage capacity because of the water square. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your water square area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\nThe specification window is shown in Figure¬†8. In this window, you enter a name for the measure (no spaces or special characters), an optional description, and the depth of the water square. After entering the depth, click Enter. FloodAdapt will then automatically calculate the area of the water square (based on the selected area for the water square) and the total storage volume by multiplying the area with the specified water square depth. Additionally, there is also a ‚ÄúLook-up table‚Äù button. This shows suggestions for infiltration depths for different types of green infrastructure measures; see Figure¬†5. For the water square measure type, only the entry about water squares would be relevant.\n\n\n\n\n\n\nFigure¬†4: Water square specification window\n\n\n\n\n\n\n\n\n\nFigure¬†5: Lookup table with suggestions on infiltration depths for different types of green infrastructure solutions\n\n\n\n\n\n\n\n\n\nNoteWhere do the suggested infiltration depths come from?\n\n\n\nThe suggested infiltration depths in the green infrastructure lookup-table are based on the default values used in the Climate Reilient Cities Tool, which itself based these values on different sources in literature. Users are free to choose their own infiltration depth when they have more information, but the suggestions are intended to help users who may not know this information but already want to start high-level exploring of green infrastructure solutions in their community.",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "1_user_guide/measures/green_infra.html#greening",
    "href": "1_user_guide/measures/green_infra.html#greening",
    "title": "Urban green infrastructure",
    "section": "Greening",
    "text": "Greening\nGreening in FloodAdapt refers to the implementation of a collection of different types of individual measures that may be part of a green infrastructure design. This option allows you to specify an area and the percentage of that area where green infrastructure will be implemented. For example, let‚Äôs say the area of interest is a neighborhood, and the measure under consideration is a bioswale. In this case, you could estimate the area of the neighborhood where there are roads (for example, let‚Äôs say 10%), and then specify that 10% of the area will have an infiltration depth appropriate for a bioswale (see the lookup table shown in Figure¬†5).\n\n\n\n\n\n\nFigure¬†6: Examples of different green infrastructure measures (source: https://crctool.org/en/set-measure)\n\n\n\nTo implement the greening option in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúGreening‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon for the area where you want to apply green infrastructure. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\n\n\n\n\n\n\nFigure¬†7: Selecting an aggregation area for applying the green infrastructure option ‚Äúgreening‚Äù.\n\n\n\nThe specification window is shown in Figure¬†8. In this window, you enter a name for the measure (no spaces or special characters), an optional description, the percent of the selected area you wish to apply green infrastructure measures, and the infiltration depth of the measures. For this last entry, you can use the Look-up table (see Figure¬†5). This shows suggestions for infiltration depths for different types of green infrastructure measures. After entering the depth, click Enter. FloodAdapt will then automatically calculate the area where the green infrastructure will be applied (based on the selected area and the percent area to green) and the total storage volume by multiplying the green infrastructure area with the specified infiltration depth.\n\n\n\n\n\n\nFigure¬†8: Greening specification window",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "1_user_guide/measures/green_infra.html#total-storage",
    "href": "1_user_guide/measures/green_infra.html#total-storage",
    "title": "Urban green infrastructure",
    "section": "Total storage",
    "text": "Total storage\nTotal storage is the most appropriate option for high-level strategic planning of green infrastructure. It addresses key questions such as, ‚ÄúWhere should we implement green infrastructure?‚Äù and ‚ÄúHow much storage capacity do we need?‚Äù This green infrastructure option involves selecting an area and specifying a total increased storage volume from green infrastructure measures, without focusing on specific measures. This approach allows you to explore different storage capacities and identify what storage capacity you need to meet your planning targets. It also allows you to test out storage in different neighborhoods and see where you get the best result for different rainfall events. This can help give direction to landscape architects, who can look into more detail how to obtain the required storage in different areas of the city. Of course, it is always recommended to verify the increase in storage with more detailed models in the design phase.\nTo implement the Total storage option in FloodAdapt:\n\nGo to the Measures tab\nSelect ‚ÄúGreen infrastructure‚Äù for the Category\nFrom the Measure drop-down menu, select ‚ÄúTotal storage‚Äù\nSelect one of the ‚ÄúArea Type‚Äù options and then click ‚ÄúAdd Measure‚Äù\n\nIf you selected ‚ÄúDraw Polygon‚Äù, you can now begin drawing the polygon for the area where you want to apply green infrastructure. When you have finished drawing your polygon, you can double click to open the specification window. If you select ‚ÄúAggregation area‚Äù or ‚ÄúImport polygon‚Äù to define your area, the specification window will open immediately when you click ‚ÄúAdd measure‚Äù, and you will additionally be asked to specify the aggregation area or to upload your polygon as a spatial file, depending on what you chose.\nThe specification window is shown in Figure¬†9. In this window, you enter a name for the measure (no spaces or special characters), an optional description, and the total increased storage volume.\n\n\n\n\n\n\nFigure¬†9: Total storage specification window",
    "crumbs": [
      "Measures",
      "Urban green infrastructure"
    ]
  },
  {
    "objectID": "1_user_guide/measures/index.html",
    "href": "1_user_guide/measures/index.html",
    "title": "Measures",
    "section": "",
    "text": "FloodAdapt can simulate several types of adaptation measures. These fall under three categories within FloodAdapt:\nUsers enter measures in the Measures tab in FloodAdapt (see Figure¬†2). To get started specifying a measure, the user selects three options:\nClick on each of the category types (Hydraulic, Green Infrastructure, or Buildings) to see details about how to enter information for specific measures.",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/index.html#view-layers-in-the-measures-tab",
    "href": "1_user_guide/measures/index.html#view-layers-in-the-measures-tab",
    "title": "Measures",
    "section": "View layers in the Measures tab",
    "text": "View layers in the Measures tab\nAnother feature on the Measures tab is the ability to show a layer that can support or guide a user in determining where to implement measures. For example, a social vulnerability index layer, a disadvantaged communities layer, or an income layer may help the user to see where they want to focus their efforts to support more equitable adaptation planning. The layers that are visible in the Measures tab are configurable, so that communities can include the data that is most relevant for them. To view a layer, the user clicks the ‚ÄúShow Layer‚Äù dropdown menu (see Figure¬†2) and selects the layer they want to view.\n\n\n\n\n\n\nFigure¬†2: Measures tab in FloodAdapt",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "1_user_guide/measures/index.html#copying-editing-and-deleting-measures",
    "href": "1_user_guide/measures/index.html#copying-editing-and-deleting-measures",
    "title": "Measures",
    "section": "Copying, editing and deleting measures",
    "text": "Copying, editing and deleting measures\nFloodAdapt allows users to copy, edit, and delete measures they have already added. Copying measures is an efficient way to create multiple variations of a similar type of measure. For example, a user may want to evaluate elevating the same properties to different heights, or trying different heights for a floodwall.\nEditing measures allows the user to modify either the geometry of a measure or the measure parameters (these are specifications like the height of a wall). When a user selects ‚ÄúEdit measure‚Äù, FloodAdapt asks which of these a user would like to modify. If the user selects the geometry, they are able to modify polylines or polygons in the map. If they select parameters, the measure specification window opens and they can change parameters they specified.\nEditing and deleting measures is not permitted if the measure has already been used to specify a strategy. If the user wants to delete the measure, they must first delete the strategy which includes the measure.",
    "crumbs": [
      "Measures"
    ]
  },
  {
    "objectID": "1_user_guide/projections/climate.html",
    "href": "1_user_guide/projections/climate.html",
    "title": "Climate projections",
    "section": "",
    "text": "This section will describe how future projections of sea level rise, precipitation and tropical storm frequencies are specified and implemented in FloodAdapt.",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/climate.html#sea-level-rise",
    "href": "1_user_guide/projections/climate.html#sea-level-rise",
    "title": "Climate projections",
    "section": "Sea level rise",
    "text": "Sea level rise\nThere are two ways to specify sea level rise in the projections window: manually and from scenario.\nIf you select manually, you can type a number in the ‚ÄúSea Level Rise‚Äù (see Figure¬†2). You can then give your projection a name and (optionally) a description and click ‚ÄúOK‚Äù and your projection will show up in the FlodoAdapt Projections tab.\n\n\n\n\n\n\nFigure¬†2: Manually entering a sea level rise projection\n\n\n\nIf you select from scenario, a dropdown box will appear from which you can select the sea level rise scenario you want to use (see Figure¬†3). These options are configurable and are specified at system setup. Once you select a scenario, you specify a year and FloodAdapt will automatically calculate the sea level rise for that year, using the selected sea level rise scenario. You can then give your projection a name and (optionally) a description and click ‚ÄúOK‚Äù and your projection will show up in the FlodoAdapt Projections tab.\n\n\n\n\n\n\nFigure¬†3: Using a sea level rise scenario and a year to enter a sea level rise projection\n\n\n\n\n\n\n\n\n\nNoteSea level rise - since when?\n\n\n\nSea level rise scenarios have a starting point where sea level rise is zero (often, but not necessarily, starting at the year 2000). FloodAdapt corrects for this, using the ‚Äòcurrent year‚Äô, which is specified at system setup. So when a user chooses the ‚Äúfrom scenario‚Äù option to input a sea level rise projection for a future year, the sea level rise that is shown in the projections window is relative to the current year. This is done by subtracting the projected rise between the starting point and the current year, for each sea level rise scenario.\n\n\n\n\n\n\n\n\nNoteHow is the sea level rise projection represented in the modeling?\n\n\n\nWhen a user runs a scenario with a sea level rise projection, the sea level rise is added to the flood model‚Äôs coastal boundary condition. FloodAdapt treats this addition differently depending on the type of event. For a recent event using gauged water levels, the sea level rise in the current year relative to mean sea level is already represented in the measured water levels, so only the relative rise between the current year and future year is added. For a recent event without gauged water levels and for a historical hurricane, the offshore model calculates the nearshore coastal water levels relative to mean sea level. To correct for the sea level rise in the current year relative to mean sea level, an ‚Äòoffset‚Äô is added which is specified at system set-up. On top of this, the relative sea level rise between the current year and the future year is added to represent the future conditions.",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/climate.html#increased-precipitation",
    "href": "1_user_guide/projections/climate.html#increased-precipitation",
    "title": "Climate projections",
    "section": "Increased precipitation",
    "text": "Increased precipitation\nAn increase in precipitation is given as a percentage in the projections window (see Figure¬†4). You can give the projection a name and (optionally) a description and click ‚ÄúOK‚Äù and the projection will be added in the projections tab.\n\nWhy is this only for probabilistic event sets?\nIn the projection window, you see an indication that increased precipitation is for probabilistic events only. This is because for a single event, a user can explore a ‚Äòwhat-if‚Äô scenario about increased rainfall by adjusting the rainfall when they define an event (with the precipitation magnifier for a historical event, or with complete flexibility in defining rainfall for a synthetic event). For probabilistic event sets, the precpitation change needs to be applied to every event in the set, something that the user cannot do via the events tab.\n\n\n\n\n\n\nNoteWhat happens if I choose this projection for a single event scenario?\n\n\n\nIf you choose a projection of increased precipitation for a single event, it will work exactly as expected, and is identical to the precipitation magnifier option when you define your event. If you prefer to specify the increased precipitation via the projections tab instead of as a precipitation magnifier in the event tab, that is completely fine! Just be careful not to choose both, or the increase will be applied twice.\n\n\n\n\n\n\n\n\nFigure¬†4: Entering increased precipitation as a percentage increase",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/climate.html#increased-storm-frequency",
    "href": "1_user_guide/projections/climate.html#increased-storm-frequency",
    "title": "Climate projections",
    "section": "Increased storm frequency",
    "text": "Increased storm frequency\nAn increase in storm frequency is given as a percentage in the projections window (see Figure¬†5). This percentage is treated as an increase in the occurrence frequency of each tropical storm event in a probabilistic event set. This influences the return period flood maps and risk estimates, because when storms occur more frequently, the chance of storm flooding, and hence risk, increases.\n\n\n\n\n\n\nTipExample - increased storm frequency\n\n\n\nFor example, if you select a storm frequency increase of 10%, and a tropical storm in the event set had an occurrence frequency of once in 50 years (0.02), the increased frequency of this storm would be 0.022, or once in about 45 years.\n\n\n\nWhy is this only for probabilistic event sets?\nThe change in storm frequency will only affect the frequency of the storm. This frequency is used in the derivation of return period flood maps and the calculation of expected annual damages. For a single event, this frequency is not used.\n\n\n\n\n\n\nNoteWhat happens if I choose this projection for a single event scenario?\n\n\n\nIf you choose a projection of increased storm frequency for a single event, it will have no effect. The frequency is only used when calculating return period flood maps and risk, and for a single event scenario will play no role. It won‚Äôt do any harm, but it won‚Äôt have any effect on the resulting event-scenario flood and impact results.\n\n\n\n\n\n\n\n\nFigure¬†5: Entering increased storm frequency as a percentage increase",
    "crumbs": [
      "Projections",
      "Climate projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/socioEconomic.html",
    "href": "1_user_guide/projections/socioEconomic.html",
    "title": "Socio-economic projections",
    "section": "",
    "text": "This section will describe how future projections of population in existing built area, population growth in new development areas and economic growth are specified and implemented in FloodAdapt.",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/socioEconomic.html#population-growth---existing-built-area",
    "href": "1_user_guide/projections/socioEconomic.html#population-growth---existing-built-area",
    "title": "Socio-economic projections",
    "section": "Population growth - existing built area",
    "text": "Population growth - existing built area\nTo represent population growth in existing built areas within the community, the user can choose ‚ÄúPopulation Growth - Existing‚Äù (see Figure¬†1). The user enters a percentage (such as 10%) which represents the percentage of the current existing population. So if there are 100,000 people now living in a community, a 10% increase would represent an additional 10,000 residents.\n\n\n\n\n\n\nFigure¬†1: Entering a percentage population growth in the existing built area\n\n\n\nThe idea of the population growth option in existing built areas within FloodAdapt is that the building stock becomes either more dense (more buildings), or the existing residences are replaced by higher-density buildings like apartment buildings.\nThe implementation of population growthing within FloodAdapt is simplified. This is because users may not know where new buildings will be built or which buildings will be replaced by higher-density buildings to support future population growth. FloodAdapt therefore spreads the increase evenly over the entire building stock, by increasing the maximum potential damages of all the existing buildings. Figure¬†2 shows an example how this is implemented, highlighting one building. This increase is applied to all buildings equally, so that the overall increase in damages is reflective of the future situation with population growth.\n\n\n\n\n\n\nFigure¬†2: Simplification of population growth in the existing built area in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/socioEconomic.html#population-growth---new-development-areas",
    "href": "1_user_guide/projections/socioEconomic.html#population-growth---new-development-areas",
    "title": "Socio-economic projections",
    "section": "Population growth - new development areas",
    "text": "Population growth - new development areas\nTo evaluate future impacts of population growth specifically in new areas considered for development, users can choose the option ‚ÄúPopulation Growth - New (%)‚Äù (see Figure¬†3). This is an innovative feature of FloodAdapt which allows users to evaluate the flooding and impacts in areas considered for future development.\nThe user specifies the percentage of the current existing population that is projected to live in the new development area. For example, if the current population is 100,000, and the new development area is expected to support 1,000 new residents, the user would enter 1% for the population growth in the new area. The user is then asked to provide a shape file (or other spatial polygon file) specifying the boundaries of the new development area. In addition, the user can specify how high the new development will be built off the ground, either relative to a datum, or relative to base flood elevation (BFE). This allows users to explore the impact of regulations on how high new developments need to be built.\n\n\n\n\n\n\nFigure¬†3: Entering a percentage population growth for a new development area\n\n\n\nThe idea of population growth in new areas in FloodAdapt is that people will move to currently-undeveloped areas which will be zoned for residential or commercial use to accommodate population growth. This feature allows users to evaluate potential new development areas in terms of the impacts and risk that result.\nThe implementation of population growth in new areas in FloodAdapt is simplified. The user is not expected to know exactly where each new building will be located, or specifics about each building that are typically needed to calculated damages, such as maximum potential damages, or whether they will be one-story or two-story homes. Instead, FloodAdapt creates a composite building over the entire new development area. This composite building is currently assumed to reflect the make-up of the existing built area. For example, if the current built area is 80% residential, 18% commercial, and 2% government buildings, the new development will have this same composition. The way this is utilized in FloodAdapt is that the composite new-development building is assigned a depth-damage curve that is a weighted average of the depth-damage curves of the existing buildings. The maximum potential damage of the composite building is assumed to be the total maximum potential damages over all the existing buildings multiplied by the percentage population growth. For example, if the total maximum potential damages over all buildings in the area is $1 Billion, the maximum potential damages for a new development area with 1% population growth would be $10 Million. Because the new-development composite building is large, it is likely often partially flooded during flood events. FloodAdapt stores the flood depths over the entire new development area. It takes the average flood depth to calculate damages, but reduces these damages by the fraction of the area that is not flooded. For example, if the average flood depth leads to damages of $1 Million, but only 20% of the area was flooded, FloodAdapt will reduce the damages by 80% to $200,000. Figure¬†4 gives a visual representation of how population growth in new development areas is represented in FloodAdapt.\n\n\n\n\n\n\nFigure¬†4: Implementation of population growth in new development areas in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "1_user_guide/projections/socioEconomic.html#economic-growth",
    "href": "1_user_guide/projections/socioEconomic.html#economic-growth",
    "title": "Socio-economic projections",
    "section": "Economic growth",
    "text": "Economic growth\nTo evaluate economic growth, users can choose the option ‚ÄúEconomic Growth (%)‚Äù (see Figure¬†5). The user enters a percentage increase in economic growth.\nThe economic growth projection is implemented in a simplified way in FloodAdapt by increasing the maximum potential damages of the existing buildings by the specified percentage. This is a simplification intended to represent increasing wealth and value in the community, without specifically accounting for changes in economic activity which would lead to this wealth and value increase.\n\n\n\n\n\n\nFigure¬†5: Implementation of economic growth in FloodAdapt",
    "crumbs": [
      "Projections",
      "Socio-economic projections"
    ]
  },
  {
    "objectID": "1_user_guide/scenario_results/index.html",
    "href": "1_user_guide/scenario_results/index.html",
    "title": "Scenario results",
    "section": "",
    "text": "Coming soon.\n\n\n\n Back to top"
  },
  {
    "objectID": "1_user_guide/scenarios/index.html",
    "href": "1_user_guide/scenarios/index.html",
    "title": "Scenarios",
    "section": "",
    "text": "A scenario in FloodAdapt is a what-if situation and consists of a hydro-meteorological event, a climate and/or socio-economic projection, and a strategy. For example, a scenario could be ‚ÄúHurricane Ian (event) with 1 foot of sea level rise (projection) with a floodwall (strategy)‚Äù. This scenario could be compared with ‚ÄúHurricane Ian with 1 foot of sea level rise with no measures implemented‚Äù to see how well a floodwall would prevent flooding and damages for this event under future sea level rise. Once you have defined at least one event, projection, and strategy, you are ready to create a scenario. Users can evaluate both event scenarios and risk scenarios. For a risk scenario, users select an event set instead of a single event; event sets are created as part of system setup.\n\n\n\n\n\n\nNoteWhat is the difference between an event scenario and a risk scenario\n\n\n\nFor an event scenario FloodAdapt calculates the flooding and impacts for one single weather event, such as a hurricane or a king tide with rainfall. The scenario can include future projections and measures, but always represents just one single event. For a risk scenario, in contrast, FloodAdapt calculates flooding for a set of events with different probabilities. From this output, FloodAdapt derives return period flood maps (such as the 10-year, 25-year, or 100-year flood maps) and return period damage maps. It then combines this information to further derive expected annual damages, which is the metric associated with economic risk.\n\n\n\nIn the ‚ÄúScenarios‚Äù tab (see Figure¬†1) you will see a tabulated overview of any scenarios that have already been created. You can sort existing scenarios by name, date created, scenario component (event, project, or strategy), or run status (column ‚Äúfinished‚Äù) which indicates whether the scenario has been run (True) or not (False). Next to the table there are buttons to add, edit, or delete scenarios. Note that scenarios can only be edited or deleted if they have not yet been run.\n\n\n\n\n\n\nFigure¬†1: Scenarios tab in FloodAdapt\n\n\n\nTo create a new scenario, click ‚ÄúAdd scenario‚Äù to open the specification window (see Figure¬†2). In this window there are three panels for each of your scenario ingredients: event, projection, and strategy. Select the desired event, projection, and strategy for your scenario. The scenario name will automatically be generated based on your choice. You can keep that name or overwrite it with your own preferred scenario name (no spaces or special characters); you can also enter an optional description. When you have made your selection and are happy with the scenario name, click ‚ÄúOK‚Äù to add the scenario to the scenario window.\n\n\n\n\n\n\nFigure¬†2: Specifying a scenario in FloodAdapt, shown here for the scenario of Hurricane Ian with 1 foot of sea level rise and elevated homes\n\n\n\nTo run a scenario, select the scenario in the table and click the button ‚ÄúRun scenario‚Äù. The simulation will start and a pop-up window will appear informing that the scenario is running (see Figure¬†3). Sometimes the header in the popup window may say ‚ÄúNot Responding‚Äù but this can be ignored. The simulation may take several minutes. While the simulation is running you will not be able to work in the FloodAdapt application. When the simulation is finished, the pop-up window will disappear and the run status for your scenario will change from ‚ÄúFalse‚Äù to ‚ÄúTrue‚Äù.\n\n\n\n\n\n\nFigure¬†3: Popup indicating that a scenario is running\n\n\n\n\n\n\n\n\n\nTipRun multiple scenarios at once\n\n\n\nBecause scenarios can take several minutes to run, it can be efficient to run many scenarios at once, for example before your lunch break or at the end of the work day. This is also advantageous because the flood model can consume a lot of your computer‚Äôs computing power, which may make other applications run more slowly. To run many scenarios at once, simply select all the scenarios you wish to simulate and click ‚ÄúRun scenario‚Äù. FloodAdapt will then sequentially run the scenarios until they have all been completed.\n\n\n\n\n\n\n\n\nNoteCreating and running event scenarios versus risk scenarios\n\n\n\nCreating an event scenario and a risk scenario follow the same procedure. The only difference is that a risk scenario will select an event set from the event panel instead of a single event. You can identify which ‚Äòevents‚Äô are actually ‚Äòevent sets‚Äô in the Events tab. These events specify that the type is ‚ÄúProbabilistic Event Set‚Äù (see the figure in the description of the probabilistic event set). FloodAdapt recognizes this choice and initiates a risk calculation. Note that risk calculations take much longer because they include the simulation of flooding for every event in the event set. Calculation times for both event scenarios and risk scenarios will depend on the resolution of the underlying flood model, the duration of the event, and the specifications of the user‚Äôs computer. In general, event scenarios run on the order of a few minutes.\n\n\nTo view the output of your scenario you can proceed to the Output tab. To compare scenarios you can make use of the Compare - map and Compare - table tabs.\n\n\n\n Back to top",
    "crumbs": [
      "Scenarios"
    ]
  },
  {
    "objectID": "1_user_guide/strategy/index.html",
    "href": "1_user_guide/strategy/index.html",
    "title": "Strategies",
    "section": "",
    "text": "A strategy in FloodAdapt refers to a combination of measures. Users can define and name these strategies according to their own ideas and terminology. For example, a ‚Äúbusiness as usual‚Äù strategy could consist of no measures; a ‚Äúprotect‚Äù strategy could consist of floodwalls and levees, or an ‚Äúadapt‚Äù strategy could consist of elevating, floodproofing, or buying out properties. Defining at least one strategy is mandatory in FloodAdapt to run a scenario.\nThe ‚ÄúStrategies‚Äù tab (see Figure¬†1) contains an overview of the strategies that have already been created. You can select existing strategies in the left panel and in the right panel see the measures that are included in the strategy. The measures in the selected strategy also appear in the map window. If a description was added to the strategy when it was created, this will also appear to the right for the selected strategy. Next to the left panel there are buttons to add or delete strategies.\n\n\n\n\n\n\nFigure¬†1: Strategy tab in FloodAdapt\n\n\n\nTo create a new strategy, click ‚ÄúAdd strategy‚Äù. A dialogue window opens up (see Figure¬†2) within which you can choose the measures you want to include in your strategy. To add a measure to your strategy, select it in the left-hand panel and click the ‚ÄúApply measure‚Äù button. You can do this multiple times until you have selected all the measures you want to include in the strategy. In the right-hand panel you see the collection of measures that have been selected. If you want to remove one of these, you can select it in the right-hand panel and click the ‚ÄúRemove measure‚Äù button. You can give your strategy a name; this cannot contain any special characters or spaces. You can then (optionally) give a description of your strategy for future reference. Once you have selected the measures in your strategy and provided a name, click ‚ÄúOK‚Äù and the strategy will be added to the strategy window.\n\n\n\n\n\n\nFigure¬†2: Adding a strategy in FloodAdapt\n\n\n\n\n\n\n\n\n\nNoteThe ‚ÄúNo-measure strategy‚Äù\n\n\n\nTo create a no-measure strategy (also commonly referred to as ‚Äúcurrent situation‚Äù or ‚Äúbusiness as usual‚Äù), click ‚ÄúAdd Strategy‚Äù, then simply name the strategy and do not select any measures and click ‚ÄúOK‚Äù. Note that a no-measure strategy may be built in with your starting database, as this is recommended during system setup.\n\n\n\n\n\n\n\n\nWarningMultiple building-level measures are not allowed on the same buildings\n\n\n\nWhen building a strategy, users are not permitted to apply multiple building-level measures to the same buildings. This is because it wouldn‚Äôt make sense to elevate a home and then also buyout or floodproof the same home. If a user does build a strategy that would result in multiple buildling-level measures being applied to the same buildings, the user will get an error like the one shown below.\n\n\n\n\n\n\nFigure¬†3: Error warning when applying multiple building-level measures to the same buildings\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Strategies"
    ]
  },
  {
    "objectID": "2_technical_docs/EquityCalc.html",
    "href": "2_technical_docs/EquityCalc.html",
    "title": "Equity Calculation",
    "section": "",
    "text": "Equity methods seek to compensate for the unfair distribution in income when calculating flood damages. They rely on the concept of marginal utility of income, which holds that a loss of $1 for a rich person is not equivalent to the loss of $1 for a poor person. Utility is defined in economics as the satisfaction, usefulness, or happiness derived from - in this case - income. Equity weights are a way to correct for the inequality in marginal utility across income classes. Essentially, the equity weight represents the relative size of the marginal utility (a loss in utility due to a change in income - brought on in this case by flood damages) compared to the marginal utility for the community‚Äôs average income level. This leads to equity weights greater than 1 for incomes below average, and less than 1 for higher-than-average incomes. The equity weights are then used as a multiplicative factor on flood damages.\n\n\n\n\n\n\nFigure¬†1: Illustration of utility, and the marginal utility for high-income versus low-income community members.\n\n\n\nFloodAdapt includes a module which automatically calculates equity weights and applies them to risk estimates, using methods described in literature (1). The calculation framework of the module is depicted in Figure¬†2.\nInputs to the method are:\n\nMean per capita income (\\(M\\)) and population \\((P)\\) at aggregated scale, for example census block groups. This information can be obtained automatically when setting up the Delft-FIAT model\nReturn period damages per building \\(D\\) (output from the impact module in a risk calculation).\n\nThe module then does the following:\n\nCalculates the weighted average income per capita, weighted by population \\(I_{WA} = \\frac{\\sum (M_i \\cdot P_i)}{P}\\), where \\(i\\) represents the areas, for example census block groups.\nDerives the equity weight for each aggregated area: \\(EW_i = \\left(\\frac{M_i}{I_{WA}}\\right)^\\gamma\\). Note that \\(\\gamma\\) is set to 1.2. This parameter is expected to be made configurable by FloodAdapt users in future releases.\nCalculates for each return period \\(j\\) the equity-weighted damages per aggregation area \\(EWD_{i,j} = EW_i \\cdot D_{i,j}\\)\nIntegrates the equity-weighted damages over the return periods using log-linear interpolation to derive the equity-weighted expected annual damages for each aggreagation area.\n\n\n\n\n\n\n\nFigure¬†2: FloodAdapt calculation framework for equity-weighted risk estimates\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Equity Calculation"
    ]
  },
  {
    "objectID": "2_technical_docs/RiskScenario.html",
    "href": "2_technical_docs/RiskScenario.html",
    "title": "Risk Scenario",
    "section": "",
    "text": "A risk scenario is similar to an event scenario, but instead of running for one single event FloodAdapt runs the flood model for every event in a probabilistic event set. This is a set consisting of specifications for different (compound) events that can lead to flooding in the area and their occurrence frequencies. A paper describing how this event set was prepared for Charleston, South Carolina can be found here.\nThe hazard calculation and impact & risk calculation frameworks for a risk scenario are presented in the sections below.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/RiskScenario.html#hazard-calc",
    "href": "2_technical_docs/RiskScenario.html#hazard-calc",
    "title": "Risk Scenario",
    "section": "Hazard calculation",
    "text": "Hazard calculation\nFigure¬†1 zooms in on the hazard calculation portion of the FloodAdapt workflow for a risk scenario. Referring to the figure can support the description of the calculation.\nFor a risk scenario the hazard calculation involves both simulating the flooding for each event in the event set and the derivation of probabilistic return period maps. FloodAdapt modifies the SFINCS model based on adaptation options and calculates the flooding for each event in the event set in the same way it does for an event scenario. This is indicated in Figure¬†1 by a horizontal line, above which the event scenario and risk scenario are the same, except that the flood model is called multiple times to calculate flooding for each event in the event set. This workflow is described in the event scenario documentation and not repeated here. Below the horizontal line in Figure¬†1, the workflow for the risk scenario hazard is unique. Once the simulation for each event in the event set has been completed, the entire set of flood maps is passed into a probabilistic calculator. This is a routine that uses the event frequencies and simulated flood maps to create a water level-frequency curve for each grid cell in the flood model. It then derives from this curve the flood depth for the return periods specified for the site at system setup. From this output it creates gridded return period flood maps. A detailed description of the probabilistic calculator is given later on this page.\n\n\n\n\n\n\nFigure¬†1: FloodAdapt calculation framework for hazardfor a risk scenario",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/RiskScenario.html#impact-risk-calc",
    "href": "2_technical_docs/RiskScenario.html#impact-risk-calc",
    "title": "Risk Scenario",
    "section": "Impact and risk calculation",
    "text": "Impact and risk calculation\nFigure¬†2 zooms in on the impact and risk calculation portion of the FloodAdapt workflow for a risk scenario. Referring to the figure can support the description of the calculation.\n\n\n\n\n\n\nFigure¬†2: FloodAdapt calculation framework for impacts and risk for a risk scenario\n\n\n\nThe automatic updating of the Delft-FIAT model based on user-specified adaptation options and projections is identical to the handling in the event scenario. This workflow description is not repeated here.\nFor a risk scenario, FloodAdapt imports into Delft-FIAT the set of return period flood maps (calculated in the hazard framework with the use of the probabilistic calcultor). Delft-FIAT has an automatic risk module built in which calculates and outputs the direct economic damages to the assets in the exposure data for each input return period flood map. It uses this output to generate a damage-frequency curve (note that the exceedance frequency is the reciprocal of the return period). The expected annual damages (risk) are then calculated as the area under the damage-frequency curve (see Figure¬†3). The set of return periods will be finite, so Delft-FIAT makes approximations for return periods beyond what is calculated. For return periods higher than the highest calculated, it assumes economic damages equal to the highest calculated. For return periods lower than the lowest calculated, it assumes economic damages of zero. In FloodAdapt, users can choose the return periods for which damages will be calculated, to minimize these approxmiations. For example, users can take an upper limit for the return period of 500 or 1000 years and a lower limit of 1 year.\n\n\n\n\n\n\nFigure¬†3: Schematic of the risk calculation performed in Delft-FIAT. The damage-frequency curve is created using the damages calculated for the return period flood maps, and the risk is calculated as the area under the damage-frequency curve.\n\n\n\nAfter the return period damages and risk have been calculated by Delft-FIAT, FloodAdapt sends the output through a suite of postprocessing scripts to derive aggregated damages, spatial maps, risk metrics, and risk-related infographics. Additionally, FloodAdapt calls an Equity routine that calculates equity weights and applies them to risk estimates at an aggregated level for optional viewing in the user interface.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/RiskScenario.html#probCalculator",
    "href": "2_technical_docs/RiskScenario.html#probCalculator",
    "title": "Risk Scenario",
    "section": "The probabilistic calculator",
    "text": "The probabilistic calculator\nIn Figure¬†1, the simulated flood maps for the events in the event set, and the event occurrence frequencies, are passed into a module called ‚ÄúThe probabilistic calculator‚Äù. This section describes the method in that calculator to determine return period flood maps. The following steps are carried out for each grid cell in the SFINCS overland model. Each step is described below with supporting images.\n\nStep 1: Arrange water levels and frequencies in tables\nStep 2: Sort the water levels in descending order\nStep 3: Calculate the frequency of exceedance of the water levels\nStep 4: Calculate the return periods of the water levels\nStep 5: Calculate the water level associated with the return periods of interest\nStep 6: Convert water levels to water depths\n\n\nStep 1: Arrange water levels and frequencies in tables\nThe water levels for each grid cell (h) and their associated frequencies of occurrence (f) are arranged in two separate matrices with the number of rows equal to the number of events (j) and the number of columns equal to the number of grid cells (n). The example shown in Figure¬†4 illustrates the results for two fictitious grid cells and 10 fictitious events. To allow the reader to follow the approach more easily, the two highest and lowest values and their associated frequencies are highlighted in orange and blue throughout all steps.\n\n\n\n\n\n\nFigure¬†4: Left: Water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of occurrence. The two highest and lowest values and their associated frequencies are highlighted in orange and blue.\n\n\n\n\n\nStep 2: Sort the water levels in descending order\nThe water levels are sorted column-wise in descending order (see Figure¬†5). The matrix with the frequencies of occurrence are sorted in the same manner so that the frequency of occurrence has the same location in the right matrix as its corresponding water level value in the left matrix. The highest water level does not necessarily correspond to the lowest frequency of occurrence as in the example below.\n\n\n\n\n\n\nFigure¬†5: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of occurrence. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 3: Calculate the frequency of exceedance of the water levels\nTo calculate the frequencies of exceedance, the CFRSS cumulatively sums the frequencies of occurrence column-wise from the highest to lowest water level (see Figure¬†6). In the example, the frequency of exceedance for grid cell n=2 in the second row is 2.11E-03. This is the sum of the frequencies of occurrence of the first two rows from Table 6.4 (1.11E-03 + 1.00E-03).\n\n\n\n\n\n\nFigure¬†6: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated frequencies of exceedance. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 4: Calculate the return periods of the water levels\nThe return periods of water levels in each grid cell are then calculated as the inverse of the frequencies of exceedance (RP = 1/fexc); see Figure¬†7.\n\n\n\n\n\n\nFigure¬†7: Left: Sorted water levels per computational grid cell (columns) and event (rows). Right: Associated return periods of exceedance. The two highest and lowest values and their associated frequencies are highlighted in orange and blue, respectively.\n\n\n\n\n\nStep 5: Calculate the water level associated with the return periods of interest\nTo calculate the water levels for the return periods of interest specified in the site configuration file, FloodAdapt uses the ‚Äúlookup-table‚Äù from Step 4 (Figure¬†7) to derive the water level associated with each return period. The water levels in the lookup table are log-linearly interpolated between the return periods (see Figure¬†8 for an illustration).\n\n\n\n\n\n\nFigure¬†8: Water level versus return period in computational grid cell n=2. Water level at the desired output return period are interpolated log-linearly between data points.\n\n\n\nFor extrapolation outside of the bounds of the minimum and maximum return period in the lookup table, the following rules are applied:\n\nIf the return period of interest is larger than the maximum return period calculated for a given grid cell, the water level of the maximum return period is assigned to the return period of interest.\nIf the return period of interest is smaller than the minimum return period calculated for a given grid cell, the water level is set to zero in that grid cell for the return period of interest.\n\n\n\nStep 6: Convert water levels to water depths\nThe resulting return-period water levels for each grid cell are mapped onto the raster of the (typically finer-scale) DEM using the indices file that maps each SFINCS grid cell to its corresponding DEM raster cells. The land elevation is then subtracted from the water levels to obtain flood depths. These flood depth maps are then passed to the Delft-FIAT model to calculate impacts and risk.",
    "crumbs": [
      "Risk Scenario"
    ]
  },
  {
    "objectID": "2_technical_docs/index.html",
    "href": "2_technical_docs/index.html",
    "title": "FloodAdapt Technical documentation",
    "section": "",
    "text": "Welcome to the FloodAdapt technical documentation. This section is intended for readers with a technical or modeling background who want to better understand the calculations within FloodAdapt.\nThe technical documentation covers the technical details of four calculation frameworks:\nEach of these are introduced below with a link to the detailed documentation."
  },
  {
    "objectID": "2_technical_docs/index.html#event-scenarios",
    "href": "2_technical_docs/index.html#event-scenarios",
    "title": "FloodAdapt Technical documentation",
    "section": "Event scenarios",
    "text": "Event scenarios\n\n\n\n\n\n\nFigure¬†1: Scenario components: a future climate and/or socio-economic projection, a hydro-meteorological event, and a strategy\n\n\n\nAn event scenario in FloodAdapt is a what-if situation and consists of a hydro-meteorological event, a climate and/or socio-economic projection, and a strategy. For example, an event scenario could be ‚ÄúHurricane Ian (event) with 1 foot of sea level rise (projection) with a floodwall (strategy)‚Äù. This scenario could be compared with ‚ÄúHurricane Ian with 1 foot of sea level rise with no measures implemented‚Äù to see how well a floodwall would prevent flooding and damages for this event under future sea level rise. Once you have defined at least one event, projection, and strategy, you are ready to create a scenario. Users can evaluate both event scenarios and risk scenarios.\nClick here to read the technical documentation for an event scenario calculation"
  },
  {
    "objectID": "2_technical_docs/index.html#risk-scenarios",
    "href": "2_technical_docs/index.html#risk-scenarios",
    "title": "FloodAdapt Technical documentation",
    "section": "Risk scenarios",
    "text": "Risk scenarios\nA risk scenario is very similar to an event scenario. It also consists of a climate and/or socio-economic projection and a strategy. However, instead of being specified for one single hydro-meteorological event, a risk scenario consists of a set of (compound) events, all of which could lead to flooding in the project area. Each event in the set is also accompanied by a frequency of occurrence. FloodAdapt simulates the flooding for each event in the event set, and subsequently derives return period flood maps (such as the 10-year, 25-year, or 100-year flood maps) and return period damage maps. It then combines this information to further derive expected annual damages, which is the metric associated with economic risk.\nClick here to read the technical documentation for a risk scenario calculation"
  },
  {
    "objectID": "2_technical_docs/index.html#equity",
    "href": "2_technical_docs/index.html#equity",
    "title": "FloodAdapt Technical documentation",
    "section": "Equity",
    "text": "Equity\nEquity methods account for income disparity among residents in the community. The equity-weighting method used in Kind et al. is applied in FloodAdapt to calculated equity-weighted expected annual damages. The method makes use of the utility curve, which relates a loss in income to a loss in ‚Äòutility‚Äô or well-being. This changes depending on the income level. The equity weights are essentially the relative utility loss compared to the average in the community. The method relies on income and population data derived at census block group level, and therefore the equity-weighted expected annual damages are only available at this same scale.\nClick here to read more details about how the equity weights are calculated and applied in FloodAdapt"
  },
  {
    "objectID": "2_technical_docs/index.html#benefits",
    "href": "2_technical_docs/index.html#benefits",
    "title": "FloodAdapt Technical documentation",
    "section": "Benefits",
    "text": "Benefits\nFlood adaptation measures are designed to reduce flood risk, and are typically evaluated by calculating their risk-reduction benefits and the benefit-cost ratio, which compares benefits with the implementation and maintenance costs of the measure(s).\nFloodAdapt supports users in evaluating the risk-reduction benefits of strategies by automating the benefit calculation and guiding the user in the creation of the scenarios needed to calculate benefits. The user guide section on benefits provides comprehensive guidance on preparing and evaluating benefits in FloodAdapt.\nClick here to read technical documentation describing the benefit calculation in FloodAdapt."
  },
  {
    "objectID": "3_api_docs/api_ref/AggregationModel.html",
    "href": "3_api_docs/api_ref/AggregationModel.html",
    "title": "AggregationModel",
    "section": "",
    "text": "config.AggregationModel()\nThe accepted input for the variable aggregation in Site.\n\n\n\nname : str\n\nTODO\n\nfile : str\n\nTODO\n\nfield_name : str\n\nTODO\n\nequity : Optional[EquityModel], default=None\n\nTODO"
  },
  {
    "objectID": "3_api_docs/api_ref/AggregationModel.html#attributes",
    "href": "3_api_docs/api_ref/AggregationModel.html#attributes",
    "title": "AggregationModel",
    "section": "",
    "text": "name : str\n\nTODO\n\nfile : str\n\nTODO\n\nfield_name : str\n\nTODO\n\nequity : Optional[EquityModel], default=None\n\nTODO"
  },
  {
    "objectID": "3_api_docs/api_ref/Benefit.html",
    "href": "3_api_docs/api_ref/Benefit.html",
    "title": "Benefit",
    "section": "",
    "text": "objects.Benefit()\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\n\nname : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None."
  },
  {
    "objectID": "3_api_docs/api_ref/Benefit.html#attributes",
    "href": "3_api_docs/api_ref/Benefit.html#attributes",
    "title": "Benefit",
    "section": "",
    "text": "name : str\n\nThe name of the benefit analysis.\n\ndescription : str\n\nThe description of the benefit analysis. Defaults to ‚Äú‚Äú.\n\nstrategy : str\n\nThe name of the strategy. Should be a strategy saved in the database.\n\nevent_set : str\n\nThe name of the event set. Should be an event set saved in the database.\n\nprojection : str\n\nThe name of the projection. Should be a projection saved in the database.\n\nfuture_year : int\n\nThe future year for the analysis.\n\ncurrent_situation : CurrentSituationModel\n\nThe current situation model.\n\nbaseline_strategy : str\n\nThe name of the baseline strategy.\n\ndiscount_rate : float\n\nThe discount rate for the analysis.\n\nimplementation_cost : Optional[float]\n\nThe implementation cost of the strategy. Defaults to None.\n\nannual_maint_cost : Optional[float]\n\nThe annual maintenance cost of the strategy. Defaults to None."
  },
  {
    "objectID": "3_api_docs/api_ref/BenefitsModel.html",
    "href": "3_api_docs/api_ref/BenefitsModel.html",
    "title": "BenefitsModel",
    "section": "",
    "text": "config.BenefitsModel()\nThe accepted input for the variable benefits in Site.\n\n\n\ncurrent_year : int\n\nThe current year used in benefits calculations.\n\ncurrent_projection : str\n\nThe current projection used in benefits calculations.\n\nbaseline_strategy : str\n\nThe baseline strategy used in benefits calculations.\n\nevent_set : str\n\nThe event set used in benefits calculations."
  },
  {
    "objectID": "3_api_docs/api_ref/BenefitsModel.html#attributes",
    "href": "3_api_docs/api_ref/BenefitsModel.html#attributes",
    "title": "BenefitsModel",
    "section": "",
    "text": "current_year : int\n\nThe current year used in benefits calculations.\n\ncurrent_projection : str\n\nThe current projection used in benefits calculations.\n\nbaseline_strategy : str\n\nThe baseline strategy used in benefits calculations.\n\nevent_set : str\n\nThe event set used in benefits calculations."
  },
  {
    "objectID": "3_api_docs/api_ref/Buyout.html",
    "href": "3_api_docs/api_ref/Buyout.html",
    "title": "Buyout",
    "section": "",
    "text": "objects.Buyout()\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/Buyout.html#attributes",
    "href": "3_api_docs/api_ref/Buyout.html#attributes",
    "title": "Buyout",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/Cstype.html",
    "href": "3_api_docs/api_ref/Cstype.html",
    "title": "Cstype",
    "section": "",
    "text": "Cstype\nconfig.Cstype()\nThe accepted input for the variable cstype in Site.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/CycloneTrackDatabaseModel.html",
    "href": "3_api_docs/api_ref/CycloneTrackDatabaseModel.html",
    "title": "CycloneTrackDatabaseModel",
    "section": "",
    "text": "config.CycloneTrackDatabaseModel()\nThe accepted input for the variable cyclone_track_database in Site.\n\n\n\nfile : str\n\nThe path to the cyclone track database file."
  },
  {
    "objectID": "3_api_docs/api_ref/CycloneTrackDatabaseModel.html#attributes",
    "href": "3_api_docs/api_ref/CycloneTrackDatabaseModel.html#attributes",
    "title": "CycloneTrackDatabaseModel",
    "section": "",
    "text": "file : str\n\nThe path to the cyclone track database file."
  },
  {
    "objectID": "3_api_docs/api_ref/DemModel.html",
    "href": "3_api_docs/api_ref/DemModel.html",
    "title": "DemModel",
    "section": "",
    "text": "config.DemModel()\nThe accepted input for the variable dem in Site.\n\n\n\nfilename : str\n\nThe path to the digital elevation model file.\n\nunits : us.UnitTypesLength\n\nThe units of the digital elevation model file."
  },
  {
    "objectID": "3_api_docs/api_ref/DemModel.html#attributes",
    "href": "3_api_docs/api_ref/DemModel.html#attributes",
    "title": "DemModel",
    "section": "",
    "text": "filename : str\n\nThe path to the digital elevation model file.\n\nunits : us.UnitTypesLength\n\nThe units of the digital elevation model file."
  },
  {
    "objectID": "3_api_docs/api_ref/EquityModel.html",
    "href": "3_api_docs/api_ref/EquityModel.html",
    "title": "EquityModel",
    "section": "",
    "text": "config.EquityModel()\nThe accepted input for the variable equity in Site.\n\n\n\ncensus_data : str\n\nTODO\n\npercapitaincome_label : Optional[str], default=\"PerCapitaIncome\"\n\nTODO\n\ntotalpopulation_label : Optional[str], default=\"TotalPopulation\"\n\nTODO"
  },
  {
    "objectID": "3_api_docs/api_ref/EquityModel.html#attributes",
    "href": "3_api_docs/api_ref/EquityModel.html#attributes",
    "title": "EquityModel",
    "section": "",
    "text": "census_data : str\n\nTODO\n\npercapitaincome_label : Optional[str], default=\"PerCapitaIncome\"\n\nTODO\n\ntotalpopulation_label : Optional[str], default=\"TotalPopulation\"\n\nTODO"
  },
  {
    "objectID": "3_api_docs/api_ref/EventInfographicModel.html",
    "href": "3_api_docs/api_ref/EventInfographicModel.html",
    "title": "EventInfographicModel",
    "section": "",
    "text": "database_builder.EventInfographicModel()\nModel for event-based infographic configuration.\n\n\n\nbuildings : BuildingsInfographicModel | None, default=None\n\nBuildings infographic configuration.\n\nsvi : SviInfographicModel | None, default=None\n\nSVI infographic configuration.\n\nroads : RoadsInfographicModel | None, default=None\n\nRoads infographic configuration."
  },
  {
    "objectID": "3_api_docs/api_ref/EventInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/EventInfographicModel.html#attributes",
    "title": "EventInfographicModel",
    "section": "",
    "text": "buildings : BuildingsInfographicModel | None, default=None\n\nBuildings infographic configuration.\n\nsvi : SviInfographicModel | None, default=None\n\nSVI infographic configuration.\n\nroads : RoadsInfographicModel | None, default=None\n\nRoads infographic configuration."
  },
  {
    "objectID": "3_api_docs/api_ref/FiatConfigModel.html",
    "href": "3_api_docs/api_ref/FiatConfigModel.html",
    "title": "FiatConfigModel",
    "section": "",
    "text": "config.FiatConfigModel()\nConfiguration settings for the FIAT model.\n\n\n\nexposure_crs : str\n\nThe coordinate reference system of the exposure data.\n\nbfe : Optional[BFEModel], default=None\n\nThe base flood elevation model.\n\naggregation : list[AggregationModel]\n\nConfiguration for the aggregation model.\n\nfloodmap_type : FloodmapType\n\nThe type of flood map to be used.\n\nnon_building_names : Optional[list[str]], default=None\n\nList of non-building names to be used in the model.\n\ndamage_unit : str, default=\"$\"\n\nThe unit of damage used in the model.\n\nbuilding_footprints : Optional[str], default=None\n\nPath to the building footprints data.\n\nroads_file_name : Optional[str], default=None\n\nPath to the roads data.\n\nnew_development_file_name : Optional[str], default=\"new_development_area.gpkg\"\n\nPath to the new development area data.\n\nsave_simulation : Optional[bool], default=False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.\n\nsvi : Optional[SVIModel], default=None\n\nThe social vulnerability index model.\n\ninfographics : Optional[bool], default=False\n\nWhether to create infographics or not.\n\nno_footprints : Optional[NoFootprintsModel], default=NoFootprintsModel()\n\nConfiguration for objects with no footprints."
  },
  {
    "objectID": "3_api_docs/api_ref/FiatConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/FiatConfigModel.html#attributes",
    "title": "FiatConfigModel",
    "section": "",
    "text": "exposure_crs : str\n\nThe coordinate reference system of the exposure data.\n\nbfe : Optional[BFEModel], default=None\n\nThe base flood elevation model.\n\naggregation : list[AggregationModel]\n\nConfiguration for the aggregation model.\n\nfloodmap_type : FloodmapType\n\nThe type of flood map to be used.\n\nnon_building_names : Optional[list[str]], default=None\n\nList of non-building names to be used in the model.\n\ndamage_unit : str, default=\"$\"\n\nThe unit of damage used in the model.\n\nbuilding_footprints : Optional[str], default=None\n\nPath to the building footprints data.\n\nroads_file_name : Optional[str], default=None\n\nPath to the roads data.\n\nnew_development_file_name : Optional[str], default=\"new_development_area.gpkg\"\n\nPath to the new development area data.\n\nsave_simulation : Optional[bool], default=False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.\n\nsvi : Optional[SVIModel], default=None\n\nThe social vulnerability index model.\n\ninfographics : Optional[bool], default=False\n\nWhether to create infographics or not.\n\nno_footprints : Optional[NoFootprintsModel], default=NoFootprintsModel()\n\nConfiguration for objects with no footprints."
  },
  {
    "objectID": "3_api_docs/api_ref/FieldMapping.html",
    "href": "3_api_docs/api_ref/FieldMapping.html",
    "title": "FieldMapping",
    "section": "",
    "text": "database_builder.FieldMapping()\nRepresents a mapping of a database field to a list of allowed values.\n\n\n\nfield_name : str\n\nThe name of the database field/column\n\nvalues : list[str]\n\nList of values that should match this field\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_sql_filter\nGenerate SQL filter string for this field mapping.\n\n\n\n\n\ndatabase_builder.FieldMapping.to_sql_filter()\nGenerate SQL filter string for this field mapping.\n\n\n\n : str\n\nSQL WHERE clause condition string for this field mapping."
  },
  {
    "objectID": "3_api_docs/api_ref/FieldMapping.html#attributes",
    "href": "3_api_docs/api_ref/FieldMapping.html#attributes",
    "title": "FieldMapping",
    "section": "",
    "text": "field_name : str\n\nThe name of the database field/column\n\nvalues : list[str]\n\nList of values that should match this field"
  },
  {
    "objectID": "3_api_docs/api_ref/FieldMapping.html#methods",
    "href": "3_api_docs/api_ref/FieldMapping.html#methods",
    "title": "FieldMapping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_sql_filter\nGenerate SQL filter string for this field mapping.\n\n\n\n\n\ndatabase_builder.FieldMapping.to_sql_filter()\nGenerate SQL filter string for this field mapping.\n\n\n\n : str\n\nSQL WHERE clause condition string for this field mapping."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodExceedanceModel.html",
    "href": "3_api_docs/api_ref/FloodExceedanceModel.html",
    "title": "FloodExceedanceModel",
    "section": "",
    "text": "database_builder.FloodExceedanceModel()\nModel for flood exceedance probability configuration.\n\n\n\ncolumn : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database column name for flood depth measurements.\n\nthreshold : float, default=0.1\n\nThe flood depth threshold value.\n\nunit : str, default=\"meters\"\n\nThe unit of measurement for the threshold.\n\nperiod : int, default=30\n\nThe time period in years for exceedance analysis."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodExceedanceModel.html#attributes",
    "href": "3_api_docs/api_ref/FloodExceedanceModel.html#attributes",
    "title": "FloodExceedanceModel",
    "section": "",
    "text": "column : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database column name for flood depth measurements.\n\nthreshold : float, default=0.1\n\nThe flood depth threshold value.\n\nunit : str, default=\"meters\"\n\nThe unit of measurement for the threshold.\n\nperiod : int, default=30\n\nThe time period in years for exceedance analysis."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodMapLayer.html",
    "href": "3_api_docs/api_ref/FloodMapLayer.html",
    "title": "FloodMapLayer",
    "section": "",
    "text": "FloodMapLayer\nconfig.FloodMapLayer()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/FloodProof.html",
    "href": "3_api_docs/api_ref/FloodProof.html",
    "title": "FloodProof",
    "section": "",
    "text": "objects.FloodProof()\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodProof.html#attributes",
    "href": "3_api_docs/api_ref/FloodProof.html#attributes",
    "title": "FloodProof",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúfloodproof_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties."
  },
  {
    "objectID": "3_api_docs/api_ref/FloodmapType.html",
    "href": "3_api_docs/api_ref/FloodmapType.html",
    "title": "FloodmapType",
    "section": "",
    "text": "FloodmapType\nconfig.FloodmapType()\nThe accepted input for the variable floodmap in Site.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/FootprintsOptions.html",
    "href": "3_api_docs/api_ref/FootprintsOptions.html",
    "title": "FootprintsOptions",
    "section": "",
    "text": "database_builder.FootprintsOptions()\nEnumeration for building footprints data sources.\n\n\nOSM : Use OpenStreetMap for building footprints.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "FootprintsOptions"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/FootprintsOptions.html#values",
    "href": "3_api_docs/api_ref/FootprintsOptions.html#values",
    "title": "FootprintsOptions",
    "section": "",
    "text": "OSM : Use OpenStreetMap for building footprints.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "FootprintsOptions"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/GreenInfrastructure.html",
    "href": "3_api_docs/api_ref/GreenInfrastructure.html",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "objects.GreenInfrastructure()\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]"
  },
  {
    "objectID": "3_api_docs/api_ref/GreenInfrastructure.html#attributes",
    "href": "3_api_docs/api_ref/GreenInfrastructure.html#attributes",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure."
  },
  {
    "objectID": "3_api_docs/api_ref/GreenInfrastructure.html#methods",
    "href": "3_api_docs/api_ref/GreenInfrastructure.html#methods",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]"
  },
  {
    "objectID": "3_api_docs/api_ref/GuiModel.html",
    "href": "3_api_docs/api_ref/GuiModel.html",
    "title": "GuiModel",
    "section": "",
    "text": "config.GuiModel()\nThe accepted input for the variable gui in Site.\n\n\n\nunits : GuiUnitModel\n\nThe unit system used in the GUI.\n\noutput_layers : OutputLayers\n\nThe configuration of the mapbox layers in the GUI.\n\nvisualization_layers : VisualizationLayers\n\nThe configuration of the visualization layers in the GUI.\n\nplotting : PlottingModel\n\nThe configuration for creating hazard forcing plots."
  },
  {
    "objectID": "3_api_docs/api_ref/GuiModel.html#attributes",
    "href": "3_api_docs/api_ref/GuiModel.html#attributes",
    "title": "GuiModel",
    "section": "",
    "text": "units : GuiUnitModel\n\nThe unit system used in the GUI.\n\noutput_layers : OutputLayers\n\nThe configuration of the mapbox layers in the GUI.\n\nvisualization_layers : VisualizationLayers\n\nThe configuration of the visualization layers in the GUI.\n\nplotting : PlottingModel\n\nThe configuration for creating hazard forcing plots."
  },
  {
    "objectID": "3_api_docs/api_ref/HistoricalEvent.html",
    "href": "3_api_docs/api_ref/HistoricalEvent.html",
    "title": "HistoricalEvent",
    "section": "",
    "text": "objects.HistoricalEvent()\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "3_api_docs/api_ref/HistoricalEvent.html#attributes",
    "href": "3_api_docs/api_ref/HistoricalEvent.html#attributes",
    "title": "HistoricalEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Historical.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event."
  },
  {
    "objectID": "3_api_docs/api_ref/HurricaneEvent.html",
    "href": "3_api_docs/api_ref/HurricaneEvent.html",
    "title": "HurricaneEvent",
    "section": "",
    "text": "objects.HurricaneEvent()\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track."
  },
  {
    "objectID": "3_api_docs/api_ref/HurricaneEvent.html#attributes",
    "href": "3_api_docs/api_ref/HurricaneEvent.html#attributes",
    "title": "HurricaneEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track."
  },
  {
    "objectID": "3_api_docs/api_ref/ImpactCategoriesModel.html",
    "href": "3_api_docs/api_ref/ImpactCategoriesModel.html",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "database_builder.ImpactCategoriesModel()\nModel for defining impact categories with associated colors, field, unit, and bins.\n\n\n\ncategories : list[str], default=[\"Minor\", \"Major\", \"Severe\"]\n\nList of impact category names.\n\ncolors : list[str], default=[\"#ffa500\", \"#ff0000\", \"#000000\"]\n\nList of colors corresponding to each category.\n\nfield : str\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nbins : list[float]\n\nList of threshold values for binning the field values.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nvalidate_bins_length\nValidate that bins list length is one less than categories list length.\n\n\nvalidate_colors_length\nValidate that colors list length matches categories list length.\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_bins_length(bins, info)\nValidate that bins list length is one less than categories list length.\n\n\n\nbins : list[float]\n\nList of bin threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated bins list.\n\n\n\n\n\n\n: ValueError\n\nIf bins length is not one less than categories length.\n\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_colors_length(colors, info)\nValidate that colors list length matches categories list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match categories length."
  },
  {
    "objectID": "3_api_docs/api_ref/ImpactCategoriesModel.html#attributes",
    "href": "3_api_docs/api_ref/ImpactCategoriesModel.html#attributes",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "categories : list[str], default=[\"Minor\", \"Major\", \"Severe\"]\n\nList of impact category names.\n\ncolors : list[str], default=[\"#ffa500\", \"#ff0000\", \"#000000\"]\n\nList of colors corresponding to each category.\n\nfield : str\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nbins : list[float]\n\nList of threshold values for binning the field values."
  },
  {
    "objectID": "3_api_docs/api_ref/ImpactCategoriesModel.html#methods",
    "href": "3_api_docs/api_ref/ImpactCategoriesModel.html#methods",
    "title": "ImpactCategoriesModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nvalidate_bins_length\nValidate that bins list length is one less than categories list length.\n\n\nvalidate_colors_length\nValidate that colors list length matches categories list length.\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_bins_length(bins, info)\nValidate that bins list length is one less than categories list length.\n\n\n\nbins : list[float]\n\nList of bin threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated bins list.\n\n\n\n\n\n\n: ValueError\n\nIf bins length is not one less than categories length.\n\n\n\n\n\n\ndatabase_builder.ImpactCategoriesModel.validate_colors_length(colors, info)\nValidate that colors list length matches categories list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match categories length."
  },
  {
    "objectID": "3_api_docs/api_ref/MeasureType.html",
    "href": "3_api_docs/api_ref/MeasureType.html",
    "title": "MeasureType",
    "section": "",
    "text": "objects.MeasureType()\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\nEach type of measure is associated with a category (hazard or impact) and can be used to determine the type of measure.\n\n\n\nfloodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure."
  },
  {
    "objectID": "3_api_docs/api_ref/MeasureType.html#attributes",
    "href": "3_api_docs/api_ref/MeasureType.html#attributes",
    "title": "MeasureType",
    "section": "",
    "text": "floodwall : A floodwall measure.\n\n\n\nthin_dam : A thin dam measure.\n\n\n\nlevee : A levee measure.\n\n\n\npump : A pump measure.\n\n\n\nculvert : A culvert measure.\n\n\n\nwater_square : A water square measure.\n\n\n\ngreening : A greening measure.\n\n\n\ntotal_storage : A total storage measure.\n\n\n\nelevate_properties : An elevate properties measure.\n\n\n\nbuyout_properties : A buyout properties measure.\n\n\n\nfloodproof_properties : A floodproof properties measure."
  },
  {
    "objectID": "3_api_docs/api_ref/Mode.html",
    "href": "3_api_docs/api_ref/Mode.html",
    "title": "Mode",
    "section": "",
    "text": "objects.Mode()\nClass describing the accepted input for the variable mode in Event.\n\n\n\nsingle_event : The single event mode.\n\n\n\nrisk : The risk mode."
  },
  {
    "objectID": "3_api_docs/api_ref/Mode.html#attributes",
    "href": "3_api_docs/api_ref/Mode.html#attributes",
    "title": "Mode",
    "section": "",
    "text": "single_event : The single event mode.\n\n\n\nrisk : The risk mode."
  },
  {
    "objectID": "3_api_docs/api_ref/Object.html",
    "href": "3_api_docs/api_ref/Object.html",
    "title": "Object",
    "section": "",
    "text": "objects.object_model.Object()\nBase class for FloodAdapt objects.\n\n\n\nname : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nsave\nSave object to disk.\n\n\nsave_additional\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\n\n\n\n\n\nobjects.object_model.Object.load_file(\n    file_path: Path | str | os.PathLike,\n    **kwargs,\n)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.object_model.Object.save(toml_path: Path | str | os.PathLike)\nSave object to disk.\n\n\n\ntoml_path : Path | str | os.PathLike\n\nPath to the file to save.\n\n\n\n\n\n\nobjects.object_model.Object.save_additional(\n    output_dir: Path | str | os.PathLike,\n)\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\nThis method should be overridden if the object has additional files.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Object.html#attributes",
    "href": "3_api_docs/api_ref/Object.html#attributes",
    "title": "Object",
    "section": "",
    "text": "name : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Object.html#methods",
    "href": "3_api_docs/api_ref/Object.html#methods",
    "title": "Object",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nLoad object from file.\n\n\nsave\nSave object to disk.\n\n\nsave_additional\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\n\n\n\n\n\nobjects.object_model.Object.load_file(\n    file_path: Path | str | os.PathLike,\n    **kwargs,\n)\nLoad object from file.\n\n\n\nfile_path : Path | str | os.PathLike\n\nPath to the file to load.\n\n\n\n\n\n\nobjects.object_model.Object.save(toml_path: Path | str | os.PathLike)\nSave object to disk.\n\n\n\ntoml_path : Path | str | os.PathLike\n\nPath to the file to save.\n\n\n\n\n\n\nobjects.object_model.Object.save_additional(\n    output_dir: Path | str | os.PathLike,\n)\nSave additional files to database if the object has any and update attrs to reflect the change in file location.\nThis method should be overridden if the object has additional files.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Object"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/OutputLayers.html",
    "href": "3_api_docs/api_ref/OutputLayers.html",
    "title": "OutputLayers",
    "section": "",
    "text": "config.OutputLayers()\nThe configuration of the mapbox layers in the gui.\n\n\n\nfloodmap : FloodMapLayer\n\nThe configuration of the floodmap layer.\n\naggregation_dmg : AggregationDmgLayer\n\nThe configuration of the aggregation damage layer.\n\nfootprints_dmg : FootprintsDmgLayer\n\nThe configuration of the footprints damage layer.\n\nbenefits : BenefitsLayer\n\nThe configuration of the benefits layer."
  },
  {
    "objectID": "3_api_docs/api_ref/OutputLayers.html#attributes",
    "href": "3_api_docs/api_ref/OutputLayers.html#attributes",
    "title": "OutputLayers",
    "section": "",
    "text": "floodmap : FloodMapLayer\n\nThe configuration of the floodmap layer.\n\naggregation_dmg : AggregationDmgLayer\n\nThe configuration of the aggregation damage layer.\n\nfootprints_dmg : FootprintsDmgLayer\n\nThe configuration of the footprints damage layer.\n\nbenefits : BenefitsLayer\n\nThe configuration of the benefits layer."
  },
  {
    "objectID": "3_api_docs/api_ref/PlottingModel.html",
    "href": "3_api_docs/api_ref/PlottingModel.html",
    "title": "PlottingModel",
    "section": "",
    "text": "config.PlottingModel()\nThe configuration of the plotting in the gui.\n\n\n\nexcluded_datums : list[str]\n\nA list of datums that will be excluded from the forcing plot in event windows.\n\nsynthetic_tide : SyntheticTideModel\n\nThe configuration of the synthetic tide."
  },
  {
    "objectID": "3_api_docs/api_ref/PlottingModel.html#attributes",
    "href": "3_api_docs/api_ref/PlottingModel.html#attributes",
    "title": "PlottingModel",
    "section": "",
    "text": "excluded_datums : list[str]\n\nA list of datums that will be excluded from the forcing plot in event windows.\n\nsynthetic_tide : SyntheticTideModel\n\nThe configuration of the synthetic tide."
  },
  {
    "objectID": "3_api_docs/api_ref/Pump.html",
    "href": "3_api_docs/api_ref/Pump.html",
    "title": "Pump",
    "section": "",
    "text": "objects.Pump()\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall."
  },
  {
    "objectID": "3_api_docs/api_ref/Pump.html#attributes",
    "href": "3_api_docs/api_ref/Pump.html#attributes",
    "title": "Pump",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúpump‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolyline‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLength\n\nHeight of the floodwall."
  },
  {
    "objectID": "3_api_docs/api_ref/RiskModel.html",
    "href": "3_api_docs/api_ref/RiskModel.html",
    "title": "RiskModel",
    "section": "",
    "text": "config.RiskModel()\nThe accepted input for the variable risk in Site.\n\n\n\nreturn_periods : list[int]\n\nThe return periods for the risk model."
  },
  {
    "objectID": "3_api_docs/api_ref/RiskModel.html#attributes",
    "href": "3_api_docs/api_ref/RiskModel.html#attributes",
    "title": "RiskModel",
    "section": "",
    "text": "return_periods : list[int]\n\nThe return periods for the risk model."
  },
  {
    "objectID": "3_api_docs/api_ref/RoadsInfographicModel.html",
    "href": "3_api_docs/api_ref/RoadsInfographicModel.html",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "database_builder.RoadsInfographicModel()\nModel for roads infographic configuration.\n\n\n\ncategories : list[str], default=[\"Slight\", \"Minor\", \"Major\", \"Severe\"]\n\nList of road impact category names.\n\ncolors : list[str], default=[\"#e0f7fa\", \"#80deea\", \"#26c6da\", \"#006064\"]\n\nList of colors corresponding to each category.\n\nicons : list[str], default=[\"walking_person\", \"car\", \"truck\", \"ambulance\"]\n\nList of icon names for each category.\n\nusers : list[str], default=[\"Pedestrians\", \"Cars\", \"Trucks\", \"Rescue vehicles\"]\n\nList of road user types for each category.\n\nthresholds : list[float]\n\nList of threshold values for categorizing road impacts.\n\nfield : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nroad_length_field : str, default=_IMPACT_COLUMNS.segment_length\n\nThe database field name containing road segment lengths.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for roads infographics.\n\n\nvalidate_lengths\nValidate that all list attributes have the same length.\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.get_template(\n    unit_system: Literal['metric', 'imperial'],\n)\nGet a pre-configured template for roads infographics.\n\n\n\nunit_system : Literal['metric', 'imperial']\n\nThe unit system to use for thresholds and measurements.\n\n\n\n\n\n\n : RoadsInfographicModel\n\nPre-configured roads infographic model.\n\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.validate_lengths(v, info)\nValidate that all list attributes have the same length.\n\n\n\nv : list[str]\n\nThe categories list.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated categories list.\n\n\n\n\n\n\n: ValueError\n\nIf list attributes don‚Äôt have the same length."
  },
  {
    "objectID": "3_api_docs/api_ref/RoadsInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/RoadsInfographicModel.html#attributes",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "categories : list[str], default=[\"Slight\", \"Minor\", \"Major\", \"Severe\"]\n\nList of road impact category names.\n\ncolors : list[str], default=[\"#e0f7fa\", \"#80deea\", \"#26c6da\", \"#006064\"]\n\nList of colors corresponding to each category.\n\nicons : list[str], default=[\"walking_person\", \"car\", \"truck\", \"ambulance\"]\n\nList of icon names for each category.\n\nusers : list[str], default=[\"Pedestrians\", \"Cars\", \"Trucks\", \"Rescue vehicles\"]\n\nList of road user types for each category.\n\nthresholds : list[float]\n\nList of threshold values for categorizing road impacts.\n\nfield : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nroad_length_field : str, default=_IMPACT_COLUMNS.segment_length\n\nThe database field name containing road segment lengths."
  },
  {
    "objectID": "3_api_docs/api_ref/RoadsInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/RoadsInfographicModel.html#methods",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for roads infographics.\n\n\nvalidate_lengths\nValidate that all list attributes have the same length.\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.get_template(\n    unit_system: Literal['metric', 'imperial'],\n)\nGet a pre-configured template for roads infographics.\n\n\n\nunit_system : Literal['metric', 'imperial']\n\nThe unit system to use for thresholds and measurements.\n\n\n\n\n\n\n : RoadsInfographicModel\n\nPre-configured roads infographic model.\n\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.validate_lengths(v, info)\nValidate that all list attributes have the same length.\n\n\n\nv : list[str]\n\nThe categories list.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated categories list.\n\n\n\n\n\n\n: ValueError\n\nIf list attributes don‚Äôt have the same length."
  },
  {
    "objectID": "3_api_docs/api_ref/Scenario.html",
    "href": "3_api_docs/api_ref/Scenario.html",
    "title": "Scenario",
    "section": "",
    "text": "objects.Scenario()\nBaseModel describing the expected variables and data types of a scenario.\nA scenario is a combination of an event, a projection, and a strategy, that all should be saved in the database.\n\n\n\nevent : str\n\nThe name of the event. Must not be empty.\n\nprojection : str\n\nThe name of the projection. Must not be empty.\n\nstrategy : str\n\nThe name of the strategy. Must not be empty."
  },
  {
    "objectID": "3_api_docs/api_ref/Scenario.html#attributes",
    "href": "3_api_docs/api_ref/Scenario.html#attributes",
    "title": "Scenario",
    "section": "",
    "text": "event : str\n\nThe name of the event. Must not be empty.\n\nprojection : str\n\nThe name of the projection. Must not be empty.\n\nstrategy : str\n\nThe name of the strategy. Must not be empty."
  },
  {
    "objectID": "3_api_docs/api_ref/SelectionType.html",
    "href": "3_api_docs/api_ref/SelectionType.html",
    "title": "SelectionType",
    "section": "",
    "text": "objects.SelectionType()\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\nIt is used to determine where to apply the measure to a model.\n\n\n\naggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database."
  },
  {
    "objectID": "3_api_docs/api_ref/SelectionType.html#attributes",
    "href": "3_api_docs/api_ref/SelectionType.html#attributes",
    "title": "SelectionType",
    "section": "",
    "text": "aggregation_area : Use aggregation area as geometry for the measure.\n\n\n\npolygon : Use polygon as geometry for the measure.\n\n\n\npolyline : Use polyline as geometry for the measure.\n\n\n\nall : Apply the measure to all geometries in the database."
  },
  {
    "objectID": "3_api_docs/api_ref/SfincsConfigModel.html",
    "href": "3_api_docs/api_ref/SfincsConfigModel.html",
    "title": "SfincsConfigModel",
    "section": "",
    "text": "config.SfincsConfigModel()\nThe expected variables and data types of attributes of the SfincsConfig class.\n\n\n\ncsname : str\n\nThe name of the CS model.\n\ncstype : Cstype\n\nCstype of the CS model. must be either ‚Äúprojected‚Äù or ‚Äúspherical‚Äù.\n\nversion : Optional[str], default = None\n\nThe version of the CS model. If None, the version is not specified.\n\noffshore_model : Optional[FloodModel], default = None\n\nThe offshore model. If None, the offshore model is not specified.\n\noverland_model : FloodModel\n\nThe overland model. This is the main model used for the simulation.\n\nfloodmap_units : us.UnitTypesLength\n\nThe units used for the output floodmap. Sfincs always produces in metric units, this is used to convert the floodmap to the correct units.\n\nsave_simulation : Optional[bool], default = False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted."
  },
  {
    "objectID": "3_api_docs/api_ref/SfincsConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/SfincsConfigModel.html#attributes",
    "title": "SfincsConfigModel",
    "section": "",
    "text": "csname : str\n\nThe name of the CS model.\n\ncstype : Cstype\n\nCstype of the CS model. must be either ‚Äúprojected‚Äù or ‚Äúspherical‚Äù.\n\nversion : Optional[str], default = None\n\nThe version of the CS model. If None, the version is not specified.\n\noffshore_model : Optional[FloodModel], default = None\n\nThe offshore model. If None, the offshore model is not specified.\n\noverland_model : FloodModel\n\nThe overland model. This is the main model used for the simulation.\n\nfloodmap_units : us.UnitTypesLength\n\nThe units used for the output floodmap. Sfincs always produces in metric units, this is used to convert the floodmap to the correct units.\n\nsave_simulation : Optional[bool], default = False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted."
  },
  {
    "objectID": "3_api_docs/api_ref/Site.html",
    "href": "3_api_docs/api_ref/Site.html",
    "title": "Site",
    "section": "",
    "text": "Site()\nThe expected variables and data types of attributes of the Site class.\n\n\n\nname : str\n\nName of the site.\n\ndescription : str\n\nDescription of the site. Defaults to ‚Äú‚Äú.\n\nlat : float\n\nLatitude of the site.\n\nlon : float\n\nLongitude of the site.\n\nstandard_objects : StandardObjectModel, default=StandardObjectModel()\n\nStandard objects of the site.\n\nis_coastal : bool\n\nIndicates whether the site is coastal.\n\ngui : GuiModel\n\nGUI model of the site.\n\nsfincs : SfincsModel\n\nSFincs model of the site.\n\nfiat : FiatModel\n\nFiat model of the site.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_file\nCreate Site from toml file.\n\n\nsave\nWrite toml file from model object.\n\n\n\n\n\nSite.load_file(filepath: Union[str, os.PathLike])\nCreate Site from toml file.\n\n\n\nSite.save(\n    filepath: Union[str, os.PathLike],\n    sfincs: str = 'sfincs.toml',\n    fiat: str = 'fiat.toml',\n    gui: str = 'gui.toml',\n)\nWrite toml file from model object.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Site.html#attributes",
    "href": "3_api_docs/api_ref/Site.html#attributes",
    "title": "Site",
    "section": "",
    "text": "name : str\n\nName of the site.\n\ndescription : str\n\nDescription of the site. Defaults to ‚Äú‚Äú.\n\nlat : float\n\nLatitude of the site.\n\nlon : float\n\nLongitude of the site.\n\nstandard_objects : StandardObjectModel, default=StandardObjectModel()\n\nStandard objects of the site.\n\nis_coastal : bool\n\nIndicates whether the site is coastal.\n\ngui : GuiModel\n\nGUI model of the site.\n\nsfincs : SfincsModel\n\nSFincs model of the site.\n\nfiat : FiatModel\n\nFiat model of the site.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/Site.html#methods",
    "href": "3_api_docs/api_ref/Site.html#methods",
    "title": "Site",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_file\nCreate Site from toml file.\n\n\nsave\nWrite toml file from model object.\n\n\n\n\n\nSite.load_file(filepath: Union[str, os.PathLike])\nCreate Site from toml file.\n\n\n\nSite.save(\n    filepath: Union[str, os.PathLike],\n    sfincs: str = 'sfincs.toml',\n    fiat: str = 'fiat.toml',\n    gui: str = 'gui.toml',\n)\nWrite toml file from model object.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Site"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/SocioEconomicChange.html",
    "href": "3_api_docs/api_ref/SocioEconomicChange.html",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "objects.SocioEconomicChange()\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\npopulation_growth_existing : float\n\nThe population growth percentage of the existing area. default=0.0\n\neconomic_growth : float\n\nThe economic growth percentage. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth percentage for the new development areas. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of the new development areas. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of the new development areas. default=None.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nserialize_new_development_shapefile\nSerialize the new_development_shapefile attribute to a string of only the file name.\n\n\n\n\n\nobjects.SocioEconomicChange.serialize_new_development_shapefile(\n    value: Optional[str],\n)\nSerialize the new_development_shapefile attribute to a string of only the file name."
  },
  {
    "objectID": "3_api_docs/api_ref/SocioEconomicChange.html#attributes",
    "href": "3_api_docs/api_ref/SocioEconomicChange.html#attributes",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "population_growth_existing : float\n\nThe population growth percentage of the existing area. default=0.0\n\neconomic_growth : float\n\nThe economic growth percentage. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth percentage for the new development areas. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of the new development areas. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of the new development areas. default=None."
  },
  {
    "objectID": "3_api_docs/api_ref/SocioEconomicChange.html#methods",
    "href": "3_api_docs/api_ref/SocioEconomicChange.html#methods",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nserialize_new_development_shapefile\nSerialize the new_development_shapefile attribute to a string of only the file name.\n\n\n\n\n\nobjects.SocioEconomicChange.serialize_new_development_shapefile(\n    value: Optional[str],\n)\nSerialize the new_development_shapefile attribute to a string of only the file name."
  },
  {
    "objectID": "3_api_docs/api_ref/StandardObjectModel.html",
    "href": "3_api_docs/api_ref/StandardObjectModel.html",
    "title": "StandardObjectModel",
    "section": "",
    "text": "StandardObjectModel\nconfig.StandardObjectModel()\nThe accepted input for the variable standard_object in Site.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "3_api_docs/api_ref/SubEventModel.html",
    "href": "3_api_docs/api_ref/SubEventModel.html",
    "title": "SubEventModel",
    "section": "",
    "text": "objects.SubEventModel()\nThe accepted input for a sub event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event."
  },
  {
    "objectID": "3_api_docs/api_ref/SubEventModel.html#attributes",
    "href": "3_api_docs/api_ref/SubEventModel.html#attributes",
    "title": "SubEventModel",
    "section": "",
    "text": "name : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event."
  },
  {
    "objectID": "3_api_docs/api_ref/SviModel.html",
    "href": "3_api_docs/api_ref/SviModel.html",
    "title": "SviModel",
    "section": "",
    "text": "database_builder.SviModel()\nModel for Social Vulnerability Index (SVI) configuration.\n\n\n\nclasses : list[str], default=[\"Low\", \"High\"]\n\nList of vulnerability class names.\n\ncolors : list[str], default=[\"#D5DEE1\", \"#88A2AA\"]\n\nList of colors corresponding to each vulnerability class.\n\nthresholds : list[float], default=[0.7]\n\nList of threshold values for vulnerability classification.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nvalidate_colors_length\nValidate that colors list length matches classes list length.\n\n\nvalidate_thresholds_length\nValidate that thresholds list length is one less than classes list length.\n\n\n\n\n\ndatabase_builder.SviModel.validate_colors_length(colors, info)\nValidate that colors list length matches classes list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match classes length.\n\n\n\n\n\n\ndatabase_builder.SviModel.validate_thresholds_length(thresholds, info)\nValidate that thresholds list length is one less than classes list length.\n\n\n\nthresholds : list[float]\n\nList of threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated thresholds list.\n\n\n\n\n\n\n: ValueError\n\nIf thresholds length is not one less than classes length."
  },
  {
    "objectID": "3_api_docs/api_ref/SviModel.html#attributes",
    "href": "3_api_docs/api_ref/SviModel.html#attributes",
    "title": "SviModel",
    "section": "",
    "text": "classes : list[str], default=[\"Low\", \"High\"]\n\nList of vulnerability class names.\n\ncolors : list[str], default=[\"#D5DEE1\", \"#88A2AA\"]\n\nList of colors corresponding to each vulnerability class.\n\nthresholds : list[float], default=[0.7]\n\nList of threshold values for vulnerability classification."
  },
  {
    "objectID": "3_api_docs/api_ref/SviModel.html#methods",
    "href": "3_api_docs/api_ref/SviModel.html#methods",
    "title": "SviModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nvalidate_colors_length\nValidate that colors list length matches classes list length.\n\n\nvalidate_thresholds_length\nValidate that thresholds list length is one less than classes list length.\n\n\n\n\n\ndatabase_builder.SviModel.validate_colors_length(colors, info)\nValidate that colors list length matches classes list length.\n\n\n\ncolors : list[str]\n\nList of color values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated colors list.\n\n\n\n\n\n\n: ValueError\n\nIf colors length doesn‚Äôt match classes length.\n\n\n\n\n\n\ndatabase_builder.SviModel.validate_thresholds_length(thresholds, info)\nValidate that thresholds list length is one less than classes list length.\n\n\n\nthresholds : list[float]\n\nList of threshold values.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[float]\n\nThe validated thresholds list.\n\n\n\n\n\n\n: ValueError\n\nIf thresholds length is not one less than classes length."
  },
  {
    "objectID": "3_api_docs/api_ref/SyntheticTideModel.html",
    "href": "3_api_docs/api_ref/SyntheticTideModel.html",
    "title": "SyntheticTideModel",
    "section": "",
    "text": "config.SyntheticTideModel()\nConfiguration for the synthetic tide.\n\n\n\nharmonic_amplitude : us.UnitfulLength\n\nThe amplitude of the tide harmonic relative to the datum.\n\ndatum : str\n\nThe datum to which the harmonic amplitude is relative. Should be a datum defined in site.sfincs.waterlevels.datums"
  },
  {
    "objectID": "3_api_docs/api_ref/SyntheticTideModel.html#attributes",
    "href": "3_api_docs/api_ref/SyntheticTideModel.html#attributes",
    "title": "SyntheticTideModel",
    "section": "",
    "text": "harmonic_amplitude : us.UnitfulLength\n\nThe amplitude of the tide harmonic relative to the datum.\n\ndatum : str\n\nThe datum to which the harmonic amplitude is relative. Should be a datum defined in site.sfincs.waterlevels.datums"
  },
  {
    "objectID": "3_api_docs/api_ref/TideGaugeConfigModel.html",
    "href": "3_api_docs/api_ref/TideGaugeConfigModel.html",
    "title": "TideGaugeConfigModel",
    "section": "",
    "text": "database_builder.TideGaugeConfigModel()\nModel for tide gauge configuration.\n\n\n\nsource : TideGaugeSource\n\nSource of tide gauge data.\n\ndescription : str\n\nDescription of the tide gauge.\n\nref : Optional[str]\n\nReference name (should match water level references).\n\nid : Optional[int]\n\nStation ID.\n\nlon : Optional[float]\n\nLongitude.\n\nlat : Optional[float]\n\nLatitude.\n\nfile : Optional[str]\n\nPath to tide gauge data file.\n\nmax_distance : Optional[us.UnitfulLength]\n\nMaximum distance for gauge association.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "TideGaugeConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/TideGaugeConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/TideGaugeConfigModel.html#attributes",
    "title": "TideGaugeConfigModel",
    "section": "",
    "text": "source : TideGaugeSource\n\nSource of tide gauge data.\n\ndescription : str\n\nDescription of the tide gauge.\n\nref : Optional[str]\n\nReference name (should match water level references).\n\nid : Optional[int]\n\nStation ID.\n\nlon : Optional[float]\n\nLongitude.\n\nlat : Optional[float]\n\nLatitude.\n\nfile : Optional[str]\n\nPath to tide gauge data file.\n\nmax_distance : Optional[us.UnitfulLength]\n\nMaximum distance for gauge association.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "TideGaugeConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/TimeFrame.html",
    "href": "3_api_docs/api_ref/TimeFrame.html",
    "title": "TimeFrame",
    "section": "",
    "text": "objects.TimeFrame()\nClass representing a time frame for a simulation.\n\n\n\nstart_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration."
  },
  {
    "objectID": "3_api_docs/api_ref/TimeFrame.html#attributes",
    "href": "3_api_docs/api_ref/TimeFrame.html#attributes",
    "title": "TimeFrame",
    "section": "",
    "text": "start_time : datetime\n\nThe start time of the simulation.\n\nend_time : datetime\n\nThe end time of the simulation.\n\ntime_step : timedelta\n\nThe time step of the simulation. Default is calculated as 1/1000 of the duration."
  },
  {
    "objectID": "3_api_docs/api_ref/UnitSystems.html",
    "href": "3_api_docs/api_ref/UnitSystems.html",
    "title": "UnitSystems",
    "section": "",
    "text": "database_builder.UnitSystems()\nEnumeration for supported unit systems.\n\n\nimperial : Imperial units (feet, miles, etc.) metric : Metric units (meters, kilometers, etc.)",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "UnitSystems"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitSystems.html#values",
    "href": "3_api_docs/api_ref/UnitSystems.html#values",
    "title": "UnitSystems",
    "section": "",
    "text": "imperial : Imperial units (feet, miles, etc.) metric : Metric units (meters, kilometers, etc.)",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "UnitSystems"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesDirection.html",
    "href": "3_api_docs/api_ref/UnitTypesDirection.html",
    "title": "UnitTypesDirection",
    "section": "",
    "text": "unit_system.UnitTypesDirection()\nUnits of direction.\n\n\n\ndegrees : degrees",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDirection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesDirection.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesDirection.html#attributes",
    "title": "UnitTypesDirection",
    "section": "",
    "text": "degrees : degrees",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesDirection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesIntensity.html",
    "href": "3_api_docs/api_ref/UnitTypesIntensity.html",
    "title": "UnitTypesIntensity",
    "section": "",
    "text": "unit_system.UnitTypesIntensity()\nUnits of intensity.\n\n\n\ninch_hr : inch per hour\n\n\n\nmm_hr : millimeter per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesIntensity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesIntensity.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesIntensity.html#attributes",
    "title": "UnitTypesIntensity",
    "section": "",
    "text": "inch_hr : inch per hour\n\n\n\nmm_hr : millimeter per hour",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesIntensity"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesTime.html",
    "href": "3_api_docs/api_ref/UnitTypesTime.html",
    "title": "UnitTypesTime",
    "section": "",
    "text": "unit_system.UnitTypesTime()\nUnits of time.\n\n\n\nseconds : seconds\n\n\n\nminutes : minutes\n\n\n\nhours : hours\n\n\n\ndays : days",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesTime"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesTime.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesTime.html#attributes",
    "title": "UnitTypesTime",
    "section": "",
    "text": "seconds : seconds\n\n\n\nminutes : minutes\n\n\n\nhours : hours\n\n\n\ndays : days",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesTime"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesVolume.html",
    "href": "3_api_docs/api_ref/UnitTypesVolume.html",
    "title": "UnitTypesVolume",
    "section": "",
    "text": "unit_system.UnitTypesVolume()\nUnits of volume.\n\n\n\nm3 : cubic meters\n\n\n\ncf : cubic feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVolume"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitTypesVolume.html#attributes",
    "href": "3_api_docs/api_ref/UnitTypesVolume.html#attributes",
    "title": "UnitTypesVolume",
    "section": "",
    "text": "m3 : cubic meters\n\n\n\ncf : cubic feet",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitTypesVolume"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulDirection.html",
    "href": "3_api_docs/api_ref/UnitfulDirection.html",
    "title": "UnitfulDirection",
    "section": "",
    "text": "unit_system.UnitfulDirection()\nCombination of direction and unit.\n\n\n\nvalue : float\n\nThe direction value, must be greater than or equal to 0 and less than or equal to 360.\n\nunits : UnitTypesDirection\n\nThe unit of direction.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDirection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulDirection.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulDirection.html#attributes",
    "title": "UnitfulDirection",
    "section": "",
    "text": "value : float\n\nThe direction value, must be greater than or equal to 0 and less than or equal to 360.\n\nunits : UnitTypesDirection\n\nThe unit of direction.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulDirection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulHeight.html",
    "href": "3_api_docs/api_ref/UnitfulHeight.html",
    "title": "UnitfulHeight",
    "section": "",
    "text": "unit_system.UnitfulHeight()\nCombination of height and unit.\n\n\n\nvalue : float\n\nThe height value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of height.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulHeight"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulHeight.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulHeight.html#attributes",
    "title": "UnitfulHeight",
    "section": "",
    "text": "value : float\n\nThe height value, must be greater than or equal to 0.\n\nunits : UnitTypesLength\n\nThe unit of height.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulHeight"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulLength.html",
    "href": "3_api_docs/api_ref/UnitfulLength.html",
    "title": "UnitfulLength",
    "section": "",
    "text": "unit_system.UnitfulLength()\nCombination of length and unit.\n\n\n\nvalue : float\n\nThe length value.\n\nunits : UnitTypesLength\n\nThe unit of length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLength"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulLength.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulLength.html#attributes",
    "title": "UnitfulLength",
    "section": "",
    "text": "value : float\n\nThe length value.\n\nunits : UnitTypesLength\n\nThe unit of length.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulLength"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulTime.html",
    "href": "3_api_docs/api_ref/UnitfulTime.html",
    "title": "UnitfulTime",
    "section": "",
    "text": "unit_system.UnitfulTime()\nCombination of time and unit.\n\n\n\nvalue : float\n\nThe time value.\n\nunits : UnitTypesTime\n\nThe unit of time.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_timedelta\nConvert given timedelta to UnitfulTime object.\n\n\nto_timedelta\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n\n\nunit_system.UnitfulTime.from_timedelta(td: timedelta)\nConvert given timedelta to UnitfulTime object.\n\n\n\nunit_system.UnitfulTime.to_timedelta()\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n : datetime.timedelta\n\ndatetime.timedelta object with representation: (days, seconds, microseconds)",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulTime.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulTime.html#attributes",
    "title": "UnitfulTime",
    "section": "",
    "text": "value : float\n\nThe time value.\n\nunits : UnitTypesTime\n\nThe unit of time.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulTime.html#methods",
    "href": "3_api_docs/api_ref/UnitfulTime.html#methods",
    "title": "UnitfulTime",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_timedelta\nConvert given timedelta to UnitfulTime object.\n\n\nto_timedelta\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n\n\nunit_system.UnitfulTime.from_timedelta(td: timedelta)\nConvert given timedelta to UnitfulTime object.\n\n\n\nunit_system.UnitfulTime.to_timedelta()\nConvert given time to datetime.deltatime object, relative to UnitfulTime(0, Any).\n\n\n\n : datetime.timedelta\n\ndatetime.timedelta object with representation: (days, seconds, microseconds)",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulTime"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulVolume.html",
    "href": "3_api_docs/api_ref/UnitfulVolume.html",
    "title": "UnitfulVolume",
    "section": "",
    "text": "unit_system.UnitfulVolume()\nCombination of volume and unit.\n\n\n\nvalue : float\n\nThe volume value, must be greater than or equal to 0.\n\nunits : UnitTypesVolume\n\nThe unit of volume.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVolume"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/UnitfulVolume.html#attributes",
    "href": "3_api_docs/api_ref/UnitfulVolume.html#attributes",
    "title": "UnitfulVolume",
    "section": "",
    "text": "value : float\n\nThe volume value, must be greater than or equal to 0.\n\nunits : UnitTypesVolume\n\nThe unit of volume.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "UnitfulVolume"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/VerticalReference.html",
    "href": "3_api_docs/api_ref/VerticalReference.html",
    "title": "VerticalReference",
    "section": "",
    "text": "unit_system.VerticalReference()\nVertical reference for height.\n\n\n\nfloodmap : Use the floodmap as reference.\n\n\n\ndatum : Use the datum as reference.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "VerticalReference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/VerticalReference.html#attributes",
    "href": "3_api_docs/api_ref/VerticalReference.html#attributes",
    "title": "VerticalReference",
    "section": "",
    "text": "floodmap : Use the floodmap as reference.\n\n\n\ndatum : Use the datum as reference.",
    "crumbs": [
      "API Reference",
      "Unit system",
      "VerticalReference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/VisualizationLayers.html",
    "href": "3_api_docs/api_ref/VisualizationLayers.html",
    "title": "VisualizationLayers",
    "section": "",
    "text": "config.VisualizationLayers()\nThe configuration of the layers you might want to visualize in the gui.\n\n\n\nbuildings_min_zoom_level : int\n\nThe minimum zoom level before building footprints become visible in the map.\n\ntopography_cmin : float\n\nDefault minimum for DEM color scaling.\n\ntopography_cmax : float\n\nDefault maximum for DEM color scaling.\n\nlayers : list[VisualizationLayer]\n\nThe extra layers to visualize."
  },
  {
    "objectID": "3_api_docs/api_ref/VisualizationLayers.html#attributes",
    "href": "3_api_docs/api_ref/VisualizationLayers.html#attributes",
    "title": "VisualizationLayers",
    "section": "",
    "text": "buildings_min_zoom_level : int\n\nThe minimum zoom level before building footprints become visible in the map.\n\ntopography_cmin : float\n\nDefault minimum for DEM color scaling.\n\ntopography_cmax : float\n\nDefault maximum for DEM color scaling.\n\nlayers : list[VisualizationLayer]\n\nThe extra layers to visualize."
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html",
    "href": "3_api_docs/api_ref/api_index.html",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Class that contains the main functionality of FloodAdapt.\n\n\n\nFloodAdapt\n\n\n\n\n\n\n\nConfiguration settings for FloodAdapt.\n\n\n\nSettings\nThe configuration settings for the FloodAdapt database and integrator.\n\n\nSite\nThe expected variables and data types of attributes of the Site class.\n\n\n\n\n\nConfiguration settings for visualizations and the GUI\n\n\n\nGuiModel\nThe accepted input for the variable gui in Site.\n\n\nGuiUnitModel\nThe unit system used in the GUI.\n\n\nOutputLayers\nThe configuration of the mapbox layers in the gui.\n\n\nVisualizationLayer\nThe configuration of a layer to visualize in the gui.\n\n\nVisualizationLayers\nThe configuration of the layers you might want to visualize in the gui.\n\n\nPlottingModel\nThe configuration of the plotting in the gui.\n\n\nStandardObjectModel\nThe accepted input for the variable standard_object in Site.\n\n\nFloodMapLayer\n\n\n\nAggregationDmgLayer\n\n\n\nFootprintsDmgLayer\n\n\n\nBenefitsLayer\n\n\n\nSyntheticTideModel\nConfiguration for the synthetic tide.\n\n\n\n\n\n\nConfiguration settings for hazard models\n\n\n\nCstype\nThe accepted input for the variable cstype in Site.\n\n\nCycloneTrackDatabaseModel\nThe accepted input for the variable cyclone_track_database in Site.\n\n\nDatumModel\nThe accepted input for the variable datums in WaterlevelReferenceModel.\n\n\nDemModel\nThe accepted input for the variable dem in Site.\n\n\nFloodFrequencyModel\nThe accepted input for the variable flood_frequency in Site.\n\n\nFloodModel\nThe accepted input for the variable overland_model and offshore_model in Site.\n\n\nObsPointModel\nThe accepted input for the variable obs_point in Site.\n\n\nRiverModel\nModel that describes the accepted input for the variable river in Site.\n\n\nSCSModel\nClass describing the accepted input for the variable scs.\n\n\nScstype\n\n\n\nSlrScenariosModel\nThe accepted input for the variable slr_scenarios.\n\n\nWaterlevelReferenceModel\nThe accepted input for the variable water_level in Site.\n\n\n\n\n\n\nConfiguration settings for Sfincs models\n\n\n\nSfincsConfigModel\nThe expected variables and data types of attributes of the SfincsConfig class.\n\n\nSfincsModel\nThe expected variables and data types of attributes of the Sfincs class.\n\n\n\n\n\n\nConfiguration settings for impact models\n\n\n\nAggregationModel\nThe accepted input for the variable aggregation in Site.\n\n\nBenefitsModel\nThe accepted input for the variable benefits in Site.\n\n\nEquityModel\nThe accepted input for the variable equity in Site.\n\n\nFloodmapType\nThe accepted input for the variable floodmap in Site.\n\n\nNoFootprintsModel\nThe configuration on the how to show objects with no footprints.\n\n\nRiskModel\nThe accepted input for the variable risk in Site.\n\n\n\n\n\n\nConfiguration settings for Fiat models\n\n\n\nFiatConfigModel\nConfiguration settings for the FIAT model.\n\n\nFiatModel\nThe expected variables and data types of attributes of the Fiat class.\n\n\n\n\n\n\n\nObject models in FloodAdapt are the components that are saved in the database. They define the configuration, input and output of the model kernels. The database stores Objects, and returns Objects when queried.\n\n\n\nObject\nBase class for FloodAdapt objects.\n\n\n\n\n\nVarious flood protection and mitigation measures available that can interact with the models. Can be impact measures or a hazard measures, where impact measures do not affect the hazard model at all, and hazard measures do.\n\n\n\nMeasure\nThe expected variables and data types of attributes common to all measures.\n\n\nMeasureType\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\n\n\nSelectionType\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\n\n\nFloodWall\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\nGreenInfrastructure\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\nPump\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\nBuyout\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\nElevate\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\nFloodProof\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\n\n\n\nA collection of measures that can be used to define a strategy for flood risk management.\n\n\n\nStrategy\nClass representing a strategy in FloodAdapt.\n\n\n\n\n\n\nEvent types including historical, synthetic, and hurricane events.\n\n\n\nEvent\nThe accepted input for an event in FloodAdapt.\n\n\nSyntheticEvent\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\nHistoricalEvent\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\nHurricaneEvent\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\nEventSet\nBaseModel describing the expected variables and data types for parameters of EventSet.\n\n\nTimeFrame\nClass representing a time frame for a simulation.\n\n\nIForcing\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\nForcingType\nEnum class for the different types of forcing parameters.\n\n\nTemplate\nClass describing the accepted input for the variable template in Event.\n\n\nMode\nClass describing the accepted input for the variable mode in Event.\n\n\nSubEventModel\nThe accepted input for a sub event in FloodAdapt.\n\n\n\n\n\n\nClimate and socio-economic projections for future scenario analysis.\n\n\n\nProjection\nThe accepted input for a projection in FloodAdapt.\n\n\nPhysicalProjection\nThe accepted input for a physical projection in FloodAdapt.\n\n\nSocioEconomicChange\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\n\n\n\nScenario modeling for assessing different flood risk management approaches. Scenarios consist of a combination of event, projection, and strategy.\n\n\n\nScenario\nBaseModel describing the expected variables and data types of a scenario.\n\n\n\n\n\n\nBenefit calculation for different flood risk management strategies. Benefits can be used to perform cost benefit analysis on a strategy, which is calculated based on the impact of the event on the population and infrastructure.\n\n\n\nBenefit\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\nCurrentSituationModel\nThe accepted input for a current situation in FloodAdapt.\n\n\n\n\n\n\n\nUnit system for FloodAdapt. The unit system is used to convert between different units of measurement, and to define the units of the input and output of the models.\n\n\n\nValueUnitPair\nRepresents a value with associated units.\n\n\nUnitfulLength\nCombination of length and unit.\n\n\nUnitfulHeight\nCombination of height and unit.\n\n\nUnitfulArea\nCombination of area and unit.\n\n\nUnitfulVelocity\nCombination of velocity and unit.\n\n\nUnitfulDirection\nCombination of direction and unit.\n\n\nUnitfulDischarge\nCombination of discharge and unit.\n\n\nUnitfulIntensity\nCombination of intensity and unit.\n\n\nUnitfulVolume\nCombination of volume and unit.\n\n\nUnitfulTime\nCombination of time and unit.\n\n\nUnitfulLengthRefValue\nCombination of length and unit with a reference value.\n\n\nUnitTypesLength\nUnits of length.\n\n\nUnitTypesArea\nUnits of area.\n\n\nUnitTypesVolume\nUnits of volume.\n\n\nUnitTypesVelocity\nUnits of velocity.\n\n\nUnitTypesDirection\nUnits of direction.\n\n\nUnitTypesTime\nUnits of time.\n\n\nUnitTypesDischarge\nUnits of discharge.\n\n\nUnitTypesIntensity\nUnits of intensity.\n\n\nVerticalReference\nVertical reference for height.\n\n\n\n\n\n\nDatabase builder for FloodAdapt. The database builder is used to create the database schema and to populate the database with data.\n\n\n\ncreate_database\nCreate a new database from a configuration file or ConfigModel.\n\n\nConfigModel\nMain configuration model for FloodAdapt database builder.\n\n\nUnitSystems\nEnumeration for supported unit systems.\n\n\nGuiConfigModel\nConfiguration for FloodAdapt GUI visualization scaling.\n\n\nSpatialJoinModel\nModel for representing a spatial join between geometries and tabular data.\n\n\nFootprintsOptions\nEnumeration for building footprints data sources.\n\n\nSviConfigModel\nModel for Social Vulnerability Index (SVI) spatial join.\n\n\nBasins\nEnumeration of global cyclone basins.\n\n\nTideGaugeConfigModel\nModel for tide gauge configuration.\n\n\nTideGaugeSource\nThe accepted input for the variable source in tide_gauge.\n\n\n\n\n\nSettings for metrics and infographics in FloodAdapt.\n\n\n\nMetricModel\nRepresents a metric configuration for infometric analysis.\n\n\nBuildingsInfographicModel\nModel for building infographic configuration.\n\n\nEventInfographicModel\nModel for event-based infographic configuration.\n\n\nHomesInfographicModel\nModel for Homes and SVI (Social Vulnerability Index) infographic configuration.\n\n\nRiskInfographicModel\nModel for risk-based infographic configuration.\n\n\nRoadsInfographicModel\nModel for roads infographic configuration.\n\n\nImpactCategoriesModel\nModel for defining impact categories with associated colors, field, unit, and bins.\n\n\nFloodExceedanceModel\nModel for flood exceedance probability configuration.\n\n\nTypeMapping\nContainer for multiple field mappings that define object type filtering.\n\n\nFieldMapping\nRepresents a mapping of a database field to a list of allowed values.\n\n\nSviModel\nModel for Social Vulnerability Index (SVI) configuration.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html#floodadapt",
    "href": "3_api_docs/api_ref/api_index.html#floodadapt",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Class that contains the main functionality of FloodAdapt.\n\n\n\nFloodAdapt",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html#setup-and-configuration",
    "href": "3_api_docs/api_ref/api_index.html#setup-and-configuration",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Configuration settings for FloodAdapt.\n\n\n\nSettings\nThe configuration settings for the FloodAdapt database and integrator.\n\n\nSite\nThe expected variables and data types of attributes of the Site class.\n\n\n\n\n\nConfiguration settings for visualizations and the GUI\n\n\n\nGuiModel\nThe accepted input for the variable gui in Site.\n\n\nGuiUnitModel\nThe unit system used in the GUI.\n\n\nOutputLayers\nThe configuration of the mapbox layers in the gui.\n\n\nVisualizationLayer\nThe configuration of a layer to visualize in the gui.\n\n\nVisualizationLayers\nThe configuration of the layers you might want to visualize in the gui.\n\n\nPlottingModel\nThe configuration of the plotting in the gui.\n\n\nStandardObjectModel\nThe accepted input for the variable standard_object in Site.\n\n\nFloodMapLayer\n\n\n\nAggregationDmgLayer\n\n\n\nFootprintsDmgLayer\n\n\n\nBenefitsLayer\n\n\n\nSyntheticTideModel\nConfiguration for the synthetic tide.\n\n\n\n\n\n\nConfiguration settings for hazard models\n\n\n\nCstype\nThe accepted input for the variable cstype in Site.\n\n\nCycloneTrackDatabaseModel\nThe accepted input for the variable cyclone_track_database in Site.\n\n\nDatumModel\nThe accepted input for the variable datums in WaterlevelReferenceModel.\n\n\nDemModel\nThe accepted input for the variable dem in Site.\n\n\nFloodFrequencyModel\nThe accepted input for the variable flood_frequency in Site.\n\n\nFloodModel\nThe accepted input for the variable overland_model and offshore_model in Site.\n\n\nObsPointModel\nThe accepted input for the variable obs_point in Site.\n\n\nRiverModel\nModel that describes the accepted input for the variable river in Site.\n\n\nSCSModel\nClass describing the accepted input for the variable scs.\n\n\nScstype\n\n\n\nSlrScenariosModel\nThe accepted input for the variable slr_scenarios.\n\n\nWaterlevelReferenceModel\nThe accepted input for the variable water_level in Site.\n\n\n\n\n\n\nConfiguration settings for Sfincs models\n\n\n\nSfincsConfigModel\nThe expected variables and data types of attributes of the SfincsConfig class.\n\n\nSfincsModel\nThe expected variables and data types of attributes of the Sfincs class.\n\n\n\n\n\n\nConfiguration settings for impact models\n\n\n\nAggregationModel\nThe accepted input for the variable aggregation in Site.\n\n\nBenefitsModel\nThe accepted input for the variable benefits in Site.\n\n\nEquityModel\nThe accepted input for the variable equity in Site.\n\n\nFloodmapType\nThe accepted input for the variable floodmap in Site.\n\n\nNoFootprintsModel\nThe configuration on the how to show objects with no footprints.\n\n\nRiskModel\nThe accepted input for the variable risk in Site.\n\n\n\n\n\n\nConfiguration settings for Fiat models\n\n\n\nFiatConfigModel\nConfiguration settings for the FIAT model.\n\n\nFiatModel\nThe expected variables and data types of attributes of the Fiat class.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html#object-models",
    "href": "3_api_docs/api_ref/api_index.html#object-models",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Object models in FloodAdapt are the components that are saved in the database. They define the configuration, input and output of the model kernels. The database stores Objects, and returns Objects when queried.\n\n\n\nObject\nBase class for FloodAdapt objects.\n\n\n\n\n\nVarious flood protection and mitigation measures available that can interact with the models. Can be impact measures or a hazard measures, where impact measures do not affect the hazard model at all, and hazard measures do.\n\n\n\nMeasure\nThe expected variables and data types of attributes common to all measures.\n\n\nMeasureType\nClass describing the accepted input for the variable ‚Äòtype‚Äô in Measure.\n\n\nSelectionType\nClass describing the accepted input for the variable ‚Äòselection_type‚Äô in Measures.\n\n\nFloodWall\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\nGreenInfrastructure\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\nPump\nThe expected variables and data types of the ‚Äúpump‚Äù hazard measure.\n\n\nBuyout\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\nElevate\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\nFloodProof\nThe expected variables and data types of the ‚Äúfloodproof‚Äù impact measure.\n\n\n\n\n\n\nA collection of measures that can be used to define a strategy for flood risk management.\n\n\n\nStrategy\nClass representing a strategy in FloodAdapt.\n\n\n\n\n\n\nEvent types including historical, synthetic, and hurricane events.\n\n\n\nEvent\nThe accepted input for an event in FloodAdapt.\n\n\nSyntheticEvent\nBaseModel describing the expected variables and data types for parameters of Synthetic that extend the parent class Event.\n\n\nHistoricalEvent\nBaseModel describing the expected variables and data types for parameters of HistoricalEvent that extend the parent class Event.\n\n\nHurricaneEvent\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\nEventSet\nBaseModel describing the expected variables and data types for parameters of EventSet.\n\n\nTimeFrame\nClass representing a time frame for a simulation.\n\n\nIForcing\nBaseModel describing the expected variables and data types for forcing parameters of hazard model.\n\n\nForcingType\nEnum class for the different types of forcing parameters.\n\n\nTemplate\nClass describing the accepted input for the variable template in Event.\n\n\nMode\nClass describing the accepted input for the variable mode in Event.\n\n\nSubEventModel\nThe accepted input for a sub event in FloodAdapt.\n\n\n\n\n\n\nClimate and socio-economic projections for future scenario analysis.\n\n\n\nProjection\nThe accepted input for a projection in FloodAdapt.\n\n\nPhysicalProjection\nThe accepted input for a physical projection in FloodAdapt.\n\n\nSocioEconomicChange\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\n\n\n\nScenario modeling for assessing different flood risk management approaches. Scenarios consist of a combination of event, projection, and strategy.\n\n\n\nScenario\nBaseModel describing the expected variables and data types of a scenario.\n\n\n\n\n\n\nBenefit calculation for different flood risk management strategies. Benefits can be used to perform cost benefit analysis on a strategy, which is calculated based on the impact of the event on the population and infrastructure.\n\n\n\nBenefit\nBaseModel describing the expected variables and data types of a Benefit analysis object.\n\n\nCurrentSituationModel\nThe accepted input for a current situation in FloodAdapt.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html#unit-system",
    "href": "3_api_docs/api_ref/api_index.html#unit-system",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Unit system for FloodAdapt. The unit system is used to convert between different units of measurement, and to define the units of the input and output of the models.\n\n\n\nValueUnitPair\nRepresents a value with associated units.\n\n\nUnitfulLength\nCombination of length and unit.\n\n\nUnitfulHeight\nCombination of height and unit.\n\n\nUnitfulArea\nCombination of area and unit.\n\n\nUnitfulVelocity\nCombination of velocity and unit.\n\n\nUnitfulDirection\nCombination of direction and unit.\n\n\nUnitfulDischarge\nCombination of discharge and unit.\n\n\nUnitfulIntensity\nCombination of intensity and unit.\n\n\nUnitfulVolume\nCombination of volume and unit.\n\n\nUnitfulTime\nCombination of time and unit.\n\n\nUnitfulLengthRefValue\nCombination of length and unit with a reference value.\n\n\nUnitTypesLength\nUnits of length.\n\n\nUnitTypesArea\nUnits of area.\n\n\nUnitTypesVolume\nUnits of volume.\n\n\nUnitTypesVelocity\nUnits of velocity.\n\n\nUnitTypesDirection\nUnits of direction.\n\n\nUnitTypesTime\nUnits of time.\n\n\nUnitTypesDischarge\nUnits of discharge.\n\n\nUnitTypesIntensity\nUnits of intensity.\n\n\nVerticalReference\nVertical reference for height.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/api_index.html#database-builder",
    "href": "3_api_docs/api_ref/api_index.html#database-builder",
    "title": "Flood Adapt v2.0.3",
    "section": "",
    "text": "Database builder for FloodAdapt. The database builder is used to create the database schema and to populate the database with data.\n\n\n\ncreate_database\nCreate a new database from a configuration file or ConfigModel.\n\n\nConfigModel\nMain configuration model for FloodAdapt database builder.\n\n\nUnitSystems\nEnumeration for supported unit systems.\n\n\nGuiConfigModel\nConfiguration for FloodAdapt GUI visualization scaling.\n\n\nSpatialJoinModel\nModel for representing a spatial join between geometries and tabular data.\n\n\nFootprintsOptions\nEnumeration for building footprints data sources.\n\n\nSviConfigModel\nModel for Social Vulnerability Index (SVI) spatial join.\n\n\nBasins\nEnumeration of global cyclone basins.\n\n\nTideGaugeConfigModel\nModel for tide gauge configuration.\n\n\nTideGaugeSource\nThe accepted input for the variable source in tide_gauge.\n\n\n\n\n\nSettings for metrics and infographics in FloodAdapt.\n\n\n\nMetricModel\nRepresents a metric configuration for infometric analysis.\n\n\nBuildingsInfographicModel\nModel for building infographic configuration.\n\n\nEventInfographicModel\nModel for event-based infographic configuration.\n\n\nHomesInfographicModel\nModel for Homes and SVI (Social Vulnerability Index) infographic configuration.\n\n\nRiskInfographicModel\nModel for risk-based infographic configuration.\n\n\nRoadsInfographicModel\nModel for roads infographic configuration.\n\n\nImpactCategoriesModel\nModel for defining impact categories with associated colors, field, unit, and bins.\n\n\nFloodExceedanceModel\nModel for flood exceedance probability configuration.\n\n\nTypeMapping\nContainer for multiple field mappings that define object type filtering.\n\n\nFieldMapping\nRepresents a mapping of a database field to a list of allowed values.\n\n\nSviModel\nModel for Social Vulnerability Index (SVI) configuration.",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/AggregationModel.html",
    "href": "3_api_docs/api_ref/config/AggregationModel.html",
    "title": "AggregationModel",
    "section": "",
    "text": "config.AggregationModel()\nThe accepted input for the variable aggregation in Site.\n\n\n\nname : str\n\nTODO\n\nfile : str\n\nTODO\n\nfield_name : str\n\nTODO\n\nequity : Optional[EquityModel], default=None\n\nTODO",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "AggregationModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/AggregationModel.html#attributes",
    "href": "3_api_docs/api_ref/config/AggregationModel.html#attributes",
    "title": "AggregationModel",
    "section": "",
    "text": "name : str\n\nTODO\n\nfile : str\n\nTODO\n\nfield_name : str\n\nTODO\n\nequity : Optional[EquityModel], default=None\n\nTODO",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "AggregationModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/BenefitsModel.html",
    "href": "3_api_docs/api_ref/config/BenefitsModel.html",
    "title": "BenefitsModel",
    "section": "",
    "text": "config.BenefitsModel()\nThe accepted input for the variable benefits in Site.\n\n\n\ncurrent_year : int\n\nThe current year used in benefits calculations.\n\ncurrent_projection : str\n\nThe current projection used in benefits calculations.\n\nbaseline_strategy : str\n\nThe baseline strategy used in benefits calculations.\n\nevent_set : str\n\nThe event set used in benefits calculations.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "BenefitsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/BenefitsModel.html#attributes",
    "href": "3_api_docs/api_ref/config/BenefitsModel.html#attributes",
    "title": "BenefitsModel",
    "section": "",
    "text": "current_year : int\n\nThe current year used in benefits calculations.\n\ncurrent_projection : str\n\nThe current projection used in benefits calculations.\n\nbaseline_strategy : str\n\nThe baseline strategy used in benefits calculations.\n\nevent_set : str\n\nThe event set used in benefits calculations.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Impacts",
      "BenefitsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/CycloneTrackDatabaseModel.html",
    "href": "3_api_docs/api_ref/config/CycloneTrackDatabaseModel.html",
    "title": "CycloneTrackDatabaseModel",
    "section": "",
    "text": "config.CycloneTrackDatabaseModel()\nThe accepted input for the variable cyclone_track_database in Site.\n\n\n\nfile : str\n\nThe path to the cyclone track database file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "CycloneTrackDatabaseModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/CycloneTrackDatabaseModel.html#attributes",
    "href": "3_api_docs/api_ref/config/CycloneTrackDatabaseModel.html#attributes",
    "title": "CycloneTrackDatabaseModel",
    "section": "",
    "text": "file : str\n\nThe path to the cyclone track database file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "CycloneTrackDatabaseModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/DemModel.html",
    "href": "3_api_docs/api_ref/config/DemModel.html",
    "title": "DemModel",
    "section": "",
    "text": "config.DemModel()\nThe accepted input for the variable dem in Site.\n\n\n\nfilename : str\n\nThe path to the digital elevation model file.\n\nunits : us.UnitTypesLength\n\nThe units of the digital elevation model file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "DemModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/DemModel.html#attributes",
    "href": "3_api_docs/api_ref/config/DemModel.html#attributes",
    "title": "DemModel",
    "section": "",
    "text": "filename : str\n\nThe path to the digital elevation model file.\n\nunits : us.UnitTypesLength\n\nThe units of the digital elevation model file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "DemModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FiatConfigModel.html",
    "href": "3_api_docs/api_ref/config/FiatConfigModel.html",
    "title": "FiatConfigModel",
    "section": "",
    "text": "config.FiatConfigModel()\nConfiguration settings for the FIAT model.\n\n\n\nexposure_crs : str\n\nThe coordinate reference system of the exposure data.\n\nbfe : Optional[BFEModel], default=None\n\nThe base flood elevation model.\n\naggregation : list[AggregationModel]\n\nConfiguration for the aggregation model.\n\nfloodmap_type : FloodmapType\n\nThe type of flood map to be used.\n\nnon_building_names : Optional[list[str]], default=None\n\nList of non-building names to be used in the model.\n\ndamage_unit : str, default=\"$\"\n\nThe unit of damage used in the model.\n\nbuilding_footprints : Optional[str], default=None\n\nPath to the building footprints data.\n\nroads_file_name : Optional[str], default=None\n\nPath to the roads data.\n\nnew_development_file_name : Optional[str], default=\"new_development_area.gpkg\"\n\nPath to the new development area data.\n\nsave_simulation : Optional[bool], default=False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.\n\nsvi : Optional[SVIModel], default=None\n\nThe social vulnerability index model.\n\ninfographics : Optional[bool], default=False\n\nWhether to create infographics or not.\n\nno_footprints : Optional[NoFootprintsModel], default=NoFootprintsModel()\n\nConfiguration for objects with no footprints.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Fiat",
      "FiatConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FiatConfigModel.html#attributes",
    "href": "3_api_docs/api_ref/config/FiatConfigModel.html#attributes",
    "title": "FiatConfigModel",
    "section": "",
    "text": "exposure_crs : str\n\nThe coordinate reference system of the exposure data.\n\nbfe : Optional[BFEModel], default=None\n\nThe base flood elevation model.\n\naggregation : list[AggregationModel]\n\nConfiguration for the aggregation model.\n\nfloodmap_type : FloodmapType\n\nThe type of flood map to be used.\n\nnon_building_names : Optional[list[str]], default=None\n\nList of non-building names to be used in the model.\n\ndamage_unit : str, default=\"$\"\n\nThe unit of damage used in the model.\n\nbuilding_footprints : Optional[str], default=None\n\nPath to the building footprints data.\n\nroads_file_name : Optional[str], default=None\n\nPath to the roads data.\n\nnew_development_file_name : Optional[str], default=\"new_development_area.gpkg\"\n\nPath to the new development area data.\n\nsave_simulation : Optional[bool], default=False\n\nWhether to keep or delete the simulation files after the simulation is finished and all output files are created. If True, the simulation files are kept. If False, the simulation files are deleted.\n\nsvi : Optional[SVIModel], default=None\n\nThe social vulnerability index model.\n\ninfographics : Optional[bool], default=False\n\nWhether to create infographics or not.\n\nno_footprints : Optional[NoFootprintsModel], default=NoFootprintsModel()\n\nConfiguration for objects with no footprints.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Fiat",
      "FiatConfigModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FloodFrequencyModel.html",
    "href": "3_api_docs/api_ref/config/FloodFrequencyModel.html",
    "title": "FloodFrequencyModel",
    "section": "",
    "text": "FloodFrequencyModel\nconfig.FloodFrequencyModel()\nThe accepted input for the variable flood_frequency in Site.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "FloodFrequencyModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FloodModel.html",
    "href": "3_api_docs/api_ref/config/FloodModel.html",
    "title": "FloodModel",
    "section": "",
    "text": "config.FloodModel()\nThe accepted input for the variable overland_model and offshore_model in Site.\n\n\n\nname : str\n\nThe name of the directory in static/templates/&lt;directory&gt; that contains the template model files.\n\nreference : str\n\nThe name of the vertical reference model that is used as the reference datum. Should be defined in water_level.datums.\n\nvertical_offset : Optional[us.UnitfulLength], default = None\n\nThe vertical offset of the vertical reference model relative to the main reference. Given that the height of the vertical reference model is often determined by external sources, this vertical offset can be used to correct systematic over-/underestimation of a vertical reference model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "FloodModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FloodModel.html#attributes",
    "href": "3_api_docs/api_ref/config/FloodModel.html#attributes",
    "title": "FloodModel",
    "section": "",
    "text": "name : str\n\nThe name of the directory in static/templates/&lt;directory&gt; that contains the template model files.\n\nreference : str\n\nThe name of the vertical reference model that is used as the reference datum. Should be defined in water_level.datums.\n\nvertical_offset : Optional[us.UnitfulLength], default = None\n\nThe vertical offset of the vertical reference model relative to the main reference. Given that the height of the vertical reference model is often determined by external sources, this vertical offset can be used to correct systematic over-/underestimation of a vertical reference model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "FloodModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/FootprintsDmgLayer.html",
    "href": "3_api_docs/api_ref/config/FootprintsDmgLayer.html",
    "title": "FootprintsDmgLayer",
    "section": "",
    "text": "FootprintsDmgLayer\nconfig.FootprintsDmgLayer()\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "FootprintsDmgLayer"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/GuiUnitModel.html",
    "href": "3_api_docs/api_ref/config/GuiUnitModel.html",
    "title": "GuiUnitModel",
    "section": "",
    "text": "config.GuiUnitModel()\nThe unit system used in the GUI.\n\n\n\ndefault_length_units : us.UnitTypesLength\n\nThe length units used in the GUI.\n\ndefault_distance_units : us.UnitTypesLength\n\nThe distance units used in the GUI.\n\ndefault_area_units : us.UnitTypesArea\n\nThe area units used in the GUI.\n\ndefault_volume_units : us.UnitTypesVolume\n\nThe volume units used in the GUI.\n\ndefault_velocity_units : us.UnitTypesVelocity\n\nThe velocity units used in the GUI.\n\ndefault_direction_units : us.UnitTypesDirection\n\nThe direction units used in the GUI.\n\ndefault_discharge_units : us.UnitTypesDischarge\n\nThe discharge units used in the GUI.\n\ndefault_intensity_units : us.UnitTypesIntensity\n\nThe intensity units used in the GUI.\n\ndefault_cumulative_units : us.UnitTypesLength\n\nThe cumulative units used in the GUI.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "GuiUnitModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/GuiUnitModel.html#attributes",
    "href": "3_api_docs/api_ref/config/GuiUnitModel.html#attributes",
    "title": "GuiUnitModel",
    "section": "",
    "text": "default_length_units : us.UnitTypesLength\n\nThe length units used in the GUI.\n\ndefault_distance_units : us.UnitTypesLength\n\nThe distance units used in the GUI.\n\ndefault_area_units : us.UnitTypesArea\n\nThe area units used in the GUI.\n\ndefault_volume_units : us.UnitTypesVolume\n\nThe volume units used in the GUI.\n\ndefault_velocity_units : us.UnitTypesVelocity\n\nThe velocity units used in the GUI.\n\ndefault_direction_units : us.UnitTypesDirection\n\nThe direction units used in the GUI.\n\ndefault_discharge_units : us.UnitTypesDischarge\n\nThe discharge units used in the GUI.\n\ndefault_intensity_units : us.UnitTypesIntensity\n\nThe intensity units used in the GUI.\n\ndefault_cumulative_units : us.UnitTypesLength\n\nThe cumulative units used in the GUI.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "GuiUnitModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/ObsPointModel.html",
    "href": "3_api_docs/api_ref/config/ObsPointModel.html",
    "title": "ObsPointModel",
    "section": "",
    "text": "config.ObsPointModel()\nThe accepted input for the variable obs_point in Site.\nobs_points is used to define output locations in the hazard model, which will be plotted in the user interface.\n\n\n\nname : Union[int, AsciiStr]\n\nThe name of the observation point.\n\ndescription : Optional[str], default=\"\"\n\nThe description of the observation point.\n\nID : Optional[int], default=None\n\nThe ID of the observation point.\n\nfile : Optional[str], default=None\n\nThe path to the observation point data file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "ObsPointModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/ObsPointModel.html#attributes",
    "href": "3_api_docs/api_ref/config/ObsPointModel.html#attributes",
    "title": "ObsPointModel",
    "section": "",
    "text": "name : Union[int, AsciiStr]\n\nThe name of the observation point.\n\ndescription : Optional[str], default=\"\"\n\nThe description of the observation point.\n\nID : Optional[int], default=None\n\nThe ID of the observation point.\n\nfile : Optional[str], default=None\n\nThe path to the observation point data file.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "ObsPointModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/PlottingModel.html",
    "href": "3_api_docs/api_ref/config/PlottingModel.html",
    "title": "PlottingModel",
    "section": "",
    "text": "config.PlottingModel()\nThe configuration of the plotting in the gui.\n\n\n\nexcluded_datums : list[str]\n\nA list of datums that will be excluded from the forcing plot in event windows.\n\nsynthetic_tide : SyntheticTideModel\n\nThe configuration of the synthetic tide.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "PlottingModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/PlottingModel.html#attributes",
    "href": "3_api_docs/api_ref/config/PlottingModel.html#attributes",
    "title": "PlottingModel",
    "section": "",
    "text": "excluded_datums : list[str]\n\nA list of datums that will be excluded from the forcing plot in event windows.\n\nsynthetic_tide : SyntheticTideModel\n\nThe configuration of the synthetic tide.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "PlottingModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/RiverModel.html",
    "href": "3_api_docs/api_ref/config/RiverModel.html",
    "title": "RiverModel",
    "section": "",
    "text": "config.RiverModel()\nModel that describes the accepted input for the variable river in Site.\n\n\n\nname : str\n\nThe name of the river.\n\ndescription : Optional[str], default=None\n\ndescription of the river.\n\nmean_discharge : us.UnitfulDischarge\n\nThe mean discharge of the river.\n\nx_coordinate : float\n\nThe x coordinate of the river.\n\ny_coordinate : float\n\nThe y coordinate of the river.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "RiverModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/RiverModel.html#attributes",
    "href": "3_api_docs/api_ref/config/RiverModel.html#attributes",
    "title": "RiverModel",
    "section": "",
    "text": "name : str\n\nThe name of the river.\n\ndescription : Optional[str], default=None\n\ndescription of the river.\n\nmean_discharge : us.UnitfulDischarge\n\nThe mean discharge of the river.\n\nx_coordinate : float\n\nThe x coordinate of the river.\n\ny_coordinate : float\n\nThe y coordinate of the river.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "RiverModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/Scstype.html",
    "href": "3_api_docs/api_ref/config/Scstype.html",
    "title": "Scstype",
    "section": "",
    "text": "Scstype\nconfig.Scstype()\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "Scstype"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SfincsModel.html",
    "href": "3_api_docs/api_ref/config/SfincsModel.html",
    "title": "SfincsModel",
    "section": "",
    "text": "config.SfincsModel()\nThe expected variables and data types of attributes of the Sfincs class.\n\n\n\nconfig : SfincsConfigModel\n\nThe configuration of the Sfincs model.\n\nwater_level : WaterlevelReferenceModel\n\nThe collection of all datums and the main reference datum.\n\ndem : DemModel\n\nThe digital elevation model.\n\nflood_frequency : FloodFrequencyModel, default = FloodFrequencyModel()\n\nThe flood frequency model.\n\nslr : SlrScenariosModel\n\nSpecification of the sea level rise scenarios.\n\ncyclone_track_database : CycloneTrackDatabaseModel, optional, default = None\n\nThe cyclone track database model.\n\nscs : SCSModel, optional, default = None\n\nThe SCS model.\n\ntide_gauge : TideGauge, optional, default = None\n\nThe tide gauge model.\n\nriver : list[RiverModel], optional, default = None\n\nThe river model.\n\nobs_point : list[ObsPointModel], optional, default = None\n\nThe observation point model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Sfincs",
      "SfincsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/SfincsModel.html#attributes",
    "href": "3_api_docs/api_ref/config/SfincsModel.html#attributes",
    "title": "SfincsModel",
    "section": "",
    "text": "config : SfincsConfigModel\n\nThe configuration of the Sfincs model.\n\nwater_level : WaterlevelReferenceModel\n\nThe collection of all datums and the main reference datum.\n\ndem : DemModel\n\nThe digital elevation model.\n\nflood_frequency : FloodFrequencyModel, default = FloodFrequencyModel()\n\nThe flood frequency model.\n\nslr : SlrScenariosModel\n\nSpecification of the sea level rise scenarios.\n\ncyclone_track_database : CycloneTrackDatabaseModel, optional, default = None\n\nThe cyclone track database model.\n\nscs : SCSModel, optional, default = None\n\nThe SCS model.\n\ntide_gauge : TideGauge, optional, default = None\n\nThe tide gauge model.\n\nriver : list[RiverModel], optional, default = None\n\nThe river model.\n\nobs_point : list[ObsPointModel], optional, default = None\n\nThe observation point model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Sfincs",
      "SfincsModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/StandardObjectModel.html",
    "href": "3_api_docs/api_ref/config/StandardObjectModel.html",
    "title": "StandardObjectModel",
    "section": "",
    "text": "StandardObjectModel\nconfig.StandardObjectModel()\nThe accepted input for the variable standard_object in Site.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "StandardObjectModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/VisualizationLayer.html",
    "href": "3_api_docs/api_ref/config/VisualizationLayer.html",
    "title": "VisualizationLayer",
    "section": "",
    "text": "VisualizationLayer\nconfig.VisualizationLayer()\nThe configuration of a layer to visualize in the gui.\nname : str The name of the layer to visualize. long_name : str The long name of the layer to visualize. path : str The path to the layer data to visualize. field_name : str The field names of the layer to visualize. decimals : Optional[int] The number of decimals to use for the layer to visualize. default is None.\n\n\n\n\n Back to top",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "GUI",
      "VisualizationLayer"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/WaterlevelReferenceModel.html",
    "href": "3_api_docs/api_ref/config/WaterlevelReferenceModel.html",
    "title": "WaterlevelReferenceModel",
    "section": "",
    "text": "config.WaterlevelReferenceModel()\nThe accepted input for the variable water_level in Site.\nWaterlevels timeseries are calculated from user input, assumed to be relative to the reference vertical reference model.\nFor plotting in the GUI, the reference vertical reference model is used as the main zero-reference, all values are relative to this. All other vertical reference models are plotted as dashed lines.\n\n\n\nreference : str\n\nThe name of the vertical reference model that is used as the main zero-reference.\n\ndatums : list[DatumModel]\n\nThe vertical reference models that are used to calculate the waterlevels timeseries. The datums are used to calculate the waterlevels timeseries, which are relative to the reference vertical reference model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "WaterlevelReferenceModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/config/WaterlevelReferenceModel.html#attributes",
    "href": "3_api_docs/api_ref/config/WaterlevelReferenceModel.html#attributes",
    "title": "WaterlevelReferenceModel",
    "section": "",
    "text": "reference : str\n\nThe name of the vertical reference model that is used as the main zero-reference.\n\ndatums : list[DatumModel]\n\nThe vertical reference models that are used to calculate the waterlevels timeseries. The datums are used to calculate the waterlevels timeseries, which are relative to the reference vertical reference model.",
    "crumbs": [
      "API Reference",
      "Setup and configuration",
      "Hazard",
      "WaterlevelReferenceModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html",
    "href": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "database_builder.BuildingsInfographicModel()\nModel for building infographic configuration.\n\n\n\ntypes : list[str]\n\nList of building types.\n\nicons : list[str]\n\nList of icon names corresponding to each building type.\n\ntype_mapping : dict[str, TypeMapping]\n\nMapping of building types to their database filtering criteria.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for building infographics.\n\n\nvalidate_icons_length\nValidate that icons list length matches types list length.\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n)\nGet a pre-configured template for building infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\n\n\n\n\n\n : BuildingsInfographicModel\n\nPre-configured building infographic model.\n\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.validate_icons_length(icons, info)\nValidate that icons list length matches types list length.\n\n\n\nicons : list[str]\n\nList of icon names.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated icons list.\n\n\n\n\n\n\n: ValueError\n\nIf icons length doesn‚Äôt match types length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "BuildingsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html#attributes",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "types : list[str]\n\nList of building types.\n\nicons : list[str]\n\nList of icon names corresponding to each building type.\n\ntype_mapping : dict[str, TypeMapping]\n\nMapping of building types to their database filtering criteria.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "BuildingsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/BuildingsInfographicModel.html#methods",
    "title": "BuildingsInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for building infographics.\n\n\nvalidate_icons_length\nValidate that icons list length matches types list length.\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'],\n)\nGet a pre-configured template for building infographics.\n\n\n\ntype : Literal['OSM', 'NSI']\n\nThe database type to create a template for.\n\n\n\n\n\n\n : BuildingsInfographicModel\n\nPre-configured building infographic model.\n\n\n\n\n\n\ndatabase_builder.BuildingsInfographicModel.validate_icons_length(icons, info)\nValidate that icons list length matches types list length.\n\n\n\nicons : list[str]\n\nList of icon names.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated icons list.\n\n\n\n\n\n\n: ValueError\n\nIf icons length doesn‚Äôt match types length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "BuildingsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/FieldMapping.html",
    "href": "3_api_docs/api_ref/database_builder/FieldMapping.html",
    "title": "FieldMapping",
    "section": "",
    "text": "database_builder.FieldMapping()\nRepresents a mapping of a database field to a list of allowed values.\n\n\n\nfield_name : str\n\nThe name of the database field/column\n\nvalues : list[str]\n\nList of values that should match this field\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_sql_filter\nGenerate SQL filter string for this field mapping.\n\n\n\n\n\ndatabase_builder.FieldMapping.to_sql_filter()\nGenerate SQL filter string for this field mapping.\n\n\n\n : str\n\nSQL WHERE clause condition string for this field mapping.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "FieldMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/FieldMapping.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/FieldMapping.html#attributes",
    "title": "FieldMapping",
    "section": "",
    "text": "field_name : str\n\nThe name of the database field/column\n\nvalues : list[str]\n\nList of values that should match this field",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "FieldMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/FieldMapping.html#methods",
    "href": "3_api_docs/api_ref/database_builder/FieldMapping.html#methods",
    "title": "FieldMapping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_sql_filter\nGenerate SQL filter string for this field mapping.\n\n\n\n\n\ndatabase_builder.FieldMapping.to_sql_filter()\nGenerate SQL filter string for this field mapping.\n\n\n\n : str\n\nSQL WHERE clause condition string for this field mapping.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "FieldMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html",
    "href": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "database_builder.HomesInfographicModel()\nModel for Homes and SVI (Social Vulnerability Index) infographic configuration.\n\n\n\nsvi : SviModel\n\nSVI classification configuration.\n\nmapping : TypeMapping\n\nDatabase field mapping for filtering relevant objects.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for SVI infographics.\n\n\n\n\n\ndatabase_builder.HomesInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'] = 'OSM',\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for SVI infographics.\n\n\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification. If not provided, SVI will be None.\n\ntype : Literal['OSM', 'NSI'] = \"OSM\"\n\nThe database type to create a template for.\n\n\n\n\n\n\n : HomesInfographicModel\n\nPre-configured Homes infographic model.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "HomesInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html#attributes",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "svi : SviModel\n\nSVI classification configuration.\n\nmapping : TypeMapping\n\nDatabase field mapping for filtering relevant objects.\n\nimpact_categories : ImpactCategoriesModel\n\nImpact categories configuration.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "HomesInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/HomesInfographicModel.html#methods",
    "title": "HomesInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for SVI infographics.\n\n\n\n\n\ndatabase_builder.HomesInfographicModel.get_template(\n    type: Literal['OSM', 'NSI'] = 'OSM',\n    svi_threshold: float | None = None,\n)\nGet a pre-configured template for SVI infographics.\n\n\n\nsvi_threshold : float | None = None\n\nThe SVI threshold value for vulnerability classification. If not provided, SVI will be None.\n\ntype : Literal['OSM', 'NSI'] = \"OSM\"\n\nThe database type to create a template for.\n\n\n\n\n\n\n : HomesInfographicModel\n\nPre-configured Homes infographic model.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "HomesInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/MetricModel.html",
    "href": "3_api_docs/api_ref/database_builder/MetricModel.html",
    "title": "MetricModel",
    "section": "",
    "text": "database_builder.MetricModel()\nRepresents a metric configuration for infometric analysis.\n\n\n\nname : str\n\nThe short name of the metric.\n\nlong_name : str | None, default=None\n\nThe long descriptive name of the metric. If not provided, defaults to name.\n\nshow_in_metrics_table : bool | None, default=True\n\nIndicates whether the metric should be displayed in the metrics table.\n\nshow_in_map : bool | None, default=True\n\nIndicates whether the metric should be displayed on the map.\n\ndescription : str | None, default=None\n\nA detailed description of the metric. If not provided, defaults to name.\n\nselect : str\n\nThe SQL select statement or expression for the metric.\n\nfilter : str | None, default=\"\"\n\nAn optional SQL filter to apply to the metric. Defaults to no filter.\n\n\n\n\n\nIf long_name or description are None, they will be set to the value of name.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "MetricModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/MetricModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/MetricModel.html#attributes",
    "title": "MetricModel",
    "section": "",
    "text": "name : str\n\nThe short name of the metric.\n\nlong_name : str | None, default=None\n\nThe long descriptive name of the metric. If not provided, defaults to name.\n\nshow_in_metrics_table : bool | None, default=True\n\nIndicates whether the metric should be displayed in the metrics table.\n\nshow_in_map : bool | None, default=True\n\nIndicates whether the metric should be displayed on the map.\n\ndescription : str | None, default=None\n\nA detailed description of the metric. If not provided, defaults to name.\n\nselect : str\n\nThe SQL select statement or expression for the metric.\n\nfilter : str | None, default=\"\"\n\nAn optional SQL filter to apply to the metric. Defaults to no filter.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "MetricModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/MetricModel.html#validation",
    "href": "3_api_docs/api_ref/database_builder/MetricModel.html#validation",
    "title": "MetricModel",
    "section": "",
    "text": "If long_name or description are None, they will be set to the value of name.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "MetricModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html",
    "href": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "database_builder.RoadsInfographicModel()\nModel for roads infographic configuration.\n\n\n\ncategories : list[str], default=[\"Slight\", \"Minor\", \"Major\", \"Severe\"]\n\nList of road impact category names.\n\ncolors : list[str], default=[\"#e0f7fa\", \"#80deea\", \"#26c6da\", \"#006064\"]\n\nList of colors corresponding to each category.\n\nicons : list[str], default=[\"walking_person\", \"car\", \"truck\", \"ambulance\"]\n\nList of icon names for each category.\n\nusers : list[str], default=[\"Pedestrians\", \"Cars\", \"Trucks\", \"Rescue vehicles\"]\n\nList of road user types for each category.\n\nthresholds : list[float]\n\nList of threshold values for categorizing road impacts.\n\nfield : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nroad_length_field : str, default=_IMPACT_COLUMNS.segment_length\n\nThe database field name containing road segment lengths.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for roads infographics.\n\n\nvalidate_lengths\nValidate that all list attributes have the same length.\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.get_template(\n    unit_system: Literal['metric', 'imperial'],\n)\nGet a pre-configured template for roads infographics.\n\n\n\nunit_system : Literal['metric', 'imperial']\n\nThe unit system to use for thresholds and measurements.\n\n\n\n\n\n\n : RoadsInfographicModel\n\nPre-configured roads infographic model.\n\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.validate_lengths(v, info)\nValidate that all list attributes have the same length.\n\n\n\nv : list[str]\n\nThe categories list.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated categories list.\n\n\n\n\n\n\n: ValueError\n\nIf list attributes don‚Äôt have the same length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RoadsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html#attributes",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "categories : list[str], default=[\"Slight\", \"Minor\", \"Major\", \"Severe\"]\n\nList of road impact category names.\n\ncolors : list[str], default=[\"#e0f7fa\", \"#80deea\", \"#26c6da\", \"#006064\"]\n\nList of colors corresponding to each category.\n\nicons : list[str], default=[\"walking_person\", \"car\", \"truck\", \"ambulance\"]\n\nList of icon names for each category.\n\nusers : list[str], default=[\"Pedestrians\", \"Cars\", \"Trucks\", \"Rescue vehicles\"]\n\nList of road user types for each category.\n\nthresholds : list[float]\n\nList of threshold values for categorizing road impacts.\n\nfield : str, default=_IMPACT_COLUMNS.inundation_depth\n\nThe database field name used for categorization.\n\nunit : str\n\nThe unit of measurement for the field.\n\nroad_length_field : str, default=_IMPACT_COLUMNS.segment_length\n\nThe database field name containing road segment lengths.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RoadsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html#methods",
    "href": "3_api_docs/api_ref/database_builder/RoadsInfographicModel.html#methods",
    "title": "RoadsInfographicModel",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_template\nGet a pre-configured template for roads infographics.\n\n\nvalidate_lengths\nValidate that all list attributes have the same length.\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.get_template(\n    unit_system: Literal['metric', 'imperial'],\n)\nGet a pre-configured template for roads infographics.\n\n\n\nunit_system : Literal['metric', 'imperial']\n\nThe unit system to use for thresholds and measurements.\n\n\n\n\n\n\n : RoadsInfographicModel\n\nPre-configured roads infographic model.\n\n\n\n\n\n\ndatabase_builder.RoadsInfographicModel.validate_lengths(v, info)\nValidate that all list attributes have the same length.\n\n\n\nv : list[str]\n\nThe categories list.\n\ninfo : Any\n\nField validation info containing all field values.\n\n\n\n\n\n\n : list[str]\n\nThe validated categories list.\n\n\n\n\n\n\n: ValueError\n\nIf list attributes don‚Äôt have the same length.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "RoadsInfographicModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/TypeMapping.html",
    "href": "3_api_docs/api_ref/database_builder/TypeMapping.html",
    "title": "TypeMapping",
    "section": "",
    "text": "database_builder.TypeMapping()\nContainer for multiple field mappings that define object type filtering.\n\n\n\nmappings : list[FieldMapping]\n\nList of field mappings that together define the type criteria\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_mapping\nAdd a new field mapping.\n\n\nto_sql_filter\nGenerate combined SQL filter string from all mappings.\n\n\n\n\n\ndatabase_builder.TypeMapping.add_mapping(field_name: str, values: list[str])\nAdd a new field mapping.\n\n\n\nfield_name : str\n\nName of the database field.\n\nvalues : list[str]\n\nList of allowed values for this field.\n\n\n\n\n\n\ndatabase_builder.TypeMapping.to_sql_filter()\nGenerate combined SQL filter string from all mappings.\n\n\n\n : str\n\nCombined SQL WHERE clause condition string.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "TypeMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/TypeMapping.html#attributes",
    "href": "3_api_docs/api_ref/database_builder/TypeMapping.html#attributes",
    "title": "TypeMapping",
    "section": "",
    "text": "mappings : list[FieldMapping]\n\nList of field mappings that together define the type criteria",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "TypeMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/database_builder/TypeMapping.html#methods",
    "href": "3_api_docs/api_ref/database_builder/TypeMapping.html#methods",
    "title": "TypeMapping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_mapping\nAdd a new field mapping.\n\n\nto_sql_filter\nGenerate combined SQL filter string from all mappings.\n\n\n\n\n\ndatabase_builder.TypeMapping.add_mapping(field_name: str, values: list[str])\nAdd a new field mapping.\n\n\n\nfield_name : str\n\nName of the database field.\n\nvalues : list[str]\n\nList of allowed values for this field.\n\n\n\n\n\n\ndatabase_builder.TypeMapping.to_sql_filter()\nGenerate combined SQL filter string from all mappings.\n\n\n\n : str\n\nCombined SQL WHERE clause condition string.",
    "crumbs": [
      "API Reference",
      "Database Builder",
      "Metrics configuration",
      "TypeMapping"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Buyout.html",
    "href": "3_api_docs/api_ref/objects/Buyout.html",
    "title": "Buyout",
    "section": "",
    "text": "objects.Buyout()\nThe expected variables and data types of the ‚Äúbuyout‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Buyout"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Buyout.html#attributes",
    "href": "3_api_docs/api_ref/objects/Buyout.html#attributes",
    "title": "Buyout",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str, default \"\"\n\nDescription of the measure.\n\ntype : MeasureType, default MeasureType.buyout_properties\n\nType of measure.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Buyout"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Elevate.html",
    "href": "3_api_docs/api_ref/objects/Elevate.html",
    "title": "Elevate",
    "section": "",
    "text": "objects.Elevate()\nThe expected variables and data types of the ‚Äúelevate‚Äù impact measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Elevate"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Elevate.html#attributes",
    "href": "3_api_docs/api_ref/objects/Elevate.html#attributes",
    "title": "Elevate",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúelevate_properties‚Äù.\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù or ‚Äúall‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\nproperty_type : str\n\nType of property. Should be ‚Äúresidential‚Äù or ‚Äúcommercial‚Äù.\n\nelevation : us.UnitfulLengthRefValue\n\nElevation of the properties.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Elevate"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/EventSet.html",
    "href": "3_api_docs/api_ref/objects/EventSet.html",
    "title": "EventSet",
    "section": "",
    "text": "objects.EventSet()\nBaseModel describing the expected variables and data types for parameters of EventSet.\nAn EventSet is a collection of events that can be used to create a scenario and perform a probabilistic risk assessment.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/EventSet.html#attributes",
    "href": "3_api_docs/api_ref/objects/EventSet.html#attributes",
    "title": "EventSet",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.risk.\n\nsub_events : List[SubEventModel]\n\nThe sub events of the event set.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/EventSet.html#methods",
    "href": "3_api_docs/api_ref/objects/EventSet.html#methods",
    "title": "EventSet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nload_sub_events\nLoad sub events from a list or from a file path.\n\n\n\n\n\nobjects.EventSet.load_sub_events(\n    sub_events: Optional[List[Event]] = None,\n    file_path: Optional[Path] = None,\n)\nLoad sub events from a list or from a file path.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "EventSet"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/FloodWall.html",
    "href": "3_api_docs/api_ref/objects/FloodWall.html",
    "title": "FloodWall",
    "section": "",
    "text": "objects.FloodWall()\nThe expected variables and data types of the ‚Äúfloodwall‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLengthRefValue\n\nHeight of the floodwall.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodWall"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/FloodWall.html#attributes",
    "href": "3_api_docs/api_ref/objects/FloodWall.html#attributes",
    "title": "FloodWall",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚ÄúMeasureType.floodwall‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚ÄúSelectionType.polygon‚Äù or ‚ÄúSelectionType.aggregation_area‚Äù.\n\npolygon_file : Optional[str]\n\nPath to a polygon file, either absolute or relative to the measure path.\n\nelevation : us.UnitfulLengthRefValue\n\nHeight of the floodwall.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "FloodWall"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/GreenInfrastructure.html",
    "href": "3_api_docs/api_ref/objects/GreenInfrastructure.html",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "objects.GreenInfrastructure()\nThe expected variables and data types of the ‚Äúgreen infrastructure‚Äù hazard measure.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/GreenInfrastructure.html#attributes",
    "href": "3_api_docs/api_ref/objects/GreenInfrastructure.html#attributes",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be ‚Äúgreening‚Äù\n\nselection_type : SelectionType\n\nType of selection. Should be ‚Äúpolygon‚Äù or ‚Äúaggregation_area‚Äù.\n\nheight : (us.UnitfulHeight, Optional)\n\nHeight of the green infrastructure.\n\nvolume : (us.UnitfulVolume, Optional)\n\nVolume of the green infrastructure.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure path.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Should be ‚Äúaggregation_area‚Äù.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area.\n\npercent_area : (float, Optional)\n\nPercentage of the area that is green infrastructure.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/GreenInfrastructure.html#methods",
    "href": "3_api_docs/api_ref/objects/GreenInfrastructure.html#methods",
    "title": "GreenInfrastructure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_polygon_area\nCalculate area of a GeoDataFrame Polygon.\n\n\ncalculate_volume\nDetermine volume from area of the polygon and infiltration height.\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_polygon_area(\n    gdf: gpd.GeoDataFrame,\n    site: Site,\n)\nCalculate area of a GeoDataFrame Polygon.\n\n\n\ngdf : gpd.GeoDataFrame\n\nPolygon object\n\nsite : Site\n\nsite config (used for CRS)\n\n\n\n\n\n\narea : float\n\nArea of the given polygon\n\n\n\n\n\n\nobjects.GreenInfrastructure.calculate_volume(\n    area: us.UnitfulArea,\n    height: us.UnitfulHeight,\n    percent_area: float = 100.0,\n)\nDetermine volume from area of the polygon and infiltration height.\n\n\n\narea : us.UnitfulArea\n\nArea of polygon with units (calculated using calculate_polygon_area)\n\nheight : us.UnitfulHeight\n\nWater height with units\n\npercent_area : float = 100.0\n\nPercentage area covered by green infrastructure [%], by default 100.0\n\n\n\n\n\n\n : float\n\nVolume [m3]",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "GreenInfrastructure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/HurricaneEvent.html",
    "href": "3_api_docs/api_ref/objects/HurricaneEvent.html",
    "title": "HurricaneEvent",
    "section": "",
    "text": "objects.HurricaneEvent()\nBaseModel describing the expected variables and data types for parameters of HurricaneEvent that extend the parent class Event.\n\n\n\nname : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HurricaneEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/HurricaneEvent.html#attributes",
    "href": "3_api_docs/api_ref/objects/HurricaneEvent.html#attributes",
    "title": "HurricaneEvent",
    "section": "",
    "text": "name : str\n\nThe name of the event.\n\ndescription : str\n\nThe description of the event. Defaults to ‚Äú‚Äú.\n\ntime : TimeFrame\n\nThe time frame of the event.\n\ntemplate : Template\n\nThe template of the event. Defaults to Template.Hurricane.\n\nmode : Mode\n\nThe mode of the event. Defaults to Mode.single_event.\n\nrainfall_multiplier : float\n\nThe rainfall multiplier of the event. Defaults to 1.0.\n\nforcings : dict[ForcingType, list[IForcing]]\n\nThe forcings of the event.\n\ntrack_name : str\n\nThe name of the hurricane track.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "HurricaneEvent"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Measure.html",
    "href": "3_api_docs/api_ref/objects/Measure.html",
    "title": "Measure",
    "section": "",
    "text": "objects.Measure()\nThe expected variables and data types of attributes common to all measures.\nA measure is a collection of attributes that can be applied to a model.\n\n\n\nname : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.\n\nselection_type : SelectionType\n\nType of selection. Should be one of the SelectionType enum values.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure‚Äôs toml path in the database.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nread_gdf\nRead the polygon file as a GeoDataFrame if it exists.\n\n\nserialize_polygon_file\nSerialize the polygon_file attribute to a string of only the file name.\n\n\n\n\n\nobjects.Measure.read_gdf(reload: bool = False)\nRead the polygon file as a GeoDataFrame if it exists.\n\n\n\nobjects.Measure.serialize_polygon_file(value: Optional[str])\nSerialize the polygon_file attribute to a string of only the file name.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Measure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Measure.html#attributes",
    "href": "3_api_docs/api_ref/objects/Measure.html#attributes",
    "title": "Measure",
    "section": "",
    "text": "name : str\n\nName of the measure.\n\ndescription : str\n\nDescription of the measure.\n\ntype : MeasureType\n\nType of measure. Should be one of the MeasureType enum values.\n\nselection_type : SelectionType\n\nType of selection. Should be one of the SelectionType enum values.\n\npolygon_file : (str, Optional)\n\nPath to a polygon file, either absolute or relative to the measure‚Äôs toml path in the database.\n\naggregation_area_name : (str, Optional)\n\nName of the aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.\n\naggregation_area_type : (str, Optional)\n\nType of aggregation area. Required if selection_type is ‚Äòaggregation_area‚Äô.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Measure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Measure.html#methods",
    "href": "3_api_docs/api_ref/objects/Measure.html#methods",
    "title": "Measure",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nread_gdf\nRead the polygon file as a GeoDataFrame if it exists.\n\n\nserialize_polygon_file\nSerialize the polygon_file attribute to a string of only the file name.\n\n\n\n\n\nobjects.Measure.read_gdf(reload: bool = False)\nRead the polygon file as a GeoDataFrame if it exists.\n\n\n\nobjects.Measure.serialize_polygon_file(value: Optional[str])\nSerialize the polygon_file attribute to a string of only the file name.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Measures",
      "Measure"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Mode.html",
    "href": "3_api_docs/api_ref/objects/Mode.html",
    "title": "Mode",
    "section": "",
    "text": "objects.Mode()\nClass describing the accepted input for the variable mode in Event.\n\n\n\nsingle_event : The single event mode.\n\n\n\nrisk : The risk mode.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Mode"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Mode.html#attributes",
    "href": "3_api_docs/api_ref/objects/Mode.html#attributes",
    "title": "Mode",
    "section": "",
    "text": "single_event : The single event mode.\n\n\n\nrisk : The risk mode.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Mode"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Projection.html",
    "href": "3_api_docs/api_ref/objects/Projection.html",
    "title": "Projection",
    "section": "",
    "text": "objects.Projection()\nThe accepted input for a projection in FloodAdapt.\nA projection is a combination of a physical projection and a socio-economic change.\n\n\n\nname : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "Projection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Projection.html#attributes",
    "href": "3_api_docs/api_ref/objects/Projection.html#attributes",
    "title": "Projection",
    "section": "",
    "text": "name : str\n\nName of the object.\n\ndescription : str\n\nDescription of the object. defaults to ‚Äú‚Äú.\n\nphysical_projection : PhysicalProjection\n\nThe physical projection model. Contains information about hazard drivers.\n\nsocio_economic_change : SocioEconomicChange\n\nThe socio-economic change model. Contains information about impact drivers.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "Projection"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Scenario.html",
    "href": "3_api_docs/api_ref/objects/Scenario.html",
    "title": "Scenario",
    "section": "",
    "text": "objects.Scenario()\nBaseModel describing the expected variables and data types of a scenario.\nA scenario is a combination of an event, a projection, and a strategy, that all should be saved in the database.\n\n\n\nevent : str\n\nThe name of the event. Must not be empty.\n\nprojection : str\n\nThe name of the projection. Must not be empty.\n\nstrategy : str\n\nThe name of the strategy. Must not be empty.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Scenarios",
      "Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Scenario.html#attributes",
    "href": "3_api_docs/api_ref/objects/Scenario.html#attributes",
    "title": "Scenario",
    "section": "",
    "text": "event : str\n\nThe name of the event. Must not be empty.\n\nprojection : str\n\nThe name of the projection. Must not be empty.\n\nstrategy : str\n\nThe name of the strategy. Must not be empty.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Scenarios",
      "Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SocioEconomicChange.html",
    "href": "3_api_docs/api_ref/objects/SocioEconomicChange.html",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "objects.SocioEconomicChange()\nThe accepted input for socio-economic change in FloodAdapt.\n\n\n\npopulation_growth_existing : float\n\nThe population growth percentage of the existing area. default=0.0\n\neconomic_growth : float\n\nThe economic growth percentage. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth percentage for the new development areas. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of the new development areas. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of the new development areas. default=None.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nserialize_new_development_shapefile\nSerialize the new_development_shapefile attribute to a string of only the file name.\n\n\n\n\n\nobjects.SocioEconomicChange.serialize_new_development_shapefile(\n    value: Optional[str],\n)\nSerialize the new_development_shapefile attribute to a string of only the file name.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "SocioEconomicChange"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SocioEconomicChange.html#attributes",
    "href": "3_api_docs/api_ref/objects/SocioEconomicChange.html#attributes",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "population_growth_existing : float\n\nThe population growth percentage of the existing area. default=0.0\n\neconomic_growth : float\n\nThe economic growth percentage. default=0.0.\n\npopulation_growth_new : float\n\nThe population growth percentage for the new development areas. default=0.0.\n\nnew_development_elevation : Optional[us.UnitfulLengthRefValue]\n\nThe elevation of the new development areas. default=None.\n\nnew_development_shapefile : Optional[str]\n\nThe path to the shapefile of the new development areas. default=None.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "SocioEconomicChange"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SocioEconomicChange.html#methods",
    "href": "3_api_docs/api_ref/objects/SocioEconomicChange.html#methods",
    "title": "SocioEconomicChange",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nserialize_new_development_shapefile\nSerialize the new_development_shapefile attribute to a string of only the file name.\n\n\n\n\n\nobjects.SocioEconomicChange.serialize_new_development_shapefile(\n    value: Optional[str],\n)\nSerialize the new_development_shapefile attribute to a string of only the file name.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Projections",
      "SocioEconomicChange"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SubEventModel.html",
    "href": "3_api_docs/api_ref/objects/SubEventModel.html",
    "title": "SubEventModel",
    "section": "",
    "text": "objects.SubEventModel()\nThe accepted input for a sub event in FloodAdapt.\n\n\n\nname : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SubEventModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/SubEventModel.html#attributes",
    "href": "3_api_docs/api_ref/objects/SubEventModel.html#attributes",
    "title": "SubEventModel",
    "section": "",
    "text": "name : str\n\nThe name of the sub event.\n\nfrequency : float\n\nThe frequency of the sub event.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "SubEventModel"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Template.html",
    "href": "3_api_docs/api_ref/objects/Template.html",
    "title": "Template",
    "section": "",
    "text": "objects.Template()\nClass describing the accepted input for the variable template in Event.\n\n\n\nSynthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Template"
    ]
  },
  {
    "objectID": "3_api_docs/api_ref/objects/Template.html#attributes",
    "href": "3_api_docs/api_ref/objects/Template.html#attributes",
    "title": "Template",
    "section": "",
    "text": "Synthetic : The synthetic template.\n\n\n\nHurricane : The hurricane template.\n\n\n\nHistorical : The historical template.",
    "crumbs": [
      "API Reference",
      "Object models",
      "Events",
      "Template"
    ]
  },
  {
    "objectID": "3_api_docs/examples/benefits/index.html",
    "href": "3_api_docs/examples/benefits/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top",
    "crumbs": [
      "Examples",
      "Benefits"
    ]
  },
  {
    "objectID": "3_api_docs/examples/index.html",
    "href": "3_api_docs/examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "This section contains executable examples that demonstrate how to use the FloodAdapt API in practice. These notebooks are meant to complement the User Guide and API Reference by showing real-world use cases, recommended workflows, and tips for getting started with your own data.\nEach example focuses on a specific aspect of the FloodAdapt workflow, such as setting up a site, defining events, projections and measures, creating adaptation strategies, or evaluating risk and benefits. The notebooks can be run independently, but they are organized in a logical sequence for those following the full workflow from start to finish.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "3_api_docs/examples/index.html#introduction",
    "href": "3_api_docs/examples/index.html#introduction",
    "title": "Examples",
    "section": "",
    "text": "This section contains executable examples that demonstrate how to use the FloodAdapt API in practice. These notebooks are meant to complement the User Guide and API Reference by showing real-world use cases, recommended workflows, and tips for getting started with your own data.\nEach example focuses on a specific aspect of the FloodAdapt workflow, such as setting up a site, defining events, projections and measures, creating adaptation strategies, or evaluating risk and benefits. The notebooks can be run independently, but they are organized in a logical sequence for those following the full workflow from start to finish.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "3_api_docs/examples/index.html#how-to-run",
    "href": "3_api_docs/examples/index.html#how-to-run",
    "title": "Examples",
    "section": "How to Run",
    "text": "How to Run\nAll notebooks in this section are runnable with standard Python tools such as jupyter or quarto preview. They assume that FloodAdapt and its core dependencies as well as the optional docs dependencies are correctly installed. Refer to the Setup Guide for help with installation and configuration. To run these locally, make sure to select the correct python interpreter.\nEach notebook includes narrative explanations and inline code cells. You can copy/modify the code to adapt it to your own use cases.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "3_api_docs/examples/index.html#examples",
    "href": "3_api_docs/examples/index.html#examples",
    "title": "Examples",
    "section": "Examples",
    "text": "Examples\n\n1. Database Builder Demonstrates how to initialize a FloodAdapt project by building the required database structure. This includes importing and configuring SFINCS and Delft-FIAT models, setting up spatial data, and preparing the backend for scenario analysis.\n2. Simple Scenario Walks through a basic flood scenario setup using predefined hazard and exposure data. Ideal for first-time users, this example illustrates the core workflow of defining a flood event, running simulations, and interpreting impact results.\n3. Events Explains how to configure and manage flood events within FloodAdapt. Learn to define event characteristics such as rainfall intensity, duration, and spatial distribution, and understand how these parameters influence flood modeling outcomes.\n4. Projections Covers the integration of long-term projections into flood risk assessments. This includes modeling future conditions like sea level rise, land subsidence, and socio-economic changes to evaluate their impact on flood hazards and vulnerabilities.\n5. Measures & Strategies Explores the implementation of adaptation measures such as levees, floodwalls, and green infrastructure. Learn how to simulate their effectiveness in reducing flood risks and assess their feasibility within different scenarios. Demonstrates how to develop and compare comprehensive adaptation strategies by combining multiple measures. This example guides users through evaluating trade-offs, cost-effectiveness, and overall risk reduction potential.\n6. Advanced scenario Provides an in-depth look at modeling compound flood scenarios involving multiple hazard sources (e.g., riverine and coastal flooding) and cascading impacts. Ideal for advanced users seeking to analyze intricate risk profiles.\n7. Event set / risk Illustrates the creation of probabilistic event sets for comprehensive risk analysis. Learn to generate a range of flood events with varying probabilities to assess potential impacts and inform robust adaptation planning.\n8. Benefits Focuses on evaluating the benefits of implemented adaptation strategies. This includes quantifying risk reduction, economic savings, and social advantages to support evidence-based decision-making.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/index.html",
    "href": "3_api_docs/examples/scenarios/index.html",
    "title": "TITLE HERE",
    "section": "",
    "text": "This section contains ‚Ä¶\nSelect an example from the sidebar to view the corresponding notebook.\n\n\n\n Back to top"
  },
  {
    "objectID": "4_system_setup/database.html",
    "href": "4_system_setup/database.html",
    "title": "Database Builder (executable)",
    "section": "",
    "text": "Figure¬†1 shows the mandatory attributes that are given at the top of the configuration file. These are required for all configurations, including the baseline configuration. These will be described below.\n\n\n\n\n\n\nFigure¬†1: Snippet showing the mandatory attributes of the top of the configuration file\n\n\n\nMandatory attributes are:\n\nname - this is the name of the database folder for your site\ndatabase_path - this is the path where your database folder will be saved\nsfincs - this is the location of your SFINCS overland model\nfiat - this is the location of your Delft-FIAT model\nunit system - this is either ‚Äúimperial‚Äù or ‚Äúmetric‚Äù\n\nFigure¬†2 shows the optional attributes that are given at the top of the configuration file. These will be described below.\n\n\n\n\n\n\nFigure¬†2: Snippet showing the optional attributes of the top of the configuration file\n\n\n\nOptional attributes are:\n\nsfincs_offshore - this is the location of your SFINCS offshore model.\ncyclone_basin - this is the region code (given with quotation marks around it, see Figure¬†2) where your site is located, for filtering the tropical cyclones (hurricanes) that show up in the hurricane selection window in FloodAdapt. Region codes are described below this list.\nprobabilistic_set - this is the path to the prepared event set and event frequencies which enable risk analysis\ncyclones - this is by default ‚ÄúTrue‚Äù, but if set to ‚ÄúFalse‚Äù hurricanes will not show up as an option when a user selects ‚ÄúAdd Event‚Äù in FloodAdapt\n\nFor the cyclone_basin the region code options are:\n\nNA = North Atlantic\nSA = South Atlantic\nEP = Eastern North Pacific (which includes the Central Pacific region)\nWP = Western North Pacific\nSP = South Pacific\nSI = South Indian\nNI = North Indian\n\n\n\n\n\n\n\n\n\n\nFigure¬†3: Snippet showing the attributes of the GUI\n\n\n\nFigure¬†3 shows the attributes that are required for the GUI. These are mandatory attributes that must be included in all configuration files, including the base configuration file.\nThe GUI attributes all have to do with maximum values. These are used to create automatic bins for the spatial mapping of flooding, impacts, and benefits.\nStart the GUI attribute section with [gui]. The values that need to be specified are:\n\nmax_flood_depth - this will be the highest legend value in the output flood maps (above which all values get the same color).\nmax_aggr_dmg - this will be the highest legend value in the output aggregated damages maps (above which all values get the same color). A good choice for this value will depend on the size of your aggregation, the density of the building footprints, and the currency value in the application area. It can be difficult to know apriori what to pick here, but the value can always be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\nmax_footprint_dmg - this will be the highest legend value in the output building damages maps (above which all values get the same color), and can be estimated based on the maximum potential values of the buildings in the site area.\nmax_benefits - this is the maximum value for the spatial benefits. This can also be difficult to estimate apriori, but can be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\n\n\n\n\nThe attributes for building footprints are shown in Figure¬†4. A building footprint layer allows users to visualize the building footprint damages in the output maps (instead of only points). Note that if a building footprint file is not included, the database-builder will automatically add Open Street Map building footprints to support the visualization of building damages in the FloodAdapt application.\n\n\n\n\n\n\nFigure¬†4: Snippet showing the attributes of the baseline configuration\n\n\n\nFor building footprints, start the section with [building_footprints] and provide the following attributes:\n\nfile - this is the path to the building footprint file (this should be a vector file, like a shapefile or a geopackage), making sure to use forward slahses in the paths.\nfield_name - this should be a unique identifier attribute in the vector file, like an Object ID.\n\n\n\n\nThe attributes needed to include a tide gauge are shown in Figure¬†5. The inclusion of a tide gauge allows FloodAdapt users to automatically download water levels for a specified start and end time.\n\n\n\n\n\n\nFigure¬†5: Snippet showing the attributes of the tide gauge configuration\n\n\n\nFor a tide gauge, start the section with [tide_gauge] and provide the following attributes:\n\nsource - this is either ‚Äúnoaa_coops‚Äù if you want to use the closest NOAA gauge station from https://tidesandcurrents.noaa.gov/stations.html (only available in the U.S.) OR ‚Äúfile‚Äù if you will be providing gauge data (water level time series) in a CSV file.\nfile - this is only required if the source is equal to ‚Äúfile‚Äù. It should be the path to a CSV file containing the gauged water level time series. The CSV file should have two columns; the first contains a ‚Äòdatetime‚Äô in the format DD/MM/YYYY HH:MM and the second column contains the water levels relative to mean sea level.\nref - this is an optional attribute; if provided, it will be used as the ‚Äòzero‚Äô when plotting event water levels in the event specification window of FloodAdapt.\n[tide_gauge.max_distance] - this is a section to specify the maximum radius around the site to search for a tidal gauge station. This prevents tide gauges being applied to a site that are too far away to be representative. The attributes that fall under this are value which gives a numeric value for the distance, and units which specifies the unit of the value (e.g.¬†‚Äúmiles‚Äù). See Figure¬†5 for an example.\n\n\n\n\nThe attributes needed to include an SVI layer are shown in Figure¬†6. The inclusion of an SVI layer allows FloodAdapt users to get additional information in the infographic related to who is being impacted, and to view the layer in the FloodAdapt Measures and Output tabs.\n\n\n\n\n\n\nFigure¬†6: Snippet showing the attributes of the SVI layer configuration\n\n\n\nFor an SVI layer, start the section with [svi] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the SVI layer\nfield_name - this is the name of the attribute in the geospatial file that contains the social vulnerability index.\nthreshold - this is the value of the SVI above which homes will be considered to have a high social vulnerability.\n\n\n\n\nThe attributes needed to include a BFE layer are shown in Figure¬†7. The inclusion of a BFE layer allows FloodAdapt users to elevate buildings relative to this layer, in addition to being able to elevate relative to datum.\n\n\n\n\n\n\nFigure¬†7: Snippet showing the attributes of the BFE layer configuration\n\n\n\nFor a BFE layer, start the section with [bfe] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the BFE layer\nfield_name - this is the name of the attribute in the geospatial file that contains the base flood elevation.\n\n\n\n\nThe attributes needed to include SLR scenarios are shown in Figure¬†8. The inclusion of a SLR scenarios file allows FloodAdapt users to enter a future sea level rise projection by selecting a SLR scenario and a year in the Projections window of FloodAdapt.\n\n\n\n\n\n\nFigure¬†8: Snippet showing the attributes of the SLR scenarios configuration\n\n\n\nFor SLR scenarios, start the section with [slr_scenarios] and provide the following attributes:\n\nfile - this is the path to the CSV file that contains the SLR scenario information. Figure¬†9 shows an example of the CSV file format. The first column should contain the year, the second column the units, and each additional column should contain the projections at the specified years in column 1. Each SLR scenario column should contain a header with the name of the SLR scenario. These are the names that will show up in the Projections window.\nrelative_to_year - this is the year you want the SLR projections relative to. Often SLR scenarios are relative to an older date, for example the year 2000. If you want to know how a recent event would look with SLR, you will want to know the SLR relative to a more recent year. The relative_to_year does not need to be exactly the current year, but should be within a few years of events of interest. When a user selects a SLR scenario and a year, FloodAdapt will then automatically calculate the SLR relative to the date selected here.\n\n\n\n\n\n\n\nFigure¬†9: Snippet showing an example of a SLR scenario CSV file\n\n\n\n\n\n\nThe attributes needed to include observation points are shown in Figure¬†10. The inclusion of observation points allows FloodAdapt users to visualize a time series of water levels at these points throughout a simulated event (rather than only a maximum flood depth as is shown in the spatial maps).\n\n\n\n\n\n\nFigure¬†10: Snippet showing the attributes of the observation points configuration. In this example there are two observation points included. Each one begins with a the double-bracketed ‚Äúobs_point‚Äù header\n\n\n\nUsers can enter multiple observation points. These are treated as a list, which means that each observation point gets its own section with the same name (obs_point), enclosed in a double square bracket.\nFor observation points, start the section with [[obs_point]] (one for each observation point) and provide the following attributes:\n\nname - this is the name of your observation point. This name cannot contain spaces or special characters.\ndescription - this a descriptive name of your observation point. This will show up at the top of the time series plot in the FloodAdapt Output tab.\nlat - this is the latitude of your observation point.\nlon - this is the longitude of your observation point.",
    "crumbs": [
      "Database Builder (executable)"
    ]
  },
  {
    "objectID": "4_system_setup/database.html#configuration-file-attributes",
    "href": "4_system_setup/database.html#configuration-file-attributes",
    "title": "Database Builder (executable)",
    "section": "",
    "text": "Figure¬†1 shows the mandatory attributes that are given at the top of the configuration file. These are required for all configurations, including the baseline configuration. These will be described below.\n\n\n\n\n\n\nFigure¬†1: Snippet showing the mandatory attributes of the top of the configuration file\n\n\n\nMandatory attributes are:\n\nname - this is the name of the database folder for your site\ndatabase_path - this is the path where your database folder will be saved\nsfincs - this is the location of your SFINCS overland model\nfiat - this is the location of your Delft-FIAT model\nunit system - this is either ‚Äúimperial‚Äù or ‚Äúmetric‚Äù\n\nFigure¬†2 shows the optional attributes that are given at the top of the configuration file. These will be described below.\n\n\n\n\n\n\nFigure¬†2: Snippet showing the optional attributes of the top of the configuration file\n\n\n\nOptional attributes are:\n\nsfincs_offshore - this is the location of your SFINCS offshore model.\ncyclone_basin - this is the region code (given with quotation marks around it, see Figure¬†2) where your site is located, for filtering the tropical cyclones (hurricanes) that show up in the hurricane selection window in FloodAdapt. Region codes are described below this list.\nprobabilistic_set - this is the path to the prepared event set and event frequencies which enable risk analysis\ncyclones - this is by default ‚ÄúTrue‚Äù, but if set to ‚ÄúFalse‚Äù hurricanes will not show up as an option when a user selects ‚ÄúAdd Event‚Äù in FloodAdapt\n\nFor the cyclone_basin the region code options are:\n\nNA = North Atlantic\nSA = South Atlantic\nEP = Eastern North Pacific (which includes the Central Pacific region)\nWP = Western North Pacific\nSP = South Pacific\nSI = South Indian\nNI = North Indian\n\n\n\n\n\n\n\n\n\n\nFigure¬†3: Snippet showing the attributes of the GUI\n\n\n\nFigure¬†3 shows the attributes that are required for the GUI. These are mandatory attributes that must be included in all configuration files, including the base configuration file.\nThe GUI attributes all have to do with maximum values. These are used to create automatic bins for the spatial mapping of flooding, impacts, and benefits.\nStart the GUI attribute section with [gui]. The values that need to be specified are:\n\nmax_flood_depth - this will be the highest legend value in the output flood maps (above which all values get the same color).\nmax_aggr_dmg - this will be the highest legend value in the output aggregated damages maps (above which all values get the same color). A good choice for this value will depend on the size of your aggregation, the density of the building footprints, and the currency value in the application area. It can be difficult to know apriori what to pick here, but the value can always be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\nmax_footprint_dmg - this will be the highest legend value in the output building damages maps (above which all values get the same color), and can be estimated based on the maximum potential values of the buildings in the site area.\nmax_benefits - this is the maximum value for the spatial benefits. This can also be difficult to estimate apriori, but can be changed later in the FloodAdapt database static/site.toml file under the [gui.output_layers] section.\n\n\n\n\nThe attributes for building footprints are shown in Figure¬†4. A building footprint layer allows users to visualize the building footprint damages in the output maps (instead of only points). Note that if a building footprint file is not included, the database-builder will automatically add Open Street Map building footprints to support the visualization of building damages in the FloodAdapt application.\n\n\n\n\n\n\nFigure¬†4: Snippet showing the attributes of the baseline configuration\n\n\n\nFor building footprints, start the section with [building_footprints] and provide the following attributes:\n\nfile - this is the path to the building footprint file (this should be a vector file, like a shapefile or a geopackage), making sure to use forward slahses in the paths.\nfield_name - this should be a unique identifier attribute in the vector file, like an Object ID.\n\n\n\n\nThe attributes needed to include a tide gauge are shown in Figure¬†5. The inclusion of a tide gauge allows FloodAdapt users to automatically download water levels for a specified start and end time.\n\n\n\n\n\n\nFigure¬†5: Snippet showing the attributes of the tide gauge configuration\n\n\n\nFor a tide gauge, start the section with [tide_gauge] and provide the following attributes:\n\nsource - this is either ‚Äúnoaa_coops‚Äù if you want to use the closest NOAA gauge station from https://tidesandcurrents.noaa.gov/stations.html (only available in the U.S.) OR ‚Äúfile‚Äù if you will be providing gauge data (water level time series) in a CSV file.\nfile - this is only required if the source is equal to ‚Äúfile‚Äù. It should be the path to a CSV file containing the gauged water level time series. The CSV file should have two columns; the first contains a ‚Äòdatetime‚Äô in the format DD/MM/YYYY HH:MM and the second column contains the water levels relative to mean sea level.\nref - this is an optional attribute; if provided, it will be used as the ‚Äòzero‚Äô when plotting event water levels in the event specification window of FloodAdapt.\n[tide_gauge.max_distance] - this is a section to specify the maximum radius around the site to search for a tidal gauge station. This prevents tide gauges being applied to a site that are too far away to be representative. The attributes that fall under this are value which gives a numeric value for the distance, and units which specifies the unit of the value (e.g.¬†‚Äúmiles‚Äù). See Figure¬†5 for an example.\n\n\n\n\nThe attributes needed to include an SVI layer are shown in Figure¬†6. The inclusion of an SVI layer allows FloodAdapt users to get additional information in the infographic related to who is being impacted, and to view the layer in the FloodAdapt Measures and Output tabs.\n\n\n\n\n\n\nFigure¬†6: Snippet showing the attributes of the SVI layer configuration\n\n\n\nFor an SVI layer, start the section with [svi] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the SVI layer\nfield_name - this is the name of the attribute in the geospatial file that contains the social vulnerability index.\nthreshold - this is the value of the SVI above which homes will be considered to have a high social vulnerability.\n\n\n\n\nThe attributes needed to include a BFE layer are shown in Figure¬†7. The inclusion of a BFE layer allows FloodAdapt users to elevate buildings relative to this layer, in addition to being able to elevate relative to datum.\n\n\n\n\n\n\nFigure¬†7: Snippet showing the attributes of the BFE layer configuration\n\n\n\nFor a BFE layer, start the section with [bfe] and provide the following attributes:\n\nfile - this is the path to the geospatial file with the BFE layer\nfield_name - this is the name of the attribute in the geospatial file that contains the base flood elevation.\n\n\n\n\nThe attributes needed to include SLR scenarios are shown in Figure¬†8. The inclusion of a SLR scenarios file allows FloodAdapt users to enter a future sea level rise projection by selecting a SLR scenario and a year in the Projections window of FloodAdapt.\n\n\n\n\n\n\nFigure¬†8: Snippet showing the attributes of the SLR scenarios configuration\n\n\n\nFor SLR scenarios, start the section with [slr_scenarios] and provide the following attributes:\n\nfile - this is the path to the CSV file that contains the SLR scenario information. Figure¬†9 shows an example of the CSV file format. The first column should contain the year, the second column the units, and each additional column should contain the projections at the specified years in column 1. Each SLR scenario column should contain a header with the name of the SLR scenario. These are the names that will show up in the Projections window.\nrelative_to_year - this is the year you want the SLR projections relative to. Often SLR scenarios are relative to an older date, for example the year 2000. If you want to know how a recent event would look with SLR, you will want to know the SLR relative to a more recent year. The relative_to_year does not need to be exactly the current year, but should be within a few years of events of interest. When a user selects a SLR scenario and a year, FloodAdapt will then automatically calculate the SLR relative to the date selected here.\n\n\n\n\n\n\n\nFigure¬†9: Snippet showing an example of a SLR scenario CSV file\n\n\n\n\n\n\nThe attributes needed to include observation points are shown in Figure¬†10. The inclusion of observation points allows FloodAdapt users to visualize a time series of water levels at these points throughout a simulated event (rather than only a maximum flood depth as is shown in the spatial maps).\n\n\n\n\n\n\nFigure¬†10: Snippet showing the attributes of the observation points configuration. In this example there are two observation points included. Each one begins with a the double-bracketed ‚Äúobs_point‚Äù header\n\n\n\nUsers can enter multiple observation points. These are treated as a list, which means that each observation point gets its own section with the same name (obs_point), enclosed in a double square bracket.\nFor observation points, start the section with [[obs_point]] (one for each observation point) and provide the following attributes:\n\nname - this is the name of your observation point. This name cannot contain spaces or special characters.\ndescription - this a descriptive name of your observation point. This will show up at the top of the time series plot in the FloodAdapt Output tab.\nlat - this is the latitude of your observation point.\nlon - this is the longitude of your observation point.",
    "crumbs": [
      "Database Builder (executable)"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html",
    "href": "4_system_setup/risk_analysis.html",
    "title": "Event Set",
    "section": "",
    "text": "This guidance provides support for preparing an event set to be used in FloodAdapt to calculate probabilistic flood maps, impacts, and risk. An event set consists of a set of events, defined by variables like surge, tide, and rainfall, and their occurrence frequencies. To see how FloodAdapt uses an event set to calculate risk, take a look at the FloodAdapt technical documentation on risk analysis, particularly the part about the probabilistic calculator.\nThe method described in this guidance is known as the Joint Probability Method (JPM). In the JPM, all types of hydro-meteorological events that may lead to flooding in an area of interest are identified. Subsequently, a representative set of (synthetic) events is selected, covering as much as possible the whole range of events that may contribute substantially to the overall flood risk. The likelihood of occurrence of each event is estimated from key statistics of the relevant flood drivers like rainfall, river discharge, and sea level.\nNote that this guide focuses on non-hurricane events. For the derivation of a hurricane event set, which can be combined with a set of non-hurricane events, please see the comprehensive FEMA guide from 2023.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#steps-to-prepare-an-event-set",
    "href": "4_system_setup/risk_analysis.html#steps-to-prepare-an-event-set",
    "title": "Event Set",
    "section": "Steps to prepare an event set",
    "text": "Steps to prepare an event set\nThis guide is organized around key steps in preparing an event set.\n\nIdentify flood drivers and define variables\nDetermine the flood drivers that have a significant impact on the flood risk in the area (e.g.¬†rainfall, river discharge, sea levels), and select appropriate variables that best represent the characteristics of the identified flood drivers.\nCalculate probabilities of variables\nCalculate the probability distribution of the flood driver variables.\nCalculate joint probabilities\nCalculate correlation between variables and the joint probability of occurrence of the flood driver variables.\nSelect events and calculate their frequencies\nSelect a set of events (defined as a combination of flood driver variables) and quantify their occurrence frequencies.\nFormat the events for FloodAdapt\nPrepare the set of events (event specs and frequencies) in the format required for FloodAdapt.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#identify-relevant-define-variables",
    "href": "4_system_setup/risk_analysis.html#identify-relevant-define-variables",
    "title": "Event Set",
    "section": "Step 1 - Identify flood drivers and define variables",
    "text": "Step 1 - Identify flood drivers and define variables\nThe initial step in setting up a probabilistic flood risk assessment involves identifying the most relevant flood drivers in the project area. In coastal zones, floods may be caused by (combinations of) intense rainfall (pluvial flooding), high river discharges (fluvial flooding), groundwater tables rising above the ground surface (groundwater flooding), and high tides, storm surges, and waves (coastal flooding). In a probabilistic analysis, these flood drivers are represented by variables that quantify a specific characteristic of the flood driver, such as daily rainfall or peak storm surge. These variables are sometimes referred to as ‚Äústochastic variables‚Äù or ‚Äúrandom variables,‚Äù acknowledging the fact that they can take on a range of values that have probabilities of occurrence/exceedance associated with them.\nThe choice of the most suitable variable to represent a flood driver depends on the system under consideration. For example, for an assessment of a storm sewage system, a suitable variable may be the 15-minute or 1-hour rainfall, whereas for larger catchments the daily rainfall or multi-day rainfall is more relevant. For the design of river embankments, the peak discharge is a suitable choice, whereas for the design of a reservoir the total volume of flow during the entire flood event is also relevant. In some cases, it may be worth considering representing a flood driver with multiple variables. For example, river discharge can be represented by a combination of peak flow and flow volume.\nLimiting the number of variables in a probabilistic flood risk assessment is crucial due to the exponential increase in the required model simulations, which can impact practical feasibility and computational resources. Consider a scenario where only two variables‚Äîrainfall and storm surge‚Äîare selected, each with five possible realizations. This setup yields 25 possible combinations (5√ó5), necessitating 25 model runs to assess flood conditions and impacts. This number of simulations is generally manageable. However, increasing the variables to four, each with five realizations, results in 625 possible combinations (5√ó5√ó5√ó5), significantly increasing the simulation time. If the number of variables increases to six, this leads to a staggering 15,625 combinations (5^6), which may not all need simulation but illustrate the potential scale of the assessment.\nWhile a comprehensive analysis ideally covers all relevant flood events, practical constraints often necessitate a balance. The choice of the number of model simulations is a trade-off between accuracy and simulation time. It is important to understand the relationship between the flood drivers and flood response, which may come from existing knowledge of the area or from exploratory simulations with a Hydrologic/Hydraulic (H&H) model. Conducting a sensitivity analysis with the H&H model for each candidate variable allows quantification of the sensitivity of the flood hazard and impact. Variables for which this sensitivity is relatively small can be replaced by a constant value, reducing the complexity of the analysis and computation times. For example, while the peak river discharge is a critical variable if a project area is along a river, in coastal areas where water levels are dominated by the sea, a constant river discharge might suffice, verified through sensitivity analysis to assess its impact. This demonstrates the essential balance between accuracy and practicality in setting up probabilistic flood risk assessments, aiming to include as many variables as necessary but as few as possible to maintain manageability and effectiveness, particularly if scenarios need to be re-evaluated frequently due to changing climate conditions or socio-economic factors.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#quantify-probs",
    "href": "4_system_setup/risk_analysis.html#quantify-probs",
    "title": "Event Set",
    "section": "Step 2 - Calculate probabilities of variables",
    "text": "Step 2 - Calculate probabilities of variables\nFlood events are described as a combination of realizations of the selected flood driver variables. For each event considered in the probabilistic analysis, the probability of occurrence is needed to be able to quantify the contribution of such an event to the overall risk. The event probabilities are derived from probabilities of the flood event variables. In some cases, probability distributions of variables are readily available. NOAA, for example, offers nation-wide statistics on rainfall (NOAA rainfall). In other instances, probabilities need to be derived either from gauge records or from expert judgement.This section focuses on deriving probabilities/statistics from gauge data.\nThe main steps in deriving (joint) probabilities of the flood variables are:\n\nData gathering and validation - this step involves collecting and ensuring the quality of time series of the variables for which we want to derive probability distributions\nCorrecting for non-stationarity - this step involves correcting for changes in the system or trends which would make distribution fitting techniques invalid\nExtreme value analysis- this step fits distributions to the extreme tails of the flood variable distributions\nCombining statistics of extreme events and average conditions - this step creates a distribution that is correct for both average values of the variables and extreme values\n\n\nData Gathering and Validation\nData gathering is a critical step in flood risk assessment. Important considerations include the record length, temporal resolution, number of stations, and data validation processes. Long records are preferable as they provide more comprehensive information on ‚Äúextremes,‚Äù which are crucial for analyzing flood risks.\n\nRecord Length: Longer records are more valuable because they include more rare events, which are important for understanding the full range of possible scenarios. They also allow for more robust statistical analyses.\nTemporal Resolution: The temporal resolution of the data should align with the scale of the hydrological processes being modeled. For urban drainage studies, minute-by-minute data may be necessary, whereas for river basin studies, daily values may suffice.\nNumber of Stations: Gathering data from multiple stations is generally preferred over using data from only one station. This provides valuable information on spatial variability. Furthermore, comparing data between nearby stations is an excellent way to validate data.\nData Validation: It is critical to validate the data to ensure its accuracy and reliability. This involves checking for anomalies or errors, such as outliers that might indicate data recording errors, especially for extreme values.\n\n\n\nDealing with Non-Stationarities\nSometimes, data is collected from a period when the system under consideration was significantly different from the current situation. As a result, the recorded time series may be non-stationary, meaning that probabilities of occurrence/exceedance can change over time. Various factors could cause changes in the system over the years, including climate change, sea level rise, urbanization, morphological changes, and human interventions like reservoirs. In such cases, caution is needed when using this data, as it could lead to over- or underestimation of current flood risk. One option is to discard earlier data, but this removes potentially useful information and may leave too little data to derive reliable statistics. Alternatively, ‚Äòcorrections‚Äô can be applied to make the data set (approximately) stationary again. The aim of these corrections is to estimate what the observed time series would have looked like if the system conditions had been the same as they are today.\nFor coastal systems, corrections for sea level rise are almost always necessary. Due to sea level rise, the exceedance probabilities of sea water levels increase over time, making early observations non-representative of current conditions. A simple correction is to add the amount of observed sea level rise since year Y to all observations from that year. For instance, if sea levels have risen by 0.5 ft since 1990, all water levels observed in 1990 should be increased by 0.5 ft to reflect current conditions. This adjustment requires an understanding of the extent of sea level rise, which is complicated by year-to-year fluctuations that can obscure the long-term trend. To address this, a trend line might be fitted through the data, although this process can be somewhat subjective.\n\n\n\n\n\n\nFigure¬†1: Observed annual mean sea levels, linear trend line from NOAA and fitted LOWESS trendline\n\n\n\nFigure¬†1 illustrates annual average observed sea water levels from 1996-2020 in Charleston, SC (blue dots), with the black line representing a linear trend line as derived by NOAA (NOAA SWL trend), and the red line showing a non-linear trend line using the LOWESS method (Cleveland, 1979). The estimated average sea level in 2020 differs by approximately 0.3 feet between the two methods, indicating that the choice of method can significantly influence the estimated flood risk. The linear fit does not account for the notable increase in sea water levels observed since 2014, suggesting the LOWESS fit might be more appropriate. However, this increase could be an anomaly; a similar sharp rise occurred in the 1940s, but by the late 1950s, the data returned to align with the linear trend. This variability demonstrates that past sea level rise is uncertain, and it may be prudent to consider both trend lines when assessing potential impacts on flood risk.\nIn cases like these (sea level rise, implementation of a reservoir) the recorded time series are clearly non-stationary and the cause of the non-stationarity is known. In other situations, there may be an observed trend for which it is unclear if this is due to a change in the system or if it is merely a coincidence. In that case, statistical tests can be applied to assess the likelihood of the trend being just a coincidence. IExamples of such tests are the Mann-Kendall test (Mann, 1945; Kendall, 1975) and the Wilcoxon-Mann-Whitney test (Wilcoxon, 1945; Mann and Whitney, 1947).\n\n\nExtreme Value Analysis\nExtreme value analysis is used to derive statistics of the ‚Äúextremes‚Äù in a record, based on limited information. For floods, this is important because often it is the extreme values of the flood variables that lead to a flood event, but these occur infrequently. Extreme value analysis involves selecting peaks (either annual maxima or peaks over threshold) and fitting them to appropriate probability distribution functions.\n\nSelection of peaks\nThe first step in the process is to select a subset of the record that contains the extreme variable values. This is generally either the set of highest recordings in each year, known as annual maxima (AM) or the set of recordings that exceed a user defined threshold, known as peaks over threshold (POT).\nFor annual maxima the selection can be done for each calendar year, but it can also be done for a ‚Äúwater year‚Äù which may have a different start date than January 1st. The start of the water year should preferably be chosen in a season where little or no extremes are expected. This way, the chance is small an extreme event occurs right around the start of the year and is selected as the annual maximum for two consecutive years (for example, if high peaks occur on December 31st and January 1st that are caused by the same meteorological event).\nFor peaks over threshold, only a single value per event should be selected. So, for example, if a river discharge exceeds the threshold for five consecutive days, these can all be considered part of the same event and only the highest observed discharge during these five days should be selected as the peak discharge. It is recommended to define a time window during which only one peak can be selected to assure the selected peaks all represent independent events. The size of the window depends on the system/process under consideration. For a small mountain stream, a window of one or two days may suffice, whereas for a large river basin (&gt; 25,000 square miles) the window should be at least 10 days. A suitable choice of the threshold in a POT analysis also depends on the system under consideration. A lower threshold has the advantage that a larger number of peaks is selected which decreases the uncertainty in the probability distribution function that is subsequently derived from the selected peaks. On the other hand, it also results in lower peaks to be selected, which may be less representative of the extremes for which probabilities need to be derived, which may not be representative for the extremes for which statistics are derived. A pragmatic strategy is to choose the threshold in such a way that the number of selected peaks is equal to the number of years. This strategy is sometimes referred to as ‚ÄúAnnual Exceedance‚Äù (AE). Note that this series is not the same as AM, even though they both have the same number of peaks.\n\n\nSelection of a probability distribution function\nThe next step is to select a probability distribution function that will be fitted to the selected set of peaks. According to the extreme value theorem, the set of maxima of intervals of a fixed length (such as a year) has a Generalized Extreme Value (GEV) distribution. POT data follows a Generalized Pareto Distribution (GPD). Both GEV and GPD are three-parameter distribution functions with a location-, scale- and shape-parameter.\nThe GEV and GPD are generalized distributions of which other probability distributions are special cases: Gumbel, Fr√©chet and Weibull (GEV) and exponential and Pareto (GPD). The value of the shape parameter determines which of the underlying distributions is applicable for the data. If the shape parameter is approximately equal to zero, the Gumbel (GEV) and exponential (GPD) distribution functions should be used. If the shape parameter differs from zero, the Fr√©chet and Weibull (GEV) and Pareto (GPD) should be used. The value of the shape parameters can be derived from the selected set of peaks (see later this section on fitting distribution functions).\nFigure¬†2 shows examples of these distribution functions for daily rainfall. The rainfall is plotted against the corresponding exceedance probability on a semi-logarithmic scale. It shows that the two distribution functions for which the scale parameter is equal to 0 (Gumbel and exponential) are straight lines on this scale. The Weibull distribution is curved ‚Äúdownward‚Äù, while the Fr√©chet distribution is curved ‚Äúupward‚Äù. Similar upward and downward curves can be seen for the GPD (right plot); in both cases the distribution function is called the Pareto distribution. According to the theory, only the GEV and GPD or one of the underlying probability distribution functions (Gumbel, Fr√©chet, Weibull, exponential and Pareto) should be used to fit the set of selected extremes. In practice, however, other probability distribution functions are used as well. For example, the Log-Pearson Type 3 was adopted by US federal agencies for applications in flood frequency analysis.\n\n\n\n\n\n\nFigure¬†2: Examples of the GEV and GPD and underlying distributions. The plots show the probability of exceedance of annual maxima (left) and Peaks Over Threshold (right). \n\n\n\nThe graphs in Figure¬†2 show the probability of exceedance of annual maxima (left) and peaks over threshold (right) data. The exceedance probability of AM also represents the annual exceedance probability of the variable for which the distribution function was derived. For POT data, this is not the case because the number of peaks in a POT data set can be larger or smaller than the number of years. To convert to an annual exceedance probability, the derived exceedance probabilities of POT data must be multiplied by the average number of exceedances of the selected threshold in a year (denoted \\(\\lambda\\)). Parameter \\(\\lambda\\) can be estimated by dividing the number of selected peaks by the number of years in the record. Note that \\(\\lambda\\) is a frequency of occurrence (per year). Multiplication of this frequency with a probability of exceedance from the POT data results in a frequency of exceedance.\n\n\n\n\n\n\nNoteProbability and Frequency\n\n\n\nThe terms ‚Äúprobability‚Äù and ‚Äúfrequency‚Äù are often used interchangeably to quantify the likelihood of a specific event occurring within a defined period. These two terms are similar, but not the same. Probability refers to the chance that an event will occur in a fixed period, typically a year. Frequency refers to how often such an event will occur on average during a fixed period. For example, at some location the probability of more than 5 inches of rainfall in a day may be estimated at 1/20 per year. That means each year there is a probability of 1 in 20 that more than 5 inches of rainfall is recorded in a day. In this case, the frequency is also equal to 1/20 per year, indicating such an event will occur on average once every 20 years. However, for events that occur more often, probability and frequency differ. For example, an event with more than 2 inches of rainfall in a day may occur on average twice per year. That means such an event has a frequency of 2 (per year). The probability of such an event happening in a year will be less than 1 since probabilities are, by definition, between 0 and 1. Probability is a quantification of the chance of such an event occurring at least once in a year, whereas frequency is a quantification of the number of times such an event occurs on average in a year. For very rare events, probability and frequency are (approximately) equal, because such events are not expected to occur more than once per year.\n\n\n\n\nFitting probability distributions\nThe next step is to fit the selected distribution function to the set of extremes (AM or POT). This means the parameter values of the distribution function are chosen such that key statistical characteristics of the distribution function correspond as much as possible with those of the set of extremes. There are several methods for deriving the parameter values, such as the maximum likelihood method, the method of moments, probability weighted moments and L-moments. Such methods are available in computational programming languages like Matlab, Python and R. Alternatively, dedicated software for flood frequency analysis can be used such as PeakFQ. In principle, any of these methods will do, but it is worth considering applying several methods to verify which one provides the best fit. There are statistical methods to quantify the goodness-of-fit like the Kolmogorov-Smirnov test, the Chi Square test or Anderson-Darling test. Each of these tests compares key characteristics of the data set with the fitted distribution function; smaller differences imply a better fit. The outcome of such a test could be that a fit is ‚Äúrejected‚Äù. In that case an alternative distribution function and/or fit method should be considered. The fact that there are different tests to choose from indicates there is some subjectivity involved in determining the ‚Äúbest‚Äù fit. It is recommended to also visually compare the fitted distribution function with the data, similar to the example of Figure¬†3. If the visual fit is not to satisfaction, a different distribution function and/or different fit methods should be considered.\n\n\n\n\n\n\nFigure¬†3: Example fit of the GPD function to Peaks Over Threshold data.\n\n\n\n\n\n\nCombining statistics of extreme events and average conditions\nIn flood risk analysis, the extremes as described in the previous section are the most relevant subset of the data. However, in areas with compound flooding, extremes of flood drivers do not necessarily coincide in time. For example, high intensity rainfall may occur during a period with negligible, low or moderate storm surge, and vice versa. This may result in a (substantially) different flood hazard compared to when both flood drivers are high/extreme. For a flood risk analysis with multiple flood drivers it is therefore necessary to also consider events where only a subset of the flood drivers is extreme. This means it is required to also derive probabilities of moderate/average conditions of flood drivers.\nSimilar to the extreme value analysis of the previous section, probability distribution functions can be selected and fitted to the available data set. The main difference is that in this case the entire data record is used instead of a small selection. With this larger data set, the use of an empirical distribution may be more practical than fitting a parametric probability distribution function. The advantage of using an empirical distribution functions is that it is relatively straightforward to derive and does not involve subjective choices of a distribution function and fit method. The empirical distribution is a direct reflection of the data set. For example, if a daily rainfall depth of 0.1 inch is exceeded in 12% of all days in the record, this means the exceedance probability of 0.1 inch/day in the empirical distribution function is estimated to be 0.12. So, by simply counting the number of exceedances of each threshold of interest and dividing by the total number of recordings, the empirical probability is obtained.\nTo derive the empirical probability distribution, sort the data in descending order. The largest value has an empirical probability of exceedance of 1/(n+1), where n is the total number of recordings. The second largest value has an empirical probability of exceedance of 2/(n+1), the third largest has an empirical probability of exceedance of 3/(n+1), and this continues all the way down to the smallest value with an empirical probability of exceedance of n/(n+1). Note that these are probabilities per time step of the time series. So, in case of a daily rainfall time series, these are exceedance probabilities per day. These can be translated to exceedance frequencies per year by multiplication with 365 (i.e.¬†the number of days per year). Similarly, derived empirical probabilities of tidal peaks should be multiplied with 705 (i.e., the number of tidal periods in a year) to derive exceedance frequencies per year.\n\n\n\n\n\n\nFigure¬†4: Example combination of an empirical distribution and an extreme value distribution.\n\n\n\nThe variable of interest now has an empirical distribution function, quantifying probabilities of all observed values, and an extreme value distribution function, quantifying exceedance probabilities of extremes. So, for the highest observed values in the record there are two probability estimates available. Ideally, these two probability estimates are the same, but this is often not the case. Especially for variables for which high peaks typically occur in clusters, there will most likely be a substantial difference in the two probability estimates due to the differences in the way these two probabilities were derived. Figure¬†4 shows the empirical probability distribution (black line) and fitted extreme value distribution (red line) of the tidal peaks at an example location. It shows the exceedance frequencies according to the empirical distribution are higher than those according to the extreme value distribution function. The green dashed line shows a pragmatic way to connect the two distributions and combine them into a single probability distribution function. An alternative approach could be to ‚Äúlift‚Äù the extreme value distribution such that is better connects with the empirical distribution. Such methods may seem like they are corrupting the results, but it is a necessary work-around to combine two distributions that are based on different approaches. The first approach (‚Äúeach tidal peak should be included‚Äù) is valid for average/moderate conditions, whereas the second (‚Äúonly the highest peak of each event is included‚Äù) is valid for extreme events.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#calculate-joint-probs",
    "href": "4_system_setup/risk_analysis.html#calculate-joint-probs",
    "title": "Event Set",
    "section": "Step 3 - Calculate joint probabilities",
    "text": "Step 3 - Calculate joint probabilities\nEvent probabilities are the joint probabilities of the variables that define the event. If the variables are mutually independent, the joint probability can be calculated as the product of the the probabilities of the individual variables. However, some variables may be impacted by the same hydro-meteorological processes, which means they are not independent. For example, a storm event may cause both high storm surges and high rainfall intensities. In that case, high values of rainfall and storm surge are more likely to coincide, which means rainfall and storm surge are not independent. This needs to be accounted for when estimating event probabilities.\nStatistical dependence between two or more variables can be quantified with Pearson‚Äôs correlation coefficient, \\(\\rho\\), which can take any value in the range from -1 to 1. A value of 0 indicates two variables are independent, which means the value of one variable provides no information on the likelihood of the value of the other variable. If \\(\\rho\\) deviates substantially from 0, the variables are dependent. Positive values of \\(\\rho\\) imply that high values of one variable usually coincide with high values of the other variable, and similarly that low values generally coincide as well. Negative values of \\(\\rho\\) imply that high values of one variable usually coincide with low values of the other variable and vice versa. Figure¬†5 shows samples of hypothetical variables x and y for six different values of Pearson‚Äôs correlation coefficient.\n\n\n\n\n\n\nFigure¬†5: Samples of hypothetical variables x and y for six different values of correlation coefficient ÔÅ≤.\n\n\n\nPearson‚Äôs correlation coefficient assumes a linear relation between the correlated variables, which is not always the case. If two variables are perfectly correlated, but their relation is non-linear, the value of \\(\\rho\\) will be less than 1, indicating non-perfect correlation. This is one of the reasons why a rank correlation may be preferred over Pearson‚Äôs correlation coefficient. The two most well-known options are Spearman‚Äôs and Kendall‚Äôs rank correlation coefficients. Similar to Pearson‚Äôs correlation coefficient, these two rank correlation coefficients take on values between -1 and 1.\nEven though the correlation coefficient generally is an informative measure of statistical dependence, it does not provide the complete picture on dependency structures. In some cases, for instance, the dependence between variables is higher for extremes than for moderate events due to a common cause that is especially profound during extreme events. This phenomenon is sometimes observed in discharge records of two neighboring rivers. If one river experiences extremely high discharges, this is likely to be the result of an exceptional rainfall event that may also cause high discharges in the other river.\nAn effective approach to incorporate these types of correlation structures is the use of ‚Äúcopula functions‚Äù or ‚Äúcopulas‚Äù, which model the dependence structure of two or more random variables. A multivariate distribution function is then constructed using the individual probability distribution functions of the variables in combination with the copula. One of the key advantages of this method is that the derived individual probability distributions are preserved, which is not necessarily the case with alternative methods for deriving multivariate statistics.\nFigure¬†6 shows example realizations of copula variables x and y for four different copulas: the Gumbel-Hougard, Frank, Clayton and Gaussian copula. In each case, the correlation coefficient is equal to 0.8, but there are differences in the overall dependence structure. Application of the Gumbel-Hougard copula results in strong dependence for values of x and y close to 1. In other words, if a sample of the first random variable (x) is relatively large, the accompanying sample of the second variable most likely is relatively large as well. The Clayton copula, on the other hand, generates a stronger dependence structure for low values of x and y. In that respect the Frank copula and the Gaussian copula are more symmetrical, where the latter shows stronger correlation in the extremes (both left and right).\n\n\n\n\n\n\nFigure¬†6: Illustration of four different copulas. In all cases the correlation coefficient was assumed to be 0.8.\n\n\n\nCopula variables are uniformly distributed over the interval between 0 and 1. Hydro-meteorological variables like rainfall, river discharge or water level are typically not uniformly distributed and can take on values outside the interval between 0 and 1. Therefore, in order to use the copula to model dependency between hydro-meteorological variables, a statistical transformation is applied. This transformation is done based on ‚Äúequal probability of exceedance‚Äù. The transformation process is illustrated in Figure¬†7.\n\n\n\n\n\n\nFigure¬†7: Transformation from copula-variable y to storm surge variable s. F(s) is the cumulative probability distribution function of s.\n\n\n\nSince copula-variables x and y are correlated, the corresponding real-world variables (e.g.¬†rainfall, surge) will be correlated as well. This way, a set of correlated samples of storm surge and rainfall can be generated. Conversely, the copula function and transformations can also be used to compute the probability of an event of, for example, a river discharge of more than 5,000 cfs in combination with a storm surge of more than 2 feet. To do this, these thresholds of discharge (5,000 cfs) and storm surge (2 feet) need to be translated to their corresponding copula-parameters x and y, using their respective probability distributions.\nFigure¬†6 showed patterns of four copulas, but there are many other copulas available, covering essentially any correlation pattern imaginable. A copula needs to be selected that best matches the observed data. Plotting of observed joint occurrences of correlated variables may reveal which copula(s) best describe the correlation between the variables involved. For example, if the data indicate the dependency increases for large values, the Gumbel-Hougard copula is a possible candidate, whereas if the dependency increases for low values, the Clayton copula is a possible candidate. Another strategy is to try out a large set of copulas and verify which one provides the best fit of the data. There are several statistical tests available that quantify the goodness-of-fit of the copula to the data, similar to the goodness-of-fit tests for extreme value distribution functions. Such methods are available in computational software packages like Python and R.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#select-events",
    "href": "4_system_setup/risk_analysis.html#select-events",
    "title": "Event Set",
    "section": "Step 4 - Select events and calculate their frequencies",
    "text": "Step 4 - Select events and calculate their frequencies\nWhen considering the selection of events, it is important to remember its purpose: the set of events will be used to calculate return period flooding and expected annual damages. The key to event selection is to ensure that the set of events is sufficient to reliably (consistently) estimate these important variables. There are two primary ways to select events and estimate their occurrence frequencies. One is to use a Monte Carlo approach, which is most recommended when there are a lot of variables that influence the flooding. The second is numerical integration, which is is more straight-forward and advantageous (in terms of required number of events) when the number of variables is limited to two - which may be the case for many areas.\nWith Monte Carlo sampling, a set of synthetic events is generated from the joint probability distribution of the event variables. This can be considered a representative set of possible events that may occur. For example, if an event with a joint occurrence of a peak river discharge between Q1 and Q2 and a peak sea water level between H1 and H2 has a probability of 0.05 per year according to the joint distribution, the sampling will lead to 5% of the simulated years containing an event in this range. However, since the sampling process is random by nature, the resulting percentage can also be lower or higher.\nIn a Monte Carlo Simulation, events are sampled directly from the multivariate probability distribution function of the flood drivers. The event set for FloodAdapt would consist of this set sampled events. The associated probability for each event is set equal to \\(1/n\\), where \\(n\\) is the total number of sampled events. Note that this is not the actual probability of each event. However, by applying this probability as input in FloodAdapt, the computation of flood probabilities will be according to the Monte Carlo Simulation method. In other words, the computed probability of flooding will be equal to the number of sampled events leading to flooding, divided by the total number of simulated events.\nWith numerical integration, the range of potential combinations of flood drivers is discretized in an n-dimensional computational grid (n being the number of flood drivers), so that all combinations are considered. Figure¬†8 shows an example for two flood drivers: river discharge and sea water level. In Figure¬†8, each rectangular grid cell has a center point, representing a single event with that combination of sea water level and river discharge. The event occurrence frequency is then taken as equal to the joint occurrence frequency of the variables. The range of variables that should be included, and the spacing of the computational grid, depend on when the values of interest (flooding probabilities and risk) stabilize. Extreme combinations of variables that have a very low occurrence frequency may not contribute a noticeable amount to flood probabilities or risk. Similarly, high-frequency low values of the variables that do not lead to flooding may also be negligible. For the latter, it is important to consider if they will still be negligible under future conditions before omitting them from the event set.\nBoth for Monte Carlo and for numerical integration, more events means better accuracy, but comes at a computational cost. For the Monte Carlo approach, a higher number of samples leads to better accuracy. For the Numerical Integration approach, a finer discretization of the variables leads to better accuracy. In each case, simulations with FloodAdapt can be done to assess the trade-off between number of events and accuracy of the risk and flood probability metrics.\n\n\n\n\n\n\nFigure¬†8: Schematic view of selected grids for numerical integration.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "4_system_setup/risk_analysis.html#format-events",
    "href": "4_system_setup/risk_analysis.html#format-events",
    "title": "Event Set",
    "section": "Step 5 - Format the events for FloodAdapt",
    "text": "Step 5 - Format the events for FloodAdapt\nOnce you have selected events and calculated their occurrence frquencies, they must be put in the correct format for FloodAdapt. Figure¬†9 shows the overall structure of the event set folder. The folder contains a sub-folder for each event in the event set and an event-set TOML file that gives the event names (which should align with the folder names) and the occurrence frequencies of the events. Each event folder should contain an event TOML file defining the event, and the time series (for the event duration) of the flood variables. More details about the event folder contents and the event set TOML file are given below.\n\n\n\n\n\n\nFigure¬†9: Overview of the setup process for FloodAdapt\n\n\n\n\nEvent folder contents\nEach event folder must contain a TOML file, with the name [EVENT_NAME].TOML, where [EVENT_NAME] should be replaced with the name of your event (which is also the name of the event folder). For example, if your event is called myEvent001, then the event folder should be called myEvent100, and the TOML file should be called myEvent001.TOML. In addition, the event folder must contain a time series file (CSV format) for each of the event variables that are varying over the duration of the event. Figure¬†10 shows the contents for an event named event_001.\n\n\n\n\n\n\nFigure¬†10: Contents of an event folder (example)\n\n\n\nThe time series CSV files are two-column files that contain a datetime in the first column and the variable value in the second column. The units of the variable will depend if you are working with imperial or metric units:\n\nRainfall - inches/hour (imperial) or mm/hour (metric)\nTide - feet+MSL (imperial) or meters+MSL (metric)\nSurge - feet (imperial) or meters (metric)\nRiver discharge - cubic feet per section (imperial) or cubic meters per second (metric)\nWind - knots (imperial) or m^3/s (metric)\n\nThe TOML file specifies the event. Figure¬†11 shows the template for an event TOML file, which includes forcing fields for river discharge, wind, rainfall, tide, and surge. In this example, there are two probabilistic event variables: rainfall and total sea water level (which includes both tide and surge). The river discharge is treated as a constant and wind is omitted because its effects are already accounted for in the total water level (which includes surge). Because the total water level variable includes both tide and surge, the surge variable is omitted (set to ‚Äúnone‚Äù) and the total water level time series is used for the ‚Äútide‚Äù field. A couple of notes about the event specifications:\n\nAll potential flood drivers must be defined, even if they are set to zero or none. For example, in Figure¬†11, the wind is set to ‚Äúnone‚Äù. Similarly, the discharge is set to ‚Äúconstant‚Äù because it is not treated probabilistically in this event set.\nAlthough the events are synthetic they use the ‚ÄúHistorical_nearshore‚Äù template because the event variables are being represented by time series like a historical event. This means that a start time and end time must be given. These can be anything in the past, as long as the duration matches the duration in the variable time series files.\n\n\n\n\n\n\n\nFigure¬†11: Example TOML file for an event named ‚Äúevent_0000‚Äù\n\n\n\n\n\nEvent set TOML file\nThe event set folder must contain an event set TOML file. This file will specify the names and occurrence frequencies of all of the events in the set. Every event specified in this TOML file must also have an associated event folder. Figure¬†12 shows an example of a TOML file for a set named ‚Äúprobabilistic_set‚Äù.\n\n\n\n\n\n\nFigure¬†12: Example TOML file for an event\n\n\n\nThe required fields are:\n\nname - this should also be the name of the event-set folder\ndescription - this can be anything\nmode - this should be set to ‚Äúrisk‚Äù\nsubevent_name - this is a list of the events for which event folders have been created\nfrequency - this is a list of occurrence frequencies for the events in the subevent_name list\n\nOnce the event set folder is created, you can reference it in the database builder configuration file and it will be included in the FloodAdapt database so users can calculate risk and risk-reduction benefits of adaptation options.",
    "crumbs": [
      "Probabilistic event set"
    ]
  },
  {
    "objectID": "formatting_tips.html",
    "href": "formatting_tips.html",
    "title": "Flood Adapt Documentation",
    "section": "",
    "text": "I put some styling infos here: but you can check all formatting here:\nhttps://quarto.org/docs/authoring/markdown-basics.html"
  },
  {
    "objectID": "formatting_tips.html#generate-tables",
    "href": "formatting_tips.html#generate-tables",
    "title": "Flood Adapt Documentation",
    "section": "Generate tables",
    "text": "Generate tables\nhttps://tablesgenerator.com/markdown_tables"
  },
  {
    "objectID": "formatting_tips.html#headings",
    "href": "formatting_tips.html#headings",
    "title": "Flood Adapt Documentation",
    "section": "Headings",
    "text": "Headings\nfirst level : # Heading second level : ## Heading third level : ### Heading\n‚Ä¶"
  },
  {
    "objectID": "formatting_tips.html#fonts",
    "href": "formatting_tips.html#fonts",
    "title": "Flood Adapt Documentation",
    "section": "Fonts",
    "text": "Fonts\nbold: ** word ** (remove tab spaces betweenw asterisk and word)\nitalic: * this will be italic when tab space removed *\n&lt;Make font a different color?&gt;"
  },
  {
    "objectID": "formatting_tips.html#paragraphs",
    "href": "formatting_tips.html#paragraphs",
    "title": "Flood Adapt Documentation",
    "section": "Paragraphs",
    "text": "Paragraphs\nIf you want to create a paragraph or continue in the next line add 2 tab spaces behind the last word.\nE.g I write and want to continue in the next line.\nIf I only press enter to continue in the next line as I did now this will not show. -&gt; I have to add 2 spaces after line.\nLet‚Äôs see what happens when I add the 2 tabs:\nI to continue in the next line. If I only press enter to continue in the next line as I did now this will not show."
  },
  {
    "objectID": "formatting_tips.html#additional-options",
    "href": "formatting_tips.html#additional-options",
    "title": "Flood Adapt Documentation",
    "section": "Additional options",
    "text": "Additional options\n\nEmphasizing\nCreate different types to emphasize the text eg code\nExample 1: conda install jupyter : Use ` (grave accent) before and after your sentence (without any spacing)\nExample 2: something: just indent one time. for scrolling do the same just write a longer text (see below)\nsomething really long that will needs scrolling so I will just continue writing until the scrolling bar appears.\n\n\nBullet Points\nJust write numbers below one another and use Indentation for the levels.\n\nMerry\nChristmas\nKathryn\n\nand a new year too\n\n\nUse the asterisks for your first level. For the second level in the row below add an indentation and a + per entry.\n\nMerry (* Merry)\n\nChristmas (+ Christmas)\nKathryn (+ Kathryn)"
  },
  {
    "objectID": "formatting_tips.html#urls",
    "href": "formatting_tips.html#urls",
    "title": "Flood Adapt Documentation",
    "section": "URLs",
    "text": "URLs\nadd a URL and give it a name a\n[here comes the name] (here comes the URL)\nFloodAdapt Deltares webpage"
  },
  {
    "objectID": "formatting_tips.html#embedded-videos",
    "href": "formatting_tips.html#embedded-videos",
    "title": "Flood Adapt Documentation",
    "section": "Embedded videos",
    "text": "Embedded videos"
  },
  {
    "objectID": "formatting_tips.html#figures",
    "href": "formatting_tips.html#figures",
    "title": "Flood Adapt Documentation",
    "section": "Figures",
    "text": "Figures\nadd a figure and give it a name add #fig..to cross-reference. Just included here for demonstration purposes):\nFirst an exclamation mark - [here comes the name] (here comes the path to the file){#fig-logo}\nadd ‚Äúfig-‚Äù before the label name to be able to cross reference.\n\n\n\n\n\n\nFigure¬†1: Floodadapt\n\n\n\n\nCross reference figure\nI want to reference the Figure¬†1."
  },
  {
    "objectID": "formatting_tips.html#note-warning-blocks",
    "href": "formatting_tips.html#note-warning-blocks",
    "title": "Flood Adapt Documentation",
    "section": "Note/ Warning Blocks",
    "text": "Note/ Warning Blocks\nCreate info blocks within your test.\nJust use this header (remove quotation mark):\n\"::: {.callout-tip}\"\nwrite here the Note. and end with the following footer.\n\":::\"\nExample:\n::: {.callout-tip}\ncreate a tip\n:::\n::: {.callout-warning}\nCreate a warning .\n:::\n\noptions\n\nnote\nwarning\nimportant\ntip\ncaution"
  },
  {
    "objectID": "formatting_tips.html#cross-reference",
    "href": "formatting_tips.html#cross-reference",
    "title": "Flood Adapt Documentation",
    "section": "Cross Reference",
    "text": "Cross Reference\nCross reference to another page or figure: (remove quotation marks)\n‚Äú[Write here the text would want to see]‚Äù(‚Äúadd the reference‚Äù)\n\nCross reference page\n‚ÄúHome‚Äù Here I use the reference to the Home page\n\n\nCross reference Figure\nuse the @ before the logo Reference and use the name you gave it as reference above: @ fig-logo (remove space)\nExample: Figure¬†1"
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html",
    "href": "3_api_docs/examples/database_builder/database_builder.html",
    "title": "üìò Example: Database Builder with Python",
    "section": "",
    "text": "In this notebook, we demonstrate how to use the Database builder API of FloodAdapt to build a FloodAdapt database in a new location! For this, we will use an example area in Charleston, South Carolina, for which we have already generated a SFINCS and a Delft-FIAT model.\nIn order to use the DatabaseBuilder of FloodAdapt a set of configuration parameters are needed. The configuration parameters can be divided to mandatory and optional ones. Using only the mandatory parameters (i.e., baseline FloodAdapt configuration) will result in a simple but functional version of FloodAdapt. By adding optional parameters to your configuration, you can create a more advanced FloodAdapt database with additional features. If you want to learn more about the configuration parameters, please refer to the Database-Builder of the Setup Guide in the documentation.\nThe configuration can be either created through available FloodAdapt classes or can be parsed as a simple dictionary. We advice you to work with the FloodAdapt classes, since this can avoid using wrong parameter names or values with the help of type hinting.",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#import-libraries",
    "href": "3_api_docs/examples/database_builder/database_builder.html#import-libraries",
    "title": "üìò Example: Database Builder with Python",
    "section": "Import libraries",
    "text": "Import libraries\n\n# Import packages\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\nfrom hydromt_fiat.fiat import FiatModel\nfrom hydromt_sfincs.sfincs import SfincsModel\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import database_builder as db\nfrom flood_adapt.objects.forcing import TideGaugeSource\nfrom flood_adapt.config.hazard import ObsPointModel, SlrScenariosModel, FloodModel\n%matplotlib inline\n\nThe study area is in Charleston, South Carolina, a coastal city on the East Coast of the United States. To run this notebook, we have already prepared a SFINCS model and a Delft-FIAT model for this area. Both these models are meant for demonstration purposes only.\nIn this notebook we will go through all the mandatory and optional configuration parameters to create a database.",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#database-save-path",
    "href": "3_api_docs/examples/database_builder/database_builder.html#database-save-path",
    "title": "üìò Example: Database Builder with Python",
    "section": "üíæ Database save path",
    "text": "üíæ Database save path\nFirst, we need to define the path where the database will be saved. This is done by defining the DATABASE_PATH attribute.\n\n# Define the static data folder\nSTATIC_DATA_DIR = Path(\"../../../_data/examples/static-data/1_DatabaseBuilder\").resolve()\n\n# Where the database will be stored\nDATABASE_PATH = (STATIC_DATA_DIR / \"Database\")",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#overland-sfincs-model",
    "href": "3_api_docs/examples/database_builder/database_builder.html#overland-sfincs-model",
    "title": "üìò Example: Database Builder with Python",
    "section": "üåê Overland SFINCS model",
    "text": "üåê Overland SFINCS model\nOne of the mandatory inputs for a FloodAdapt database is an overland SFINCS model. Let‚Äôs first inspect the extents of our overland SFINCS model, by loading the model with the HydroMT-SFINCS plugin.\n\n# Get the path of the SFINCS overland model\nfn_sfincs = STATIC_DATA_DIR  / \"overland\"\n# Use HydroMT-SFINCS to read the SFINCS model\nsfincs = SfincsModel(root=str(fn_sfincs), mode=\"r\")\nsfincs.read()\n# Get the extent of the SFINCS model\ngdf = sfincs.region[[\"geometry\"]]\ngdf[\"name\"] = \"SFINCS Model Extent\"\n# Make a map of the SFINCS model extent\ngdf.explore(\n    style_kwds={\"fillColor\": \"blue\", \"color\": \"black\", \"weight\": 1, \"fillOpacity\": 0.2},\n    tiles=\"CartoDB positron\",\n    column=\"name\",\n    legend=True,\n    legend_kwds={\"caption\": \"Region\"}\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThe SFINCS model is specified using the sfincs_overland attribute, which is a FloodModel class that includes the path to the SFINCS model, defined by the attribute name and the vertical reference that the model has, defined by reference. The SFINCS model was build with elevation data in the NAVD88 vertical reference system, so we set the reference to NAVD88.\n\n# Define the overland SFINCS model path and vertical reference\nsfincs_overland = FloodModel(\n    name=(STATIC_DATA_DIR / \"overland\").as_posix(),\n    reference=\"NAVD88\" \n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#delft-fiat-model",
    "href": "3_api_docs/examples/database_builder/database_builder.html#delft-fiat-model",
    "title": "üìò Example: Database Builder with Python",
    "section": "üè† Delft-FIAT model",
    "text": "üè† Delft-FIAT model\nAnother mandatory input is the Delft-FIAT model. We can inspect the exposure objects (buildings and roads) of the Delft-FIAT model, by loading the model with the HydroMT-FIAT plugin.\n\n# Get the path of the FIAT model\nfn_fiat = STATIC_DATA_DIR  / \"fiat\"\n# Read the FIAT model using HydroMT-FIAT\nfiat = FiatModel(root=str(fn_fiat), mode=\"r\")\nfiat.read()\n# Get the geodataframe with exposure data\ngdf = fiat.exposure.get_full_gdf(fiat.exposure.exposure_db)\n# Plot the region and the secondary_object_types of the exposure data\ngdf.explore(\n    column=\"primary_object_type\", \n    name=\"Exposure types\",\n    tiles=\"CartoDB positron\"\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThe Delft-FIAT model is simply specified using the fiat attribute, which points to the path of the Delft-FIAT model.\n\n# Define the FIAT model path\nfiat = (STATIC_DATA_DIR / \"fiat\").as_posix()",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#define-the-unit-system",
    "href": "3_api_docs/examples/database_builder/database_builder.html#define-the-unit-system",
    "title": "üìò Example: Database Builder with Python",
    "section": "üìè Define the unit system",
    "text": "üìè Define the unit system\nThen, a unit_system needs to be specified, which can be either metric or imperial. The unit_system will determine the default units used in the database. Since for our example we are in U.S., we will use the imperial unit system.\n\n# Define the unit system for the database\nunit_system = db.UnitSystems.imperial",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#gui-map-color-scaling",
    "href": "3_api_docs/examples/database_builder/database_builder.html#gui-map-color-scaling",
    "title": "üìò Example: Database Builder with Python",
    "section": "üó∫Ô∏è GUI map color scaling",
    "text": "üó∫Ô∏è GUI map color scaling\nFor the output visualizations, scaling values need to be specified for each output type, using the gui attribute. These values will be used to scale the colors of the map visualizations in the GUI. There are four types of outputs that can be visualized in the GUI: flood_depth, aggregated damages, footprint damages, and benefits. For each of these outputs, we can specify the maximum values for the color scaling using the max_flood_depth, max_aggr_dmg, max_footprint_dmg, and max_benefits attributes, respectively.\n\n# Define the max values for each type of layer in the GUI\ngui = db.GuiConfigModel(\n    max_flood_depth=5,\n    max_aggr_dmg=1e6,\n    max_footprint_dmg=250000,\n    max_benefits=5e6,\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#probabilistic-event-set-and-risk-calculations",
    "href": "3_api_docs/examples/database_builder/database_builder.html#probabilistic-event-set-and-risk-calculations",
    "title": "üìò Example: Database Builder with Python",
    "section": "üé≤ Probabilistic event set and risk calculations",
    "text": "üé≤ Probabilistic event set and risk calculations\nWe can add a probabilistic event set by providing the path to an existing event set with the attribute probabilistic_set. This will enable us to run risk and benefit scenarios in FloodAdapt (see Risk and benefit analysis).\nIn case we provide a probabilistic event set to enable risk calculations, we can also specify the return periods that will be calculated from the event set in FloodAdapt during risk scenario runs. The default values are [1, 2, 5, 10, 25, 50, 100] years, but you can specify any other set of values with the return_periods attribute.\n\n # Path to the prepared probabilistic set\nprobabilistic_set = str(STATIC_DATA_DIR  / \"test_set\")\n# Here we just use the standard return periods\nreturn_periods = [1, 2, 5, 10, 25, 50, 100]",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#sfincs-offshore-model",
    "href": "3_api_docs/examples/database_builder/database_builder.html#sfincs-offshore-model",
    "title": "üìò Example: Database Builder with Python",
    "section": "üåÄ SFINCS offshore model",
    "text": "üåÄ SFINCS offshore model\nIf we have a SFINCS offshore model we can also pass this into the configuration with the sfincs_offshore attribute in the same way as the overland SFINCS model. This will allow us to run extra types of events (see Simulating hurricane events and ‚Äòungauged‚Äô historical events). Let‚Äôs first visualize the SFINCS offshore model to see its extent.\n\n# Use HydroMT-SFINCS to read the SFINCS model\noff_sfincs_path = (STATIC_DATA_DIR / \"offshore\").as_posix()\nsfincs = SfincsModel(root=off_sfincs_path, mode=\"r\")\nsfincs.read()\n# Get the extent of the SFINCS model\ngdf = sfincs.region[[\"geometry\"]]\ngdf[\"name\"] = \"offshore SFINCS Model Extent\"\n# Make a map of the SFINCS model extent\ngdf.explore(\n    style_kwds={\"fillColor\": \"blue\", \"color\": \"black\", \"weight\": 1, \"fillOpacity\": 0.2},\n    tiles=\"CartoDB positron\",\n    column=\"name\",\n    legend=True,\n    legend_kwds={\"caption\": \"Region\"}\n)\n\nbzsfile not found at D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\static-data\\1_DatabaseBuilder\\offshore\\sfincs.bzs\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nSimilarly, to the onshore SFINCS model, we can use a FloodModel class to define the path with the attribute name and its vertical reference with the attribute reference (which for an offshore models is typically ‚ÄòMSL‚Äô). In case a correction is needed to bring MSL to present day conditions (see Sea level offset for offshore simulations), the vertical_offset attribute can be used to specify the correction.\n\n# Add the SFINCS offshore model\nsfincs_offshore = FloodModel(\n    name=off_sfincs_path,\n    reference=\"MSL\",\n    vertical_offset=us.UnitfulLength(\n        value=0.33, units=us.UnitTypesLength.feet # in this case we found from observations that there is an offset of 0.33 feet\n    )\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#historical-hurricanes",
    "href": "3_api_docs/examples/database_builder/database_builder.html#historical-hurricanes",
    "title": "üìò Example: Database Builder with Python",
    "section": "üå™Ô∏è Historical hurricanes",
    "text": "üå™Ô∏è Historical hurricanes\nIf we have an offshore SFINCS model, we can run historical hurricanes as well if we are in a hurricane prone area. The configuration for running hurricanes or not, is set with the cyclones attribute, which in case we are in an area were hurricanes are not relevant we could turn to False. If this is set to True (which is the default value), the cyclone_basin attribute can be used to define the oceanic basin. The Basins class can be used to check the available basins. In the case of Charleston we are going to use NA - for North Atlantic. If this is not specified, all global basins will be downloaded.\n\n# Add cyclone tracks\ncyclones = True\ncyclone_basin = db.Basins.NA",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#tide-gauge-data",
    "href": "3_api_docs/examples/database_builder/database_builder.html#tide-gauge-data",
    "title": "üìò Example: Database Builder with Python",
    "section": "üïí Tide gauge data",
    "text": "üïí Tide gauge data\nIf there are water level observations from a close by tide gauge we can add them in the database, so they can directly be used during event creation (see Downloading historical water levels), by using the tide_gauge attribute.\nWith the source attribute assigned to file, and the use of the file attribute to define the path to a csv file with the tide gauge data, we can directly use the tide gauge data in the database. The vertical reference of the tide gauge data can be defined by the ref attribute. The CSV file should have two columns; the first contains a ‚Äòdatetime‚Äô in the format DD/MM/YYYY HH:MM and the second column contains the water levels relative to the vertical reference defined.\nIn U.S., instead of manually providing a file, we can choose db.TideGaugeSource.noaa_coops as the source attribute, to find the closest tide gauge from the NOOAA COOPS tide gauge network. To avoid using a stations that is really far away, we can also specify a max_distance attribute, which will be used to filter the stations. If no station is found within the specified distance, the tide gauge data will not be added to the database. A set of water level references from this station will be added to the database as well. These include ‚ÄúMLLW‚Äù, ‚ÄúMHHW‚Äù, ‚ÄúNAVD88‚Äù, ‚ÄúMSL‚Äù. The default reference of the observation is MLLW, which can be changed with the ref attribute.\nIn our case we will use the NOAA COOPS tide gauge data with a limit of 100 miles and we will keep the default reference of MLLW.\n\n# Add tide gauge\ntide_gauge = db.TideGaugeConfigModel(\n    source=TideGaugeSource.noaa_coops,\n    max_distance=us.UnitfulLength(\n        value=100, units=us.UnitTypesLength.miles\n    ),\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#observation-points",
    "href": "3_api_docs/examples/database_builder/database_builder.html#observation-points",
    "title": "üìò Example: Database Builder with Python",
    "section": "üìç Observation points",
    "text": "üìç Observation points\nBy using the attribute obs_points we can add a list of observation points for which we will extract timeseries of water levels as an output of our event scenarios. We can add a list of ObsPointModel objects. Each of these objects must have a name and a lat and lon attribute. The description is optional.\nKeep in mind that if a tide gauge station is added to the database, it will be automatically added as an observation point as well if it falls within the overland SFINCS domain.\n\n# Add observation points\nobs_point = [\n    ObsPointModel(\n        name=\"Ashley_river\",\n        description=\"Ashley River - James Island Expy\",\n        lat=32.7765,\n        lon=-79.9543,\n    ),\n]",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#sea-level-rise-slr-scenarios",
    "href": "3_api_docs/examples/database_builder/database_builder.html#sea-level-rise-slr-scenarios",
    "title": "üìò Example: Database Builder with Python",
    "section": "üìà Sea Level Rise (SLR) scenarios",
    "text": "üìà Sea Level Rise (SLR) scenarios\nWe can add sea level rise scenarios to be used in the projections of FloodAdapt, by using the slr_scenarios attribute, which should be a SlrScenariosModel object, with a file attribute pointing to a csv file with the columns: year, unit, scenario_1, scenario_2, ‚Ä¶, scenario_n, and a relative_to_year attribute, which indicate the year relative to which these scenarios should be translated, when used in FloodAdapt.\nHere we have created a slr scenario csv file like this already. Let‚Äôs have a quick look in what the csv file looks like.\n\nslr_csv = (STATIC_DATA_DIR  / \"slr.csv\").as_posix()\npd.read_csv(slr_csv)\n\n\n\n\n\n\n\n\nyear\nunits\nNOAA Low\nNOAA Intermediate-Low\nNOAA Intermediate\nNOAA Intermediate-High\nNOAA High\nNOAA Extreme\n\n\n\n\n0\n2000\nfeet\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n0.000000\n\n\n1\n2010\nfeet\n0.131234\n0.164042\n0.262467\n0.328084\n0.393701\n0.393701\n\n\n2\n2020\nfeet\n0.328084\n0.393701\n0.524934\n0.688976\n0.787402\n0.853018\n\n\n3\n2030\nfeet\n0.492126\n0.590551\n0.820210\n1.115486\n1.312336\n1.476378\n\n\n4\n2040\nfeet\n0.656168\n0.787402\n1.148294\n1.541995\n1.935696\n2.198163\n\n\n5\n2050\nfeet\n0.820210\n0.984252\n1.509186\n2.099738\n2.690289\n3.182415\n\n\n6\n2060\nfeet\n1.017060\n1.213911\n1.935696\n2.755906\n3.674541\n4.363517\n\n\n7\n2070\nfeet\n1.148294\n1.410761\n2.395013\n3.510499\n4.724409\n5.675853\n\n\n8\n2080\nfeet\n1.279528\n1.607612\n2.887139\n4.330709\n5.905512\n7.119423\n\n\n9\n2090\nfeet\n1.410761\n1.771654\n3.412073\n5.249344\n7.283465\n8.792651\n\n\n10\n2100\nfeet\n1.541995\n1.968504\n4.002625\n6.332021\n8.825459\n10.793963\n\n\n11\n2120\nfeet\n1.738845\n2.329396\n4.658793\n7.578740\n11.646982\n14.730971\n\n\n12\n2150\nfeet\n2.034121\n2.854331\n6.430446\n11.154856\n17.519685\n22.375328\n\n\n13\n2200\nfeet\n2.427822\n3.772966\n9.580053\n18.077428\n29.265092\n37.401575\n\n\n\n\n\n\n\n\n# Add SLR scenarios\nslr_scenarios = SlrScenariosModel(\n    file=slr_csv,\n    relative_to_year=2020,\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#social-vulnerability-index-svi",
    "href": "3_api_docs/examples/database_builder/database_builder.html#social-vulnerability-index-svi",
    "title": "üìò Example: Database Builder with Python",
    "section": "üßç‚Äç‚ôÇÔ∏èüßç‚Äç‚ôÄÔ∏è Social Vulnerability Index (SVI)",
    "text": "üßç‚Äç‚ôÇÔ∏èüßç‚Äç‚ôÄÔ∏è Social Vulnerability Index (SVI)\nA social vulnerability (SVI) layer can be added to the database for extra infographics related to who is impacted. This can be done with the svi attribute which is a db.SviConfigModel object. The path to a geospatial file with the SVI layer is provided with the file attribute, the field_name attribute defines the column name within the spatial file with the SVI value and the threshold defines the threshold value for the SVI, which distinguishes between vulnerable and non-vulnerable areas.\nIn our case we have already clipped an SVI layer (from https://www.atsdr.cdc.gov/place-health/php/svi/svi-data-documentation-download.html) to the Charleston area, so we can use it directly. Let‚Äôs have a quick look in what the SVI layer looks like.\n\nsvi_path = (STATIC_DATA_DIR / \"svi.gpkg\").as_posix()\nsvi_layer = gpd.read_file(svi_path)\n# Make a map of the SVI layer\nsvi_layer.explore(\n    column=\"SVI\",\n    name=\"Social Vulnerability Index (SVI)\",\n    tiles=\"CartoDB positron\",\n    cmap=\"RdBu_r\",\n    scheme=None,\n    style_kwds={\"color\": \"black\", \"weight\": 0.5, \"fillOpacity\": 0.7},\n    legend=True,\n    legend_kwds={\"caption\": \"SVI (0.5=center)\"},\n    categorical=False,\n    center=0.5\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNow, let‚Äôs create the SVI configuration object, using the SviConfigModel class.\n\n# Add social vulnerability index\nsvi = db.SviConfigModel(\n    file=svi_path,\n    field_name=\"SVI\",\n    threshold=0.5,\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#base-flood-elevation-bfe",
    "href": "3_api_docs/examples/database_builder/database_builder.html#base-flood-elevation-bfe",
    "title": "üìò Example: Database Builder with Python",
    "section": "üåä Base Flood Elevation (BFE)",
    "text": "üåä Base Flood Elevation (BFE)\nA base flood elevation (BFE) can be added to the database which allows users to elevate homes relative to this layer. This can be done with the bfe attribute which is a db.SpatialJoinModel object. The path to the geospatial vector file with the BFE layer is provided with the file attribute, the field_name attribute defines the column name within the spatial file with the BFE value.\nIn our case we have already created some dummy data, so we can use it directly. Let‚Äôs have a quick look in what the BFE layer looks like.\n\nbfe_path = (STATIC_DATA_DIR / \"bfe.gpkg\").as_posix()\nbfe_layer = gpd.read_file(bfe_path)\n# Make a map of the BFE layer\nbfe_layer_valid = bfe_layer[bfe_layer[\"STATIC_BFE\"] != -9999]\nbfe_layer_valid.explore(\n    column=\"STATIC_BFE\",\n    name=\"Base Flood Elevation (BFE) - feet\",\n    tiles=\"CartoDB positron\",\n    cmap=\"Blues\",\n    scheme=None,\n    style_kwds={\"color\": \"black\", \"weight\": 0.5, \"fillOpacity\": 0.7},\n    legend=True,\n    categorical=False,\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nLet‚Äôs create the BFE configuration object, using the SpatialJoinModel class.\n\n# Add base flood elevation\nbfe = db.SpatialJoinModel(\n    file=bfe_path,\n    name=\"bfe\",\n    field_name=\"STATIC_BFE\",\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#aggregation-areas",
    "href": "3_api_docs/examples/database_builder/database_builder.html#aggregation-areas",
    "title": "üìò Example: Database Builder with Python",
    "section": "üî≤ Aggregation areas",
    "text": "üî≤ Aggregation areas\nA list of different types of aggregation levels that can be included in the metrics aggregation can be defined by the aggregation_areas attribute. Each entry in the list can be defined by the SpatialJoinModel class, which has a name attribute to specify the shown name, a file attribute to specify the location of the geospatial vector file. The name is used to identify the aggregation area in the database, while the file is the path to a geospatial vector file with the aggregation area polygons and a field_name attribute to specify the column name within the spatial file with the aggregation area names.\nKeep in mind that the aggregation areas specified in the database builder configuration are additional to any aggregation areas already defined in the Delft-FIAT model.\n\naggr_path = (STATIC_DATA_DIR / \"subdivision.gpkg\").as_posix()\n# Here we can visualize in a map one of the aggragetion levels\naggr = gpd.read_file(aggr_path)\n# Make a map of the aggregation level 1 layer\naggr.explore(\n    column=\"SUDIV_UNIQUE\",\n    name=\"Aggregation Level: Subdivision\",\n    tiles=\"CartoDB positron\",\n    style_kwds={\"color\": \"black\", \"weight\": 0.5, \"fillOpacity\": 0.7},\n    legend=True,\n    legend_kwds={\"caption\": \"Aggregation Level 1\"},\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nWe can now add the aggregation level to the configuration, using the SpatialJoinModel class.\n\n# Add aggregation areas\naggregation_areas = [\n    db.SpatialJoinModel(\n        name=\"Subdivision\",\n        file=aggr_path,\n        field_name=\"SUDIV_UNIQUE\",\n    )\n]",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#exposure-objects-types",
    "href": "3_api_docs/examples/database_builder/database_builder.html#exposure-objects-types",
    "title": "üìò Example: Database Builder with Python",
    "section": "üèòÔ∏èüõ£Ô∏è Exposure Objects types",
    "text": "üèòÔ∏èüõ£Ô∏è Exposure Objects types\nThe location of the exposure objects (buildings and roads) in Delft-FIAT is defined by different geospatial vector files. By default, the name of the buildings file is set to buildings and the roads file is set to roads. If this is not the case these values can be changed using the fiat_buildings_name and fiat_roads_name attributes, respectively.\nFloodAdapt works with roads as polygons, so if the roads file is in line format, we can use the road_width attribute to define the width of the road. This will be used to create a polygon representation of the roads in the database. By default this is set to 5.0 meters, but it can be changed to any other value.\n\n# In our case we keep the default values for the exposure options\nfiat_buildings_name = \"buildings\"\nfiat_roads_name = \"roads\"\nroad_width = us.UnitfulLength(value=5, units=us.UnitTypesLength.meters)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/database_builder/database_builder.html#building-footprints",
    "href": "3_api_docs/examples/database_builder/database_builder.html#building-footprints",
    "title": "üìò Example: Database Builder with Python",
    "section": "üè¢ Building Footprints",
    "text": "üè¢ Building Footprints\nBuildings in FIAT exposure can be represent as points. Then we want to aggregate these to building footprints, which are polygons. This can be done by using the building_footprints attribute, which is a db.SpatialJoinModel object. The file attribute defines the path to the geospatial vector file with the building footprints and the field_name attribute defines the column name within the spatial file with the building footprint names. If we don‚Äôt provide a building footprints file, the building footprints will be downloaded from the OpenStreetMap (OSM) database.\n\n# Visualize building footprints in a single color\nbuilding_fp_path = (STATIC_DATA_DIR / \"FEMA_building_footprints.gpkg\").as_posix()\nbuilding_fp_gdf = gpd.read_file(building_fp_path)\nbuilding_fp_gdf.explore(\n    name=\"Building Footprints\",\n    tiles=\"CartoDB positron\",\n    style_kwds={\"color\": \"black\", \"weight\": 0.5, \"fillColor\": \"#3182bd\", \"fillOpacity\": 0.7},\n    legend=False\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nWe can now define the building footprints configuration object, using the SpatialJoinModel class.\n\nbuilding_footprints = db.SpatialJoinModel(\n    file=building_fp_path,\n    field_name=\"BUILD_ID\", # unique identifier for the building footprints\n)",
    "crumbs": [
      "Database Builder (Python)"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/event_modification.html",
    "href": "3_api_docs/examples/events/event_modification.html",
    "title": "üíæ Event modifications in the database",
    "section": "",
    "text": "This notebook demonstrates how to manipulate event objects in a FloodAdapt database, including loading, creating, editing, copying, and deleting events.\nIt is assumed that at the start of this notebook, you have a database and the events saved from the other event notebooks.\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt.objects import HistoricalEvent\nfrom flood_adapt.objects.forcing.time_frame import TimeFrame\n\n# Setup FloodAdapt\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\"\n\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:19:52 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:19:52 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Events",
      "Event modification"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/event_modification.html#analyze-the-effect-of-different-rainfall-forcings",
    "href": "3_api_docs/examples/events/event_modification.html#analyze-the-effect-of-different-rainfall-forcings",
    "title": "üíæ Event modifications in the database",
    "section": "Analyze the effect of different rainfall forcings",
    "text": "Analyze the effect of different rainfall forcings\nLets say we want to analyze the effect of rainfall, how would you approach that:\n\nRetrieve an event from the database\nCreate the rainfall forcings you want to analyze\nUpdate the event‚Äôs name and rainfall forcings\nSave the updated event to the database\nCreate scenarios using these events and run them (see this example) TODO\n\nOf course, this approach also works for analyzing the difference between any other forcings.\n\n# 1. Create an event or load it from the database\nevent_name=\"database_manipulation_event\"\nevent = HistoricalEvent(\n    name=event_name,\n    description=\"Some event description\",\n    time=TimeFrame(\n        start_time=datetime(2020, 1, 1),\n        end_time=datetime(2020, 1, 2),\n    ),\n    forcings={\n        f.ForcingType.WATERLEVEL: [f.WaterlevelGauged()]\n    }\n)\nfa.save_event(event=event)\n\n# 2. Create rainfall forcings\nrainfall_constant = f.RainfallConstant(\n    intensity=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr)\n)\n\nrainfall_synthetic = f.RainfallSynthetic(\n    timeseries=f.GaussianTimeseries(\n        duration=us.UnitfulTime(value=12, units=us.UnitTypesTime.hours),\n        # Choose the middle of the time frame for peak time\n        peak_time=us.UnitfulTime.from_timedelta(event.time.duration / 2), \n        peak_value=us.UnitfulIntensity(value=10, units=us.UnitTypesIntensity.mm_hr),\n    )\n)\n\nrainfall_csv = f.RainfallCSV(path=STATIC_DATA_DIR / \"rainfall.csv\")\n\nrainfall_forcings = [\n    (rainfall_constant, \"constant\"),\n    (rainfall_synthetic, \"synthetic\"),\n    (rainfall_csv, \"csv\")\n]\n\nfor forcing, fsource in rainfall_forcings:\n    # 3. Update the event\n    event.forcings[f.ForcingType.RAINFALL] = [forcing]\n    event.name = f\"{event_name}_rainfall_{fsource}\"\n    \n    # 4. Save the event\n    fa.save_event(event=event)\n\nfa.get_events()[\"name\"]\n\n# 5. Now the events can be used as the components for scenario creation. Similar to how the rainfall forcings are used to create various events\n# For more information on how to create scenarios, see the scenario creation example\n\n['event_set',\n 'test_set',\n 'database_manipulation_event',\n 'database_manipulation_event_rainfall_constant',\n 'database_manipulation_event_rainfall_synthetic',\n 'database_manipulation_event_rainfall_csv']",
    "crumbs": [
      "Examples",
      "Events",
      "Event modification"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/event_modification.html#delete-save-copy-edit",
    "href": "3_api_docs/examples/events/event_modification.html#delete-save-copy-edit",
    "title": "üíæ Event modifications in the database",
    "section": "Delete, Save, Copy, Edit",
    "text": "Delete, Save, Copy, Edit\nFloodAdapt supports deleting, editing, and copying objects by name, as shown below.\nIt is possible to achieve the exact same goal in multiple ways:\n\nevent = fa.get_event(event_name) -&gt; update event -&gt; fa.delete_event(event_name) -&gt; fa.save_event(event)\nevent = fa.get_event(event_name) -&gt; update event -&gt; fa.edit_event(event)\n\n\nprint(\"Initial:\", fa.get_events()[\"name\"])\n\n# Copy all events\nfor name in fa.get_events()[\"name\"]:\n    new_name = f\"{name}_copy\"\n    fa.copy_event(old_name=name, new_name=new_name, new_description=f\"Copy of {name}\")\nprint(\"Names after `Copy`:\", fa.get_events()[\"name\"])\n\n# Delete all copied events\nfor name in fa.get_events()[\"name\"]:\n    if \"copy\" in name:\n        fa.delete_event(name)\nprint(\"Names after `Delete`:\", fa.get_events()[\"name\"])\n\n# Edit an existing event\nunedited_event = fa.get_event(event_name)\nprint(\"Description before `Edit`:\", unedited_event.description)\n\nunedited_event.description = f\"Updated description\"\nfa.save_event(event=unedited_event, overwrite=True)\n\nedited_event = fa.get_event(event_name)\nprint(\"Description after `Edit`:\", edited_event.description)\n\nInitial: ['event_set', 'test_set', 'database_manipulation_event', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_synthetic', 'database_manipulation_event_rainfall_csv']\nNames after `Copy`: ['event_set', 'test_set', 'database_manipulation_event', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_synthetic', 'database_manipulation_event_rainfall_csv', 'event_set_copy', 'test_set_copy', 'database_manipulation_event_copy', 'database_manipulation_event_rainfall_constant_copy', 'database_manipulation_event_rainfall_synthetic_copy', 'database_manipulation_event_rainfall_csv_copy']\nNames after `Delete`: ['event_set', 'test_set', 'database_manipulation_event', 'database_manipulation_event_rainfall_constant', 'database_manipulation_event_rainfall_synthetic', 'database_manipulation_event_rainfall_csv']\nDescription before `Edit`: Some event description\nDescription after `Edit`: Some event description",
    "crumbs": [
      "Examples",
      "Events",
      "Event modification"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html",
    "href": "3_api_docs/examples/events/hurricane_event.html",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "",
    "text": "This notebook demonstrates how to create a hurricane event using FloodAdapt. Hurricane events are valuable for controlled testing, sensitivity analysis, and understanding the behavior of flood models under simplified or hypothetical scenarios.\nA FloodAdapt Event consists of 2 things:\nIn this example, we construct a full HurricaneEvent with water level, rainfall, wind, and river discharge forcings, and then save it to a FloodAdapt database.",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-1.-setup-and-imports",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-1.-setup-and-imports",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "‚è±Ô∏è Step 1. Setup and Imports",
    "text": "‚è±Ô∏è Step 1. Setup and Imports\nWe begin by importing the required classes and modules for constructing hurricane forcings and managing event data within the flood_adapt framework.\n\nimport flood_adapt.objects.forcing as f\n\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom flood_adapt.objects import HurricaneEvent, TimeFrame\nfrom flood_adapt.objects.events.hurricane import TranslationModel\nfrom flood_adapt import unit_system as us\nfrom flood_adapt import FloodAdapt, Settings\n\n# Setup FloodAdapt\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\"\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:20:30 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:20:30 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-2.-define-the-simulation-time-frame",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-2.-define-the-simulation-time-frame",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üóìÔ∏è Step 2. Define the Simulation Time Frame",
    "text": "üóìÔ∏è Step 2. Define the Simulation Time Frame\nWe specify a one-day time frame for the hurricane event, from January 1 to January 2, 2025. Make sure the time frame covers the tinme specified in your hurricane track file.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2025, month=1, day=1)\nend_time = datetime(year=2025, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-3.-define-water-level-forcing",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-3.-define-water-level-forcing",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåä Step 3. Define Water Level Forcing",
    "text": "üåä Step 3. Define Water Level Forcing\nWater levels for Hurricane Events are computed by taking the Hurricane Track, and generating a pressure and wind field along its track.\nThese fields are then used as forcing inputs to the offshore simulation, which generates the storm surge to be used for the overland simulation. So for waterlevels, we only need to specify to use the offshore model as the input, denoted with WaterlevelModel\n\nwater_levels = f.WaterlevelModel()",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-3.-obtain-a-hurricane-track",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-3.-obtain-a-hurricane-track",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåßÔ∏è Step 3. Obtain a hurricane track",
    "text": "üåßÔ∏è Step 3. Obtain a hurricane track\nYou can include an IBTrACS hurricane database with recent and historic tracks in the FloodAdapt database. You can use any track from the database and optionally shift the track north, southh, east or west.\n\nNOTE: Hurricane events are only available in FloodAdapt when you have an offshore flood hazard model in your database that simulates the surge from the hurricane track.\n\n\n# Get the cyclone database\ncyclone_db = fa.database.static.get_cyclone_track_database()\nian_index = cyclone_db.list_names().index(\"IAN\")\n\n# Not all cyclone tracks have names, in addition to duplicate names existing, so the index is required\ntrack = fa.get_cyclone_track_by_index(index=ian_index) \ntrack_file = STATIC_DATA_DIR / \"IAN.cyc\"\ntrack.write_track(filename=track_file, fmt=\"ddb_cyc\")\n\n# Optionally translate the cyclone track from what is defined in the file\ntranslation = TranslationModel(\n    eastwest_translation=us.UnitfulLength(value=3000, units=us.UnitTypesLength.meters),\n    northsouth_translation=us.UnitfulLength(value=5000, units=us.UnitTypesLength.meters),\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-4.-define-track-forcings",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-4.-define-track-forcings",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üåßÔ∏è Step 4. Define Track forcings",
    "text": "üåßÔ∏è Step 4. Define Track forcings\nGiven a Hurricane track, the wind field is always computer from the track. You can choose to model the rainfall based on a parametric model around the hurricane track or choose any iother rainfall option.\n\n# We want to include the rainfall and wind from the hurricane track\nrainfall = f.RainfallTrack(path=track_file)\nwind = f.WindTrack(path=track_file)",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-5.-define-river-discharge-forcing",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-5.-define-river-discharge-forcing",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üèûÔ∏è Step 5. Define River Discharge Forcing",
    "text": "üèûÔ∏è Step 5. Define River Discharge Forcing\nDischarge is defined for two pre-configured rivers in this example. These rivers must be registered in the hazard model configuration beforehand, see [Database builder].\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event\n# You can only set the discharge of each given river.\nriver = fa.database.site.sfincs.river[0]\n\ndischarge = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\n# Inspect\ndf = discharge.to_dataframe(time_frame=time_frame)\ndf.plot(title=\"Constant Discharge River\", xlabel=\"Time\", ylabel=\"Discharge (cms)\", legend=True, figsize=(5, 2))",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-6.-combine-forcings-and-create-hurricane-event",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-6.-combine-forcings-and-create-hurricane-event",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üß© Step 6. Combine Forcings and Create hurricane Event",
    "text": "üß© Step 6. Combine Forcings and Create hurricane Event\nAll defined forcings are collected into a single dictionary, which is used to construct a hurricaneEvent.\n\nNOTE: each event can only have 1 forcing of the types: water level, rainfall and wind. For discharge however, each river is required to have a forcing associated with it.\n\n\n# Create a hurricaneEvent with the forcings and time frame\nevent = HurricaneEvent(\n    name=\"example_hurricane_event\",\n    time=time_frame,\n    forcings = {\n        f.ForcingType.WATERLEVEL: [water_levels],\n        f.ForcingType.RAINFALL: [rainfall],\n        f.ForcingType.WIND: [wind],\n        f.ForcingType.DISCHARGE: [discharge],\n    },\n    track_name=track.name,\n    hurricane_translation=translation,\n)",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/events/hurricane_event.html#step-7.-save-the-event-to-a-floodadapt-database",
    "href": "3_api_docs/examples/events/hurricane_event.html#step-7.-save-the-event-to-a-floodadapt-database",
    "title": "üìò Example: Creating a Hurricane Event in FloodAdapt",
    "section": "üíæ Step 7. Save the Event to a FloodAdapt Database",
    "text": "üíæ Step 7. Save the Event to a FloodAdapt Database\nFinally, we save the event to a FloodAdapt database.\n\n# Save the event to the database\nfa.save_event(event=event)",
    "crumbs": [
      "Examples",
      "Events",
      "Hurricane Event"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html",
    "href": "3_api_docs/examples/measures/measures_strategies.html",
    "title": "üìò Example: Measures and Strategies",
    "section": "",
    "text": "In this notebook we will show you all the different options and inputs for creating different measures and how to create a strategy from the different measures.\nMeasures in FloodAdapt can be categorized into two different categories, which we will cover all in this notebook:\n1. Hazard - Mitigate the hazard directly\n2. Impact - Mitiage the impacts of the hazard on the assets\nStrategies consist of multiple measures combined for example: StrategyXYZ = Floodwall + Elevated Homes + Pumps\nIf you want to learn in more detail about measures and what a strategy is, please read the sections on Measures in the FloodAdapt GUI documentation.",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#import-libraries",
    "href": "3_api_docs/examples/measures/measures_strategies.html#import-libraries",
    "title": "üìò Example: Measures and Strategies",
    "section": "Import libraries",
    "text": "Import libraries\n\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\n\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt.objects import (\n    FloodProof, FloodWall, Elevate, GreenInfrastructure, Buyout, Pump, Strategy, MeasureType, SelectionType\n)\nfrom flood_adapt import unit_system as us",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-1.-reading-in-the-floodadapt-database",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-1.-reading-in-the-floodadapt-database",
    "title": "üìò Example: Measures and Strategies",
    "section": "üöÄ Step 1. Reading-in the FloodAdapt database",
    "text": "üöÄ Step 1. Reading-in the FloodAdapt database\nLet‚Äôs start with initiating the database and FloodAdapt class. 1. Initiate the database class Settings by defining the DATABASE_ROOT and DATABASE_NAME. 2. Initiate the FloodAdapt class by parsing the Settings().database_path.\n\n# Define the static data folder\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\" / \"3_Measures\"\n\n# Set up the settings for the database\nsettings=Settings(\n    DATABASE_ROOT=DATA_DIR / \"examples\",\n    DATABASE_NAME=\"charleston_test\"\n)\n\n# Create the FloodAdapt instance\nfa = FloodAdapt(settings.database_path)\n\n2026-02-27 11:21:15 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:21:15 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-2.-create-hazard-measures",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-2.-create-hazard-measures",
    "title": "üìò Example: Measures and Strategies",
    "section": "üåßÔ∏è Step 2. Create Hazard Measures",
    "text": "üåßÔ∏è Step 2. Create Hazard Measures\nWe can divide the hazard measures into: 1. Hydraulic (grey) measures - structures such as levees, pumps, seawalls that protect infrastructure and residents 2. Green infrastructure measures - integrate natural elements like parks, green roofs, and permeable pavements into city\nTo create a hazard measure in Floodadapt we need to create a Measure object. Depending on the type of measure different attributes must be parsed. There are three types of hazard measures: 1. Floodwall 2. Pump 3. Green Infrastructure The green infrastructure class can be divided into sub-categories:\n- Greening - Total storage - Water square\nBelow we will create a Measure object for each of the three hazard measure.\n\nüß±üåä Floodwall\nWhen we create a floodwall object we need to specify the elevation attribute to capture the height of the floodwall. To define the elevation we need to parse a UnitfulLength object which consists of a value of type float and a unit which can be one of the UnitTypesLength. The selection_type describes the spatial type. This should be of SelectionType.polyline for a floodwall.\n\n# Create a measure object for a Floodwall\nfloodwall = FloodWall(\n    name=\"seawall_12ft\",\n    description=\"12ft Seawall\",\n    selection_type=SelectionType.polyline,\n    polygon_file=str(STATIC_DATA_DIR / \"seawall.geojson\"),\n    elevation=us.UnitfulLengthRefValue(value=12, units=us.UnitTypesLength.feet, type=us.VerticalReference.datum)\n)\n\n\n\n‚õΩüí¶ Pump\nWhen we create a pump object we need to specify the discharge attribute to capture the total river discharge in the model. To define the discharge we need to parse a UnitfulLength object which consists of a value of type float and a unit which can be one of the UnitTypesLength. The selection_type describes the spatial type. This should be of SelectionType.polygon for a pump.\n\n# Create a measure object for a Pump\npump = Pump(\n    name= \"Pump\",\n    description=\"Pump\",\n    selection_type=SelectionType.polygon,\n    polygon_file=str(STATIC_DATA_DIR / \"pump.geojson\"),\n    discharge=us.UnitfulDischarge(value=1, units=us.UnitTypesDischarge.cfs)\n)\n\n\n\nüå±üñºÔ∏è Green infrastructure\nWhen we create a green infrastructure object we need to specify the volume attribute to capture the total storage of the green infrastructure. o define the volume we need to parse a UnitfulVolume object which consists of a value of type float and a unit which can be one of the UnitTypesVolume. The selection_type describes the spatial type. This should be of SelectionType.polygon or SelectionType.aggregation_area for a green infrastructure. Other attributes like height and percentage are optional.\n\nNote: GreenInfraStructure is the only measure for which it is required to pass the specific type (or sub-category as described above) to create the object, all other measures have the correct default.\n\n\n# Create a measure object for Green infrastructure\ngreening = GreenInfrastructure(\n    name= \"green_infrastructure_storage\",\n    description=\"Storage through green infrastructure\",\n    type=MeasureType.greening,\n    selection_type=SelectionType.polygon,\n    polygon_file=str(STATIC_DATA_DIR / \"greening.geojson\"),\n    volume=us.UnitfulVolume(value=43975190.31512848, units=us.UnitTypesVolume.cf),\n    height=us.UnitfulHeight(value=3, units=us.UnitTypesLength.feet),\n    percent_area=100.0\n)\n\ntotal_storage = GreenInfrastructure(\n    name=  \"total_storage_aggregation_area\",\n    description=\"Total Storage through green infrastructure in aggr area\",\n    type=MeasureType.total_storage,\n    selection_type=SelectionType.aggregation_area,\n    aggregation_area_type=\"Subdivision\",\n    aggregation_area_name=\"The Citadel\",\n    volume=us.UnitfulVolume(value=100000000.0, units=us.UnitTypesVolume.cf),\n)\n\nwater_square = GreenInfrastructure(\n    name=\"w_square\",\n    description=\"Water Square\",\n    type=MeasureType.water_square,\n    selection_type=SelectionType.polygon,\n    polygon_file=str(STATIC_DATA_DIR / \"water_square.geojson\"),\n    volume=us.UnitfulVolume(value=43975190.31512848, units=us.UnitTypesVolume.cf),\n    height=us.UnitfulHeight(value=3, units=us.UnitTypesLength.feet)\n)  \n\nLet‚Äôs have a look at some of the measures. We can for example explore the floodwall. If you want to explore another measure, update the measure variable in the cell below and re-run it.\n\nmeasure = floodwall # or `pump` or `greening` or `total_storage` or `water_square`\ngdf = gpd.read_file(measure.polygon_file)\ngdf.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-3.-saving-the-hazard-measures-to-the-database",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-3.-saving-the-hazard-measures-to-the-database",
    "title": "üìò Example: Measures and Strategies",
    "section": "üíæ Step 3. Saving the hazard measures to the database",
    "text": "üíæ Step 3. Saving the hazard measures to the database\n\n# # Save the measures to the database\nfa.save_measure(floodwall)\nfa.save_measure(pump)\nfa.save_measure(greening)\nfa.save_measure(total_storage)\nfa.save_measure(water_square)",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-4-create-impact-measures",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-4-create-impact-measures",
    "title": "üìò Example: Measures and Strategies",
    "section": "üè† Step 4: Create Impact Measures",
    "text": "üè† Step 4: Create Impact Measures\nTo create a impact measure in Floodadapt we need to create a Measure object. In the attributes we define which type of measure we want to apply using the type attribute. Depending on the type of measure different attributes must be parsed. There are three types of impact measures: 1. Elevate 2. Buy out 3. Floodproof\nWe can apply measures to a specific building occupancy by defining the occupancy in the property_type attribute. For example, if we only want to buyout residential homes we can parse the building type of the residential buildings here. Make sure you parse the same string-value as you use in your Delft-FIAT model to describe that type of building.\nIf we want to apply the measure only in a specific aggregation area, we can define this with the aggregation_area_type, which describes the name of the aggregation area category, and the aggregation_area_name, which responds to the name of the specific aggregation area within the category.\nBelow we will create a Measure-object for each impact measure.\n\nüè†‚¨ÜÔ∏è Elevate\nWhen we create a Elevate object we need to specify the elevation attribute to capture the height of the elevation. To define the elevation we need to parse a UnitfulLengthRefValue object which consists of a value of type float, a unit which can be one of the UnitTypesLength and a vertical reference from which point the elevation should be calculated. This sholud be parsed as VerticalReference object.\n\n# Create a measure object for elevating buildings\nelevate = Elevate(\n    name=\"elevate_homes_2ft\",\n    description=\"Elevate all residential buildings in aggregation area 1 by 2ft.\",\n    selection_type=SelectionType.polygon,\n    property_type=\"residential\",\n    polygon_file=str(STATIC_DATA_DIR / \"raise_property_polygon.geojson\"),\n    elevation=us.UnitfulLengthRefValue(value=2, units=us.UnitTypesLength.feet, type=us.VerticalReference.floodmap)\n)\n\n\n\nüë•üí∞ Buyout\nWhen we create a Buyout object we need to specify the property_type and either provide a spatial file for the area boundaries or define the aggregation_area_type and aggregation_area_name.\n\n# Create a measure object for buying out buildings\nbuyout = Buyout(\n    name= \"buyout_all_buildings\",\n    description=\"Buyout all buildings in a specific area.\",\n    selection_type=SelectionType.aggregation_area,\n    aggregation_area_type=\"Subdivision\",\n    aggregation_area_name=\"Garden Kiawah\",\n    property_type=\"ALL\",\n)\n\n\n\nüè†üåä Floodproof\nWhen we create a FloodProof object we need to specify the elevation attribute to capture the height of the elevation. To define the elevation we need to parse a UnitfulLength object which consists of a value of type float, a unit which can be one of the UnitTypesLength.\n\n# Create a measure object for flood proofing buildings\nflood_proof = FloodProof(\n    name=\"floodproof_all_com\",\n    description=\"Floodproofing all commercial buildings.\",\n    selection_type=SelectionType.all,\n    property_type=\"commercial\",\n    elevation=us.UnitfulLength(value=2, units=us.UnitTypesLength.feet)\n)\n\nLet‚Äôs have a look at some of the measures. We can for example explore the area in which all buildings will be elevated.\n\nmeasure = elevate  # or `buyout` or `flood_proof`\ngdf = gpd.read_file(measure.polygon_file)\ngdf.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-5.-saving-the-impact-measures-to-the-database",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-5.-saving-the-impact-measures-to-the-database",
    "title": "üìò Example: Measures and Strategies",
    "section": "üíæ Step 5. Saving the impact measures to the database",
    "text": "üíæ Step 5. Saving the impact measures to the database\n\n# Save the measures to the database\nfa.save_measure(elevate)\nfa.save_measure(buyout)\nfa.save_measure(flood_proof)\n\nUsing the get_measures() method of the FloodAdapt class, we can check that the measures have been saved to the database.\n\n# Get a df with all strategies\npd.DataFrame(fa.get_measures())\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\ngeometry\n\n\n\n\n0\nseawall_12ft\n12ft Seawall\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:17.938341\nid ...\n\n\n1\nPump\nPump\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:17.947343\nge...\n\n\n2\ngreen_infrastructure_storage\nStorage through green infrastructure\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:17.957152\nge...\n\n\n3\ntotal_storage_aggregation_area\nTotal Storage through green infrastructure in ...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:17.959164\nname ...\n\n\n4\nw_square\nWater Square\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:17.969264\nge...\n\n\n5\nelevate_homes_2ft\nElevate all residential buildings in aggregati...\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:18.063738\nid ...\n\n\n6\nbuyout_all_buildings\nBuyout all buildings in a specific area.\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:18.065494\nname ...\n\n\n7\nfloodproof_all_com\nFloodproofing all commercial buildings.\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:18.067511\nNone",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-6-copying-and-editing-a-measure-in-the-database",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-6-copying-and-editing-a-measure-in-the-database",
    "title": "üìò Example: Measures and Strategies",
    "section": "‚úèÔ∏è Step 6: Copying and Editing a Measure in the database",
    "text": "‚úèÔ∏è Step 6: Copying and Editing a Measure in the database\nIf we want to edit small parts of a measure, it is easier to copy an existing measure and edit the copy. This way we do not have to create a new measure from scratch.\nA measure can be copied in the database by using the copy_measure() method of the FloodAdapt class. This method takes three arguments: the name of the measure to be copied and the name and description of the new measure. Let‚Äôs copy the measure we just created, having in mind that we want to make a measure for flood-proofing residential buildings.\n\n# Copy measure\nfa.copy_measure(\n    old_name=\"floodproof_all_com\",\n    new_name=\"floodproof_all_res\",\n    new_description=\"Floodproofing all residential buildings.\"\n)\n\nWe can see that now a new measure with name ‚Äúfloodproof_all_res‚Äù has been created in the database. However, the actual attributes of the measure are still the same as the original measure.\n\n# Inspect Measure\nfloodproof_res = fa.get_measure(\"floodproof_all_res\")\nfloodproof_res\n\nFloodProof(name='floodproof_all_res', description='Floodproofing all residential buildings.', type=&lt;MeasureType.floodproof_properties: 'floodproof_properties'&gt;, selection_type=&lt;SelectionType.all: 'all'&gt;, polygon_file=None, aggregation_area_type=None, aggregation_area_name=None, property_type='commercial', elevation=UnitfulLength(value=2.00, units=feet))\n\n\nWe can directly edit the relevant attributes of the measure object. In this case, we want to change the type to ‚Äúresidential‚Äù.\n\n# Edit attributes\nfloodproof_res.property_type = \"residential\"\n\nThen using the save_measure() method of the FloodAdapt class, we can save the changes to the database. This method takes a two arguments which are the Measure object and an optional boolean overwrite. The name field of the measure object provided will be used to identify which measure is going to be updated in the database, with the given Measure object attributes.\n\n# Save updates\nfa.save_measure(floodproof_res, overwrite=True)\n\nNow we can verify that the measure has been updated in the database. The property type is now ‚Äúresidential‚Äù.\n\n# Verify updates\nfloodproof_res = fa.get_measure(\"floodproof_all_res\")\nfloodproof_res.property_type\n\n'residential'",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-6.-create-a-strategy",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-6.-create-a-strategy",
    "title": "üìò Example: Measures and Strategies",
    "section": "üß© Step 6. Create a Strategy",
    "text": "üß© Step 6. Create a Strategy\nStrategies are combinations measures. They allow us to run an test multiple measures in a single model run.\nTo create a strategy we need to create a Strategy object. In the measures attribute we parse a list of all the names of the measures that we want to apply in that strategy.\n\nNote: All measures of a strategy need to be saved in the database before you can save the strategy itself.\n\n\n# Create a strategy object\nstrategy = Strategy(\n    name=\"pump_greening_flood_proof\",\n    description=\"Strategy with pump, greening and floodproofing\",\n    measures=[pump.name, greening.name, flood_proof.name],\n)\n\n# Save the strategy\nfa.save_strategy(strategy)\n\nUsing the get_strategies() method of the FloodAdapt class, we can check that the strategies have been saved to the database.\n\n# Get a df with all strategies\npd.DataFrame(fa.get_strategies())\n\n\n\n\n\n\n\n\nname\ndescription\npath\nlast_modification_date\n\n\n\n\n0\nno_measures\n\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 10:59:24.420629\n\n\n1\npump_greening_flood_proof\nStrategy with pump, greening and floodproofing\nD:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples...\n2026-02-27 11:21:18.709849\n\n\n\n\n\n\n\n\n# Inspect strategy\nstrategy = fa.get_strategy(\"pump_greening_flood_proof\")\nstrategy\n\nStrategy(name='pump_greening_flood_proof', description='Strategy with pump, greening and floodproofing', measures=['Pump', 'green_infrastructure_storage', 'floodproof_all_com'])",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#step-7.-copying-and-editing-a-strategy-in-the-database",
    "href": "3_api_docs/examples/measures/measures_strategies.html#step-7.-copying-and-editing-a-strategy-in-the-database",
    "title": "üìò Example: Measures and Strategies",
    "section": "‚úèÔ∏è Step 7. Copying and Editing a Strategy in the database",
    "text": "‚úèÔ∏è Step 7. Copying and Editing a Strategy in the database\nIf we want to edit small parts of a strategy, it is easier to copy an existing strategy and edit the copy. This way we do not have to create a new strategy from scratch.\nA strategy can be copied in the database by using the copy_strategy() method of the FloodAdapt class. This method takes three arguments: the name of the strategy to be copied and the name and description of the new strategy. Let‚Äôs copy the strategy we just created, having in mind that we want to remove the greening from the strategy and add a floodwall instead.\n\n# Copy strategy\nfa.copy_strategy(\n    old_name=\"pump_greening_flood_proof\", \n    new_name=\"pump_floodwall_flood_proof\", \n    new_description=\"Strategy with pump, flodwall and floodproofing.\",\n)\n\nWe can see that now a new strategy with name ‚Äúpump_floodwall_flood_proof‚Äù has been created in the database. However, the actual attributes of the strtaegy are still the same as the original srtategy.\n\n# Inspect strategy2\nstrategy_2 = fa.get_strategy(\"pump_floodwall_flood_proof\")\nstrategy_2\n\nStrategy(name='pump_floodwall_flood_proof', description='Strategy with pump, flodwall and floodproofing.', measures=['Pump', 'green_infrastructure_storage', 'floodproof_all_com'])\n\n\nWe can directly edit the relevant attributes of the measure object. In this case, we want to change the type to ‚Äúresidential‚Äù.\n\nstrategy_2.measures.remove(greening.name)  # Remove greening\nstrategy_2.measures.append(floodwall.name) # Add floodwall\n\nThen using the save_strategy(name, overwrite=True) method of the FloodAdapt class, we can save the changes to the database. This method takes a single argument which is a Strategy object. The name field of the Strategy object provided will be used to identify which strategy is going to be updated in the database, with the given Strategy object attributes.\n\n# Save updates\nfa.save_strategy(strategy_2, overwrite=True)\n\nNow we can verify that the strategy has been updated in the database.\n\n# Verify updates\nstrategy_2 = fa.get_strategy(\"pump_floodwall_flood_proof\")\nstrategy_2.measures\n\n['Pump', 'floodproof_all_com', 'seawall_12ft']",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/measures/measures_strategies.html#finished",
    "href": "3_api_docs/examples/measures/measures_strategies.html#finished",
    "title": "üìò Example: Measures and Strategies",
    "section": "Finished!",
    "text": "Finished!\nCongratulations you created all measures possible in FloodAdap and combined some of them into a strategy!",
    "crumbs": [
      "Examples",
      "Measures"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html",
    "title": "üìò Example: Advanced Scenario",
    "section": "",
    "text": "In this notebook we demonstrate the workflow on how you can build an advanced FloodAdapt scenario in Charleston, USA, using the API.\nIn this notebook we will cover the following steps:",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#import-libraries",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#import-libraries",
    "title": "üìò Example: Advanced Scenario",
    "section": "Import libraries",
    "text": "Import libraries\n\n# Import packages\nimport os\nimport geopandas as gpd\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\nimport contextily as cx\n\nfrom datetime import datetime\nfrom pathlib import Path\nfrom IPython.display import HTML\n\nfrom flood_adapt.objects import forcing as f\nfrom flood_adapt.objects import (\n    HurricaneEvent,\n    TimeFrame,\n    Elevate,\n    FloodProof,\n    FloodWall,\n    GreenInfrastructure,\n    SelectionType,\n    MeasureType,\n    Projection, \n    PhysicalProjection, \n    SocioEconomicChange,\n    Scenario, \n    Strategy, \n)\n\nfrom flood_adapt.objects.events.hurricane import TranslationModel\n\nfrom flood_adapt import FloodAdapt, Settings\nfrom flood_adapt import unit_system as us",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-1.-reading-in-the-floodadapt-database",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-1.-reading-in-the-floodadapt-database",
    "title": "üìò Example: Advanced Scenario",
    "section": "üöÄ Step 1. Reading-in the FloodAdapt database",
    "text": "üöÄ Step 1. Reading-in the FloodAdapt database\nLet‚Äôs start with initiating the database and FloodAdapt class. 1. Initiate the database class Settings by defining the DATABASE_ROOT and DATABASE_NAME. 2. Initiate the FloodAdapt class by parsing the Settings().database_path.\n\n# Define the static data folder\nDATA_DIR = Path(\"../../../_data\").resolve()\nSTATIC_DATA_DIR = DATA_DIR / \"examples\" / \"static-data\" / \"5_Advanced_Scenario\"\n\n# Set up the settings for the database\nos.environ[\"USE_BINARIES\"] = \"True\"\nos.environ[\"FIAT_BIN_PATH\"] = (DATA_DIR / \"system\" / \"win-64\" / \"fiat\" / \"fiat.exe\").as_posix()\nos.environ[\"SFINCS_BIN_PATH\"] = (DATA_DIR / \"system\" / \"win-64\" / \"sfincs\" / \"sfincs.exe\").as_posix()\n\n# Create the FloodAdapt instance\nfa = FloodAdapt(database_path=DATA_DIR / \"examples\" / \"charleston_test\")\n\n2026-02-27 11:22:20 AM - FloodAdapt.Database - INFO - Initializing database to charleston_test at d:\\a\\floodadapt\\floodadapt\\docs\\_data\\examples\n2026-02-27 11:22:20 AM - FloodAdapt.Database - INFO - Loading database into memory",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-2.-events---create-a-synthetic-event",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-2.-events---create-a-synthetic-event",
    "title": "üìò Example: Advanced Scenario",
    "section": "üåä Step 2. Events - Create a synthetic Event",
    "text": "üåä Step 2. Events - Create a synthetic Event\nEvents in FloodAdapt are categorized into different forcings: 1. Wind 2. Rainfall 3. Discharge 4. Water Level\nIf you want to learn more about the individual forcings in FloodAdapt, please go and read the section on Events in the FloodAdapt documentation.\nWhen creating an event, we need to create an Event object. Depending on which type of event we create, we select a different class. In this example we create a synthetic event, therefore we use the SyntheticEvent class.\nTo create the SyntheticEvent object we use the time attribute to define the event duration. This should be parsed as a TimeFrame object. In the forcings attribute we aggregated the different forcing objects in a dictionary.\nIn this event example we will create an event with the following forcings:\nüå¨Ô∏è WindConstant: Define a value for a constant wind speed (mps) and direction (degrees)\nüåßÔ∏è RainfallConstant: Define a value for a constant rainfall (mm/hr)\nüí¶ DischargeConstant: Define the x and y coordinates of the discharge point of the Cooper River and a value for a constant mean discharge (cfs) in the River- and Discharge model (same value)\nüåä WaterlevelSynthetic SurgeModel: Define a peak time (h), peak value in (m) and duration (d)\n‚ÜîÔ∏éÔ∏è WaterlevelSynthetic TideModel: Define the harmonic amplitude (m), harmonic period (h) and harmonic phase (h)\nFor a complete guide on all the possible event options and inputs check out the notebooks specifically on events.\n\nStep 2.1: Create a Historical Hurricane Event\nIn FloodAdapt we can re-create and edit historical hurricanes and explore their impacts with altered parameters to answer community questions e.g.¬†what would have happened if the hurrican made landfall further south/north? To create a hurricane we need to do he following steps: 1. Set a time frame 2. Define the waterlevel 3. Obtain the hurricane track 4. Add rainfall 5. Add wind 6. Add River discharge\nFor a detailed description on how to create a hurricane event go to the event notebooks.\n\n# Create an time frame for the simulation\nstart_time = datetime(year=2025, month=1, day=1) \nend_time = datetime(year=2025, month=1, day=2)\ntime_frame = TimeFrame(start_time=start_time, end_time=end_time)\n\n# Define Water Level Forcing\nwater_levels = f.WaterlevelModel()\n\n# Obtain a hurricane track\n## Get the cyclone database\ncyclone_db = fa.database.static.get_cyclone_track_database()\nian_index = cyclone_db.list_names().index(\"IAN\")\n\n## Not all cyclone tracks have names, in addition to duplicate names existing, so it is better to use the index\ntrack = fa.get_cyclone_track_by_index(index=ian_index) \ntrack_file = STATIC_DATA_DIR / \"IAN.cyc\"\ntrack.write_track(filename=track_file, fmt=\"ddb_cyc\")\n\n## Optionally translate the cyclone track from what is defined in the file\ntranslation = TranslationModel(\n    eastwest_translation=us.UnitfulLength(value=3000, units=us.UnitTypesLength.meters),\n    northsouth_translation=us.UnitfulLength(value=5000, units=us.UnitTypesLength.meters),\n)\n\n# We want to include the rainfall and wind from the hurricane track\nrainfall = f.RainfallTrack(path=track_file)\nwind = f.WindTrack(path=track_file)\n\n# The available rivers are defined in the hazard model when creating the database.\n# You cannot add new rivers to the model in an event, you can only set the discharge of each given river.\nriver = fa.database.site.sfincs.river[0]\n\ndischarge = f.DischargeConstant(\n    river=river,\n    discharge=us.UnitfulDischarge(value=100, units=us.UnitTypesDischarge.cms)\n)\n\n# Inspect\ndf = discharge.to_dataframe(time_frame=time_frame)\ndf.plot(title=\"Constant Discharge River\", xlabel=\"Time\", ylabel=\"Discharge (cms)\", legend=True, figsize=(5, 2))\n\n\n\n\n\n\n\n\nüå™Ô∏èüåÄ Let‚Äôs put the forcings together and create the HurricaneEvent object.\n\n# Create a hurricaneEvent with the forcings and time frame\nevent = HurricaneEvent(\n    name=\"ian_hurricane_event\",\n    time=time_frame,\n    forcings = {\n        # The keys of the dictionary are the forcing types, and the values are lists of the corresponding forcing objects.\n        f.ForcingType.WATERLEVEL: [water_levels],\n        f.ForcingType.RAINFALL: [rainfall],\n        f.ForcingType.WIND: [wind],\n        f.ForcingType.DISCHARGE: [discharge],\n    },\n    track_name=track.name,\n    hurricane_translation=translation,\n)\n\n\n\nüíæ Step 2.1. Saving the event to the database\n\n# Save the event to the database\nfa.save_event(event)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-3.-projections---create-a-projection",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-3.-projections---create-a-projection",
    "title": "üìò Example: Advanced Scenario",
    "section": "üìà Step 3. Projections - Create a projection",
    "text": "üìà Step 3. Projections - Create a projection\nProjections in FloodAdapt allow us to adjust our model to future conditions such as sea level rise or/and population growth. If you want to learn more about projections in FlooAdapt, please go to the section Projections in the FloodAdapt documentation.\nThe projections can be divided into two categories: 1. üåä Physical Projections: Sea level rise, intensified precipitation, increased storm frequency 2. üí∞ Socio economic change: Population growth (existing built area, new development area), economic growth\nWhen creating a projection we need to create a Projection object. The PhysicalProjection attribute is parsed as a PhysicalProjection object which captures the physical projection such as sea lvel rise. The SocioEconomicChange attribute is parsed as a SocioEconomicChange object which captures the socioeconomic projection such as population growth. It‚Äôs not mandatory to parse both projections. If we only want to use one of the two types of projections we can leave the other one blank ().\nThe attributes of the PhysicalProjection or SocioEconomicChange object define the projection. In this case we parse the attribute sea_level_rise to the PhysicalProjection object and define the value in UnitfulLength and the unit in UnitTypesLength.\nTo get a deeper understanding for all the possible projections and their inputs go to the notebook specifically about projections.\nIn this example we will make use of sea level rise scenarios for a PhysicalProjection and explore population growth as SocioEconomicChange.\nFirst, let‚Äôs get the sea level rise scenarios from the database.\nA FloodAdapt database can include sea level rise scenarios, describing a timeline of future sea level rise relative to a reference year. If these scenarios are available in the database the get_slr_scn_names() method will return a list of the available scenarios. To get a deeper understanding on how you can create different Projections read the projection notebook.\n\n# Get the Scenarios\nfa.get_slr_scn_names()\n\n# Interpolate until 2050\nfa.interp_slr(slr_scenario=\"NOAA High\", year=2060)\n\n2.89\n\n\nUse that projection to create the Projection object.\n\nprojection = Projection(\n    name=\"proj_2060\",\n    description=\"2060 projection\", \n    physical_projection= PhysicalProjection(\n        sea_level_rise=us.UnitfulLength(value=fa.interp_slr(slr_scenario=\"NOAA High\", year=2060),\n        units=us.UnitTypesLength.feet)\n    ),\n)\nprojection\n\nProjection(name='proj_2060', description='2060 projection', physical_projection=PhysicalProjection(sea_level_rise=UnitfulLength(value=2.89, units=feet), subsidence=UnitfulLength(value=0.00, units=meters), rainfall_multiplier=1.0, storm_frequency_increase=0.0), socio_economic_change=SocioEconomicChange(population_growth_existing=0.0, economic_growth=0.0, population_growth_new=0.0, new_development_elevation=None, new_development_shapefile=None))\n\n\nNow we can create the population growth projection. To capture population growth, we will create a new development area and pass the population_growth_existing and population_growth_new. You find a detailed explanation of these input attributes in the FloodAdapt User Guide.\nWe can have a quick look at the new development area.\n\nnew_dev = gpd.read_file(STATIC_DATA_DIR / \"new_dev_areas.geojson\")\nnew_dev.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNow we can create the SocioEconomicChange object as part of the Projection object we created above. Then we are ready to save the projection.\n\n# Create new development area\nprojection.socio_economic_change = SocioEconomicChange(\n    population_growth_existing=10,\n    economic_growth=0,\n    population_growth_new=5,\n    new_development_shapefile=str(STATIC_DATA_DIR / \"new_dev_areas.geojson\"),\n    new_development_elevation=us.UnitfulLengthRefValue(\n        value=0.5,\n        units=us.UnitTypesLength.meters,\n        type=us.VerticalReference.datum\n    )\n)\n\n\nüíæ Step 3.1. Saving the projection to the database\n\n# Save projection\nfa.save_projection(projection)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-4.-measures---create-a-measure",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-4.-measures---create-a-measure",
    "title": "üìò Example: Advanced Scenario",
    "section": "üß± Step 4. Measures - Create a measure",
    "text": "üß± Step 4. Measures - Create a measure\nMeasures in FloodAdapt enable the user to mititgate the event impacts and investigate their efficiency on the fly.\nMeasures can be: 1. üí¶ Hydraulic measures on the hazard level 2. üå± Green infrastructure measures on the hazard level 3. üè† Impact measures on the building level.\nYou can read more about measures in the section Measures in the FloodAdapt documentation.\nüí¶ Hydraulic measures\nIn this example we will create two hydraulic measures, a sea wall of 12ft and a water square.\nüß± To create a measure we need to create a Measure object. In the attributes we define the measure type object, in the first example a FloodWall object. Additionally to the other attributes, we need to add the elevation value as UnitfulLength and the unit as UnitTypesLength of the sea wall.\n\n# Create a measure object for a seawall\nseawall = FloodWall(\n    name=\"seawall_16ft\",\n    description=\"16ft Seawall\",\n    selection_type=SelectionType.polyline,\n    polygon_file=str(STATIC_DATA_DIR / \"seawall.geojson\"),\n    elevation=us.UnitfulLengthRefValue(value=16, units=us.UnitTypesLength.feet, type=us.VerticalReference.datum)\n)\n\nüü¶ Next, we create the GreenInfrastructure water square object. Instead of the elevation attribute we need to define the volume of the total storage capacity of the water square. We use the UnitfulVolume object to define the value and unit of the storage capacity. Optionally we can add the height of the water square to validate the total storage volume.\n\n# Create a measure object for a water square\nwater_square = GreenInfrastructure(\n    name=\"water_square\",\n    description=\"Water Square\",\n    type=MeasureType.water_square,\n    selection_type=SelectionType.polygon,\n    polygon_file=str(STATIC_DATA_DIR / \"water_square.geojson\"),\n    volume=us.UnitfulVolume(value=43975190.31512848, units=us.UnitTypesVolume.cf),\n    height=us.UnitfulHeight(value=3, units = us.UnitTypesLength.feet)\n)\n\nüè† Impact Measure\nLet‚Äôs add two more measures on the impact level. We can for example flood proof and elevate buildings in a specific area to mititgate the impact on these assets.\n‚¨ÜÔ∏è When elevating buildings we need to create a Elevate object. To specify which buildings should be elevated we choose a selection_type and then either provide a spatial file with the boundaries of the area or select a whole aggregation area from our model. We can also specify which building types we want the measure to be applied on by defining the property type attribute. we need to use the property type (e.g.¬†residential, commercial, ALL‚Ä¶) that is used in our Delft-FIAT Model.\nTo capture the magnitude of elevation of the buildings we define the elevation attribute. Here we provide the value, unit of type UnitTypesLength, and vertical reference of type VerticalReference as part of the UnitfulLengthRefValue object.\n\n# Create a measure object for elevating buildings\nelevate = Elevate(\n    name=\"elevated_homes_1ft\",\n    description=\"Elevate residential buildings\",\n    selection_type=SelectionType.polygon,\n    polygon_file=str(STATIC_DATA_DIR / \"raise_property_polygon.geojson\"),\n    property_type=\"ALL\",\n    elevation=us.UnitfulLengthRefValue(value=1, units=us.UnitTypesLength.feet, type=us.VerticalReference.floodmap)\n)\n\nü¶∫ When we flood proof buildings we follow similar steps as when we elevate buildings. We create a FloodProof object where we define the same attributes as in the Elevate object. The only difference is here is, that we do not need to provide a vertical_reference for the elevation attribute.\n\n# Create a measure object for flood proofing commercial buildings\nflood_proof = FloodProof(\n    name=\"floodproof_all_commercial\",\n    description=\"Floodproofing all commercial buildings.\",\n    selection_type=SelectionType.all,\n    property_type=\"commercial\",\n    elevation=us.UnitfulLength(value=2, units=us.UnitTypesLength.feet)\n)\n\n\nüíæ Step 4.1. Saving the measure to the database\n\n# Save the measure\nfa.save_measure(seawall)\nfa.save_measure(water_square)\nfa.save_measure(elevate)\nfa.save_measure(flood_proof)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-5.-strategies---create-a-strategy",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-5.-strategies---create-a-strategy",
    "title": "üìò Example: Advanced Scenario",
    "section": "üß© Step 5. Strategies - Create a strategy",
    "text": "üß© Step 5. Strategies - Create a strategy\nStrategies are combinations measures. They allow us to run an test multiple measures in a single model run.\nTo create a strategy we need to create a Strategy object. In the measures attribute we parse a list of all the names of the measures that we want to apply in that strategy.\nIn this example we will create a strategy with the measures we created above, a sea wall of 12ft, a water square, elevating buildings 2ft above the floodmap reference in a specific area and flood proofing commercial buildings up to 1 ft.\n\n# Create a strategy object\nstrategy = Strategy(\n    name=\"seawall_greening_elev_build_floodproof_com\",\n    description=\"Strategy with a seawall, water square, elevation of buildings and floodp proofing commercial buildings\",\n    measures=[seawall.name, water_square.name, elevate.name, flood_proof.name],\n)\n\n\nüíæ Step 5.1. Saving the strategy to the database\n\n# Save the strategy\nfa.save_strategy(strategy)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#step-6.-create-a-scenario",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#step-6.-create-a-scenario",
    "title": "üìò Example: Advanced Scenario",
    "section": "üó∫Ô∏è Step 6. Create a scenario",
    "text": "üó∫Ô∏è Step 6. Create a scenario\nWe reached the final step where we can put all the building blocks together to create a complete scenario!\nA scenario is composed of:\n1. Event\n2. Projection\n3. Strategy (Measures)\nIf you want to read more about the composition of scenarios, go read the Scenario-section of the FloodAdapt documentation.\nWhen creating a scenario we need to create a Scenario object in which we parse the name of the event, projection and strategy as attributes.\n\n# Create a scenario object\nscenario = Scenario(\n    name=\"slr_pop_growth_seawall_water_square_elev_floodproof_build\",\n    description=\"Nearshore event with SLR and population growth projection. Strategy with a seawall, water square, elevation of buildings and floodp proofing commercial buildings.\",\n    event=event.name,\n    projection=projection.name,\n    strategy=strategy.name,\n)\n\n\nüíæ Step 6.1. Saving the scenario to the database\n\n# Save the scenario\nfa.save_scenario(scenario)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#final-step-run-a-scenario",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#final-step-run-a-scenario",
    "title": "üìò Example: Advanced Scenario",
    "section": "üèÉ‚Äç‚ôÄÔ∏è Final step: Run a scenario",
    "text": "üèÉ‚Äç‚ôÄÔ∏è Final step: Run a scenario\nWe are ready to run the scenario! Simply parse the scenario.name into the function run_scenario.\n\n# Run the scenario\nfa.run_scenario(scenario.name)\n\n2026-02-27 11:22:40 AM - FloodAdapt.ScenarioRunner - INFO - FloodAdapt version `2.0.3`\n2026-02-27 11:22:40 AM - FloodAdapt.ScenarioRunner - INFO - Started evaluation of `slr_pop_growth_seawall_water_square_elev_floodproof_build`\n2026-02-27 11:23:00 AM - FloodAdapt.SfincsAdapter - INFO - Preprocessing Scenario `slr_pop_growth_seawall_water_square_elev_floodproof_build`: Event `ian_hurricane_event`, Strategy `seawall_greening_elev_build_floodproof_com`, Projection `proj_2060`\n2026-02-27 11:23:00 AM - FloodAdapt.SfincsAdapter - INFO - Setting timing for the SFINCS model: `2025-01-01 00:00:00 - 2025-01-02 00:00:00`\n2026-02-27 11:23:04 AM - FloodAdapt.SfincsAdapter - INFO - Adding Waterlevel: Model\n2026-02-27 11:23:04 AM - FloodAdapt.OffshoreSfincsAdapter - INFO - Preparing offshore model to generate waterlevels for `slr_pop_growth_seawall_water_square_elev_floodproof_build`\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Setting timing for the SFINCS model: `2025-01-01 00:00:00 - 2025-01-02 00:00:00`\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Adding water level forcing to the offshore model\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Adding Rainfall: Track\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Translating the track of the tropical cyclone `IAN`\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Including rainfall in the spiderweb file\n2026-02-27 11:23:05 AM - FloodAdapt.SfincsAdapter - INFO - Creating spiderweb file for hurricane event `ian_hurricane_event`. This may take a while.\n2026-02-27 11:23:19 AM - FloodAdapt.SfincsAdapter - INFO - Adding spiderweb forcing to Sfincs model: offshore\n2026-02-27 11:23:19 AM - FloodAdapt.SfincsAdapter - INFO - Adding Wind: Track\n2026-02-27 11:23:19 AM - FloodAdapt.SfincsAdapter - INFO - Adding spiderweb forcing to Sfincs model: offshore\n2026-02-27 11:23:19 AM - FloodAdapt.OffshoreSfincsAdapter - INFO - Running offshore model in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\offshore\n2026-02-27 11:23:19 AM - FloodAdapt.SfincsAdapter - INFO - Running SFINCS in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\offshore\n2026-02-27 11:23:25 AM - FloodAdapt.SfincsAdapter - INFO - Reading water levels from offshore model\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Turning off boundary pressure correction in the offshore model\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding Rainfall: Track\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding spiderweb forcing to Sfincs model: overland\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding Wind: Track\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding spiderweb forcing to Sfincs model: overland\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding Discharge: Constant\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Setting discharge forcing for river: river_0\nThe provided timeseries does not cover the entire model time period.\n2026-02-27 11:23:26 AM - FloodAdapt.SfincsAdapter - INFO - Adding Floodwall `seawall_16ft`\nGeoDataFrame : CRS from data catalog does not match CRS of data. The original CRS will be used. Please check your data catalog.\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - INFO - Using floodwall height relative to datum.\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - WARNING - Using uniform height of 16.00 feet above datum.\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - INFO - Adding Greeninfrastructure `water_square`\nGeoDataFrame : CRS from data catalog does not match CRS of data. The original CRS will be used. Please check your data catalog.\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - INFO - Adding Projection `proj_2060`\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - INFO - Adding projected sea level rise `2.89 feet`\n2026-02-27 11:23:27 AM - FloodAdapt.SfincsAdapter - INFO - Adding observation points to the overland flood model\nModel dir already exists and files might be overwritten: D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\overland\\gis.\n2026-02-27 11:23:31 AM - FloodAdapt.SfincsAdapter - INFO - Running SFINCS for single event Scenario `slr_pop_growth_seawall_water_square_elev_floodproof_build`\n2026-02-27 11:23:31 AM - FloodAdapt.SfincsAdapter - INFO - Running SFINCS in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\overland\n2026-02-27 11:24:31 AM - FloodAdapt.SfincsAdapter - INFO - Postprocessing SFINCS for Scenario `slr_pop_growth_seawall_water_square_elev_floodproof_build`\n2026-02-27 11:24:31 AM - FloodAdapt.SfincsAdapter - INFO - Writing water level map to netcdf\n2026-02-27 11:24:41 AM - FloodAdapt.SfincsAdapter - INFO - Writing flood maps to geotiff.\n2026-02-27 11:25:09 AM - FloodAdapt.SfincsAdapter - INFO - Plotting water levels at observation points\n2026-02-27 11:25:19 AM - FloodAdapt.TideGauge - INFO - Retrieving waterlevels for tide gauge 8665530 for 2025-01-01 00:00:00 - 2025-01-02 00:00:00\n2026-02-27 11:25:20 AM - FloodAdapt.SfincsAdapter - INFO - Deleted simulation folder: D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Flooding\\simulations\\overland\n2026-02-27 11:25:20 AM - FloodAdapt.FiatAdapter - INFO - Pre-processing Delft-FIAT model\n2026-02-27 11:25:20 AM - FloodAdapt.FiatAdapter - INFO - Applying socioeconomic changes from projection 'proj_2060'\n2026-02-27 11:25:20 AM - FloodAdapt.FiatAdapter - INFO - Applying population growth of 5.0 %, by creating a new development area using the geometries from D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\static-data\\5_Advanced_Scenario\\new_dev_areas.geojson and a ground floor height of 0.5 feet above 'VerticalReference.datum'.\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Applying population growth of 10.0 %.\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Applying impact measure 'elevated_homes_1ft'\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Elevating 'ALL' type properties in 'D:/a/FloodAdapt/FloodAdapt/docs/_data/examples/charleston_test/input/measures/elevated_homes_1ft/raise_property_polygon.geojson' by 1.00 feet relative to 'VerticalReference.floodmap'.\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Applying impact measure 'floodproof_all_commercial'\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Flood-proofing 'commercial' type properties in 'all' by 2.00 feet.\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Setting hazard to the FloodmapType.water_level map [WindowsPath('D:/a/FloodAdapt/FloodAdapt/docs/_data/examples/charleston_test/output/scenarios/slr_pop_growth_seawall_water_square_elev_floodproof_build/Flooding/max_water_level_map.tif')]\n2026-02-27 11:25:28 AM - FloodAdapt.FiatAdapter - INFO - Running FIAT in D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Impacts\\fiat_model\n2026-02-27 11:25:34 AM - FloodAdapt.FiatAdapter - INFO - Post-processing Delft-FIAT results\n2026-02-27 11:25:34 AM - FloodAdapt.FiatAdapter - INFO - Calculating infometrics\n2026-02-27 11:25:36 AM - FloodAdapt.FiatAdapter - INFO - Creating infographics\n2026-02-27 11:25:37 AM - FloodAdapt.FiatAdapter - INFO - Saving impacts for aggregation areas type: 'Census Blockgroup'\n2026-02-27 11:25:37 AM - FloodAdapt.FiatAdapter - INFO - Saving impacts for aggregation areas type: 'Subdivision'\n2026-02-27 11:25:37 AM - FloodAdapt.FiatAdapter - INFO - Calculating impacts at a building footprint scale\n2026-02-27 11:25:38 AM - FloodAdapt.FiatAdapter - INFO - Calculating road impacts\n2026-02-27 11:25:38 AM - FloodAdapt.FiatAdapter - INFO - Delft-FIAT post-processing complete!\n2026-02-27 11:25:38 AM - FloodAdapt.FiatAdapter - INFO - Deleting D:\\a\\FloodAdapt\\FloodAdapt\\docs\\_data\\examples\\charleston_test\\output\\scenarios\\slr_pop_growth_seawall_water_square_elev_floodproof_build\\Impacts\\fiat_model\n2026-02-27 11:25:38 AM - FloodAdapt.ScenarioRunner - INFO - Finished evaluation of `slr_pop_growth_seawall_water_square_elev_floodproof_build`",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#finished",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#finished",
    "title": "üìò Example: Advanced Scenario",
    "section": "Finished!",
    "text": "Finished!\nCongratulations you created and ran your first FloodAdapt scenario!",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  },
  {
    "objectID": "3_api_docs/examples/scenarios/advanced_scenario.html#output-lets-inspect-the-output",
    "href": "3_api_docs/examples/scenarios/advanced_scenario.html#output-lets-inspect-the-output",
    "title": "üìò Example: Advanced Scenario",
    "section": "Output: üïµÔ∏è‚Äç‚ôÄÔ∏è Let‚Äôs inspect the output",
    "text": "Output: üïµÔ∏è‚Äç‚ôÄÔ∏è Let‚Äôs inspect the output\n\n1. Output files\nIn your scenario output folder you should see the following files: - Flooding: Folder - Impacts: Folder - finished.txt: text file - Infometrics_‚Äúscenario_name‚Äù.csv: csv file of the overall infometrics - Infometrics_‚Äúscenario_name‚Äù‚Äúaggregation_layer‚Äù.csv: csv file of the aggregated areas. You have one file per aggregation level. In this example we have two files. - logfile‚Äùscenario_name‚Äù.log: The log of the scenario run - **‚Äúscenario_name‚Äù_metrics.html**: A metric file of your scenario output\nThe figure below presents a visual overview of all the output files that should be in your database after running the scenario\n\n\n\n\n\n2. Floodmap - Inspect the floodmap\nWe can open and inspect the floodmap geotiff.\n\n# Plot Floodmap geotiff\ngeotiff_map = fa.get_flood_map_geotiff(scenario.name)\nraster = rxr.open_rasterio(geotiff_map, masked=True)\n\nfig, ax = plt.subplots(figsize=(10, 10))\nraster.plot(\n    ax=ax,\n    cmap=\"Blues\",\n    cbar_kwargs={\"label\": \"Flood Depth (feet)\"}\n)\nax.set_title(f\"Flood Map - Scenario: {scenario.name}\")\ncx.add_basemap(ax, crs=raster.rio.crs)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3. Economic Impacts - Inspect the economic impacts on the building level and aggregated\nWe can plot the economic impacts on the building level and on the aggregated level.\n\ngdf_building_impacts = fa.get_building_footprint_impacts(scenario.name)\n\n# Dynamic map for building impacts\ngdf_building_impacts.explore(\n    column=\"Total Damage\",\n    cmap=\"Reds\",\n    legend=True,\n    vmin=0,\n    vmax=60000,\n    legend_kwds={\"caption\": \"Total Damages ($) Buildings\"}\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n## Aggregated Impacts\ngdf_impacts_aggr = fa.get_aggregated_impacts(scenario.name)\ngdf_aggr_lvl1 = gdf_impacts_aggr[\"Subdivision\"]\n\n# Reproject buildings crs to Web Mercator\ngdf_aggr_lvl1 = gdf_aggr_lvl1.to_crs(epsg=3857)\n\n# Dynamic map for aggregated impacts\ngdf_aggr_lvl1.explore(\n    column=\"TotalDamageEvent\",\n    cmap=\"Reds\",\n    legend=True,\n    vmin=0,\n    vmax=10000000,\n    edgecolor=\"k\",\n    legend_kwds={\"caption\": \"Total Damages ($) per aggregation area\"}\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n4. Infometrics & Infographics\nWhich infometrics and infographics to generate can be defined in the infometrics and infographics and configuration file in your database ../Database charleston_full/static/templates/infometrics/, ../Database/charleston_full/static/templates/infographics/\"xyz‚Äù.toml, respectively.\nThe figure below shows the infographics of the scenario we created above.\n\n# Display HTML infographics\nfn = fa.get_infographic(scenario.name)\nHTML(filename=fn)",
    "crumbs": [
      "Examples",
      "Advanced Scenario"
    ]
  }
]